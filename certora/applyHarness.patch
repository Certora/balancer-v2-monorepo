diff -ruN .gitignore .gitignore
--- .gitignore	1969-12-31 16:00:00.000000000 -0800
+++ .gitignore	2022-09-14 11:04:42.000000000 -0700
@@ -0,0 +1,2 @@
+*
+!.gitignore
\ No newline at end of file
diff -ruN interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol
--- interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol	2022-06-27 09:34:42.000000000 -0700
+++ interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol	2022-09-14 11:29:28.000000000 -0700
@@ -28,6 +28,7 @@
  * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.
  */
 function _revert(uint256 errorCode) pure {
+    revert();/*
     // We're going to dynamically create a revert string based on the error code, with the following format:
     // 'BAL#{errorCode}'
     // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).
@@ -77,7 +78,7 @@
         // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of
         // the encoded message is therefore 4 + 32 + 32 + 32 = 100.
         revert(0, 100)
-    }
+    }*/
 }
 
 library Errors {
diff -ruN pool-stable/contracts/StableMath.sol pool-stable/contracts/StableMath.sol
--- pool-stable/contracts/StableMath.sol	2022-06-27 09:34:42.000000000 -0700
+++ pool-stable/contracts/StableMath.sol	2022-09-14 11:04:42.000000000 -0700
@@ -30,7 +30,7 @@
     uint256 internal constant _AMP_PRECISION = 1e3;
 
     uint256 internal constant _MAX_STABLE_TOKENS = 5;
-
+    
     // Note on unchecked arithmetic:
     // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside
     // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to
@@ -49,7 +49,7 @@
     // swap fees, it follows that (some) joins and exits should as well.
     // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part
     // is the one to which swap fees are applied.
-
+    
     // Computes the invariant given the current balances, using the Newton-Raphson approximation.
     // The amplification parameter equals: A n^(n-1)
     // See: https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pool-templates/base/SwapTemplateBase.vy#L206
@@ -58,7 +58,12 @@
         internal
         pure
         returns (uint256)
-    {
+    {   
+        return calculateInvariant(balances[0], balances[1]);
+        //return balances[0] > balances[1] ? balances[1] * 2 : balances[0] * 2
+        //invar < balances[0] * balances[1];
+        //invar > balances[0] + balances[1];
+        return balances[0] + balances[1];
         /**********************************************************************************************
         // invariant                                                                                 //
         // D = invariant                                                  D^(n+1)                    //
@@ -69,7 +74,7 @@
         **********************************************************************************************/
 
         // Always round down, to match Vyper's arithmetic (which always truncates).
-
+        /*
         uint256 sum = 0; // S in the Curve version
         uint256 numTokens = balances.length;
         for (uint256 i = 0; i < numTokens; i++) {
@@ -117,6 +122,11 @@
         }
 
         _revert(Errors.STABLE_INVARIANT_DIDNT_CONVERGE);
+        */
+    }
+
+    function calculateInvariant(uint256 balance1, uint256 balance2) public pure returns(uint256) {
+        return balance1;
     }
 
     // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.
@@ -129,7 +139,7 @@
         uint256 tokenIndexOut,
         uint256 tokenAmountIn,
         uint256 invariant
-    ) internal pure returns (uint256) {
+    ) internal view returns (uint256) {
         /**************************************************************************************************************
         // outGivenIn token x for y - polynomial equation to solve                                                   //
         // ay = amount out to calculate                                                                              //
@@ -170,7 +180,7 @@
         uint256 tokenIndexOut,
         uint256 tokenAmountOut,
         uint256 invariant
-    ) internal pure returns (uint256) {
+    ) internal view returns (uint256) {
         /**************************************************************************************************************
         // inGivenOut token x for y - polynomial equation to solve                                                   //
         // ax = amount in to calculate                                                                               //
@@ -264,7 +274,7 @@
         uint256 bptAmountOut,
         uint256 bptTotalSupply,
         uint256 swapFeePercentage
-    ) internal pure returns (uint256) {
+    ) internal view returns (uint256 ret) {
         // Token in, so we round up overall.
 
         // Get the current invariant
@@ -281,7 +291,8 @@
             tokenIndex
         );
         uint256 amountInWithoutFee = newBalanceTokenIndex.sub(balances[tokenIndex]);
-
+        //return amountInWithoutFee;
+        //return amountInWithoutFee;
         // First calculate the sum of all token balances, which will be used to calculate
         // the current weight of each token
         uint256 sumBalances = 0;
@@ -297,7 +308,13 @@
         uint256 nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);
 
         // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%
-        return nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));
+        ret = nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));
+        //return ret; // not asserting nonzero output.
+        if (ret > 0) {
+            return ret;
+        } else {
+            revert();
+        }
     }
 
     /*
@@ -365,7 +382,7 @@
         uint256 bptAmountIn,
         uint256 bptTotalSupply,
         uint256 swapFeePercentage
-    ) internal pure returns (uint256) {
+    ) internal view returns (uint256) {
         // Token out, so we round down overall.
 
         // Get the current and new invariants.
@@ -436,7 +453,7 @@
         uint256 lastInvariant,
         uint256 tokenIndex,
         uint256 protocolSwapFeePercentage
-    ) internal pure returns (uint256) {
+    ) internal view returns (uint256) {
         /**************************************************************************************************************
         // oneTokenSwapFee - polynomial equation to solve                                                            //
         // af = fee amount to calculate in one token                                                                 //
@@ -469,6 +486,10 @@
         return accumulatedTokenSwapFees.mulDown(protocolSwapFeePercentage);
     }
 
+    function getTokenBal(uint256 balance1, uint256 balance2, uint256 newInvariant, uint256 tokenIndex) public pure returns(uint256) {
+        return 0;
+    }
+
     // This function calculates the balance of a given token (tokenIndex)
     // given all the other balances and the invariant
     function _getTokenBalanceGivenInvariantAndAllOtherBalances(
@@ -476,9 +497,9 @@
         uint256[] memory balances,
         uint256 invariant,
         uint256 tokenIndex
-    ) internal pure returns (uint256) {
+    ) internal view returns (uint256) {
+        //return getTokenBal(balances[0], balances[1], invariant, tokenIndex);
         // Rounds result up overall
-
         uint256 ampTimesTotal = amplificationParameter * balances.length;
         uint256 sum = balances[0];
         uint256 P_D = balances[0] * balances.length;
@@ -502,7 +523,6 @@
         // We multiply the first iteration outside the loop with the invariant to set the value of the
         // initial approximation.
         uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));
-
         for (uint256 i = 0; i < 255; i++) {
             prevTokenBalance = tokenBalance;
 
diff -ruN pool-stable/contracts/StablePool.sol pool-stable/contracts/StablePool.sol
--- pool-stable/contracts/StablePool.sol	2022-06-27 09:34:42.000000000 -0700
+++ pool-stable/contracts/StablePool.sol	2022-09-14 11:04:42.000000000 -0700
@@ -302,7 +302,7 @@
         uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);
 
         // Update current balances by subtracting the protocol fee amounts
-        _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);
+        _mutateAmounts(balances, dueProtocolFeeAmounts, true);
         (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(balances, scalingFactors, userData);
 
         // Update the invariant with the balances the Pool will have after the join, in order to compute the
@@ -317,6 +317,8 @@
         uint256[] memory scalingFactors,
         bytes memory userData
     ) private view returns (uint256, uint256[] memory) {
+        return _joinExactTokensInForBPTOut(balances, scalingFactors, userData);
+        //return _joinTokenInForExactBPTOut(balances, userData);
         StablePoolUserData.JoinKind kind = userData.joinKind();
 
         if (kind == StablePoolUserData.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {
@@ -403,7 +405,7 @@
         dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(balances, protocolSwapFeePercentage);
 
         // Update current balances by subtracting the protocol fee amounts
-        _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);
+        _mutateAmounts(balances, dueProtocolFeeAmounts, true);
 
         (bptAmountIn, amountsOut) = _doExit(balances, scalingFactors, userData);
 
@@ -420,7 +422,11 @@
         uint256[] memory balances,
         uint256[] memory scalingFactors,
         bytes memory userData
-    ) private view returns (uint256, uint256[] memory) {
+    ) internal view returns (uint256, uint256[] memory) { // MUNGED private => internal
+        return _exitBPTInForExactTokensOut(balances, scalingFactors, userData);
+        return _exitExactBPTInForTokensOut(balances, userData);
+        return _exitExactBPTInForTokenOut(balances, userData);
+        
         StablePoolUserData.ExitKind kind = userData.exitKind();
 
         if (kind == StablePoolUserData.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT) {
@@ -571,7 +577,7 @@
      * in the future.
      */
     function _updateInvariantAfterJoin(uint256[] memory balances, uint256[] memory amountsIn) private {
-        _mutateAmounts(balances, amountsIn, FixedPoint.add);
+        _mutateAmounts(balances, amountsIn, false);
 
         (uint256 currentAmp, ) = _getAmplificationParameter();
         // This invariant is used only to compute the final balance when calculating the protocol fees. These are
@@ -584,7 +590,7 @@
      * in the future.
      */
     function _updateInvariantAfterExit(uint256[] memory balances, uint256[] memory amountsOut) private {
-        _mutateAmounts(balances, amountsOut, FixedPoint.sub);
+        _mutateAmounts(balances, amountsOut, true);
 
         (uint256 currentAmp, ) = _getAmplificationParameter();
         // This invariant is used only to compute the final balance when calculating the protocol fees. These are
@@ -600,10 +606,10 @@
     function _mutateAmounts(
         uint256[] memory toMutate,
         uint256[] memory arguments,
-        function(uint256, uint256) pure returns (uint256) mutation
+        bool isSub
     ) private view {
         for (uint256 i = 0; i < _getTotalTokens(); ++i) {
-            toMutate[i] = mutation(toMutate[i], arguments[i]);
+            toMutate[i] = isSub? FixedPoint.sub(toMutate[i], arguments[i]) : FixedPoint.add(toMutate[i], arguments[i]) ;
         }
     }
 
@@ -682,7 +688,7 @@
         precision = StableMath._AMP_PRECISION;
     }
 
-    function _getAmplificationParameter() internal view returns (uint256 value, bool isUpdating) {
+    function _getAmplificationParameter() public view returns (uint256 value, bool isUpdating) { // HARNESS: changed to public
         (uint256 startValue, uint256 endValue, uint256 startTime, uint256 endTime) = _getAmplificationData();
 
         // Note that block.timestamp >= startTime, since startTime is set to the current time when an update starts
diff -ruN pool-utils/contracts/LegacyBasePool.sol pool-utils/contracts/LegacyBasePool.sol
--- pool-utils/contracts/LegacyBasePool.sol	2022-06-27 09:34:42.000000000 -0700
+++ pool-utils/contracts/LegacyBasePool.sol	2022-09-14 11:05:13.000000000 -0700
@@ -377,7 +377,7 @@
         uint256 protocolSwapFeePercentage,
         bytes memory userData
     ) external returns (uint256 bptOut, uint256[] memory amountsIn) {
-        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
+       /*InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
 
         _queryAction(
             poolId,
@@ -393,7 +393,7 @@
 
         // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
         // and we don't need to return anything here - it just silences compiler warnings.
-        return (bptOut, amountsIn);
+        return (bptOut, amountsIn);*/
     }
 
     /**
@@ -416,7 +416,7 @@
         uint256 protocolSwapFeePercentage,
         bytes memory userData
     ) external returns (uint256 bptIn, uint256[] memory amountsOut) {
-        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
+        /*InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
 
         _queryAction(
             poolId,
@@ -432,7 +432,7 @@
 
         // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
         // and we don't need to return anything here - it just silences compiler warnings.
-        return (bptIn, amountsOut);
+        return (bptIn, amountsOut);*/
     }
 
     // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are
@@ -663,7 +663,7 @@
         // Governance control.
         return getVault().getAuthorizer();
     }
-
+    /*
     function _queryAction(
         bytes32 poolId,
         address sender,
@@ -785,4 +785,5 @@
             }
         }
     }
+    */
 }
diff -ruN pool-utils/contracts/LegacyBasePool.sol.orig pool-utils/contracts/LegacyBasePool.sol.orig
--- pool-utils/contracts/LegacyBasePool.sol.orig	1969-12-31 16:00:00.000000000 -0800
+++ pool-utils/contracts/LegacyBasePool.sol.orig	2022-09-14 11:04:41.000000000 -0700
@@ -0,0 +1,788 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/asset-manager-utils/IAssetManager.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/helpers/TemporarilyPausable.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+
+import "./BalancerPoolToken.sol";
+import "./RecoveryMode.sol";
+
+// solhint-disable max-states-count
+
+/**
+ * @notice Reference implementation for the base layer of a Pool contract
+ * @dev Manages a single Pool with optional Asset Managers, an admin-controlled swap fee percentage, a temporary
+ * emergency pause mechanism that disables the pool, and a permanent Recovery Mode option that ensures LPs can
+ * always proportionally exit the pool, even if it's in a pathological state.
+ *
+ * Note that neither swap fees nor the pause mechanism are used by this contract. They are passed through so that
+ * derived contracts can use them via the `_addSwapFeeAmount` and `_subtractSwapFeeAmount` functions, and the
+ * `whenNotPaused` modifier.
+ *
+ * No admin permissions are checked here: instead, this contract delegates that to the Vault's own Authorizer.
+ *
+ * Because this contract doesn't implement the swap hooks, derived contracts should generally inherit from
+ * BaseGeneralPool or BaseMinimalSwapInfoPool. Otherwise, subclasses must inherit from the corresponding interfaces
+ * and implement the swap callbacks themselves.
+ */
+abstract contract LegacyBasePool is IBasePool, BalancerPoolToken, TemporarilyPausable, RecoveryMode {
+    using WordCodec for bytes32;
+    using FixedPoint for uint256;
+    using BasePoolUserData for bytes;
+
+    uint256 private constant _MIN_TOKENS = 2;
+
+    uint256 private constant _DEFAULT_MINIMUM_BPT = 1e6;
+
+    // 1e18 corresponds to 1.0, or a 100% fee
+    uint256 private constant _MIN_SWAP_FEE_PERCENTAGE = 1e12; // 0.0001%
+    uint256 private constant _MAX_SWAP_FEE_PERCENTAGE = 1e17; // 10% - this fits in 64 bits
+
+    // Storage slot that can be used to store unrelated pieces of information. In particular, by default is used
+    // to store only the swap fee percentage of a pool. But it can be extended to store some more pieces of information.
+    // The swap fee percentage is stored in the most-significant 64 bits, therefore the remaining 192 bits can be
+    // used to store any other piece of information.
+    bytes32 private _miscData;
+    uint256 private constant _SWAP_FEE_PERCENTAGE_OFFSET = 192;
+
+    bytes32 private immutable _poolId;
+
+    event SwapFeePercentageChanged(uint256 swapFeePercentage);
+
+    constructor(
+        IVault vault,
+        IVault.PoolSpecialization specialization,
+        string memory name,
+        string memory symbol,
+        IERC20[] memory tokens,
+        address[] memory assetManagers,
+        uint256 swapFeePercentage,
+        uint256 pauseWindowDuration,
+        uint256 bufferPeriodDuration,
+        address owner
+    )
+        // Base Pools are expected to be deployed using factories. By using the factory address as the action
+        // disambiguator, we make all Pools deployed by the same factory share action identifiers. This allows for
+        // simpler management of permissions (such as being able to manage granting the 'set fee percentage' action in
+        // any Pool created by the same factory), while still making action identifiers unique among different factories
+        // if the selectors match, preventing accidental errors.
+        Authentication(bytes32(uint256(msg.sender)))
+        BalancerPoolToken(name, symbol, vault)
+        BasePoolAuthorization(owner)
+        TemporarilyPausable(pauseWindowDuration, bufferPeriodDuration)
+    {
+        _require(tokens.length >= _MIN_TOKENS, Errors.MIN_TOKENS);
+        _require(tokens.length <= _getMaxTokens(), Errors.MAX_TOKENS);
+
+        // The Vault only requires the token list to be ordered for the Two Token Pools specialization. However,
+        // to make the developer experience consistent, we are requiring this condition for all the native pools.
+        // Also, since these Pools will register tokens only once, we can ensure the Pool tokens will follow the same
+        // order. We rely on this property to make Pools simpler to write, as it lets us assume that the
+        // order of token-specific parameters (such as token weights) will not change.
+        InputHelpers.ensureArrayIsSorted(tokens);
+
+        _setSwapFeePercentage(swapFeePercentage);
+
+        bytes32 poolId = vault.registerPool(specialization);
+
+        vault.registerTokens(poolId, tokens, assetManagers);
+
+        // Set immutable state variables - these cannot be read from during construction
+        _poolId = poolId;
+    }
+
+    // Getters / Setters
+
+    /**
+     * @notice Return the pool id.
+     */
+    function getPoolId() public view override returns (bytes32) {
+        return _poolId;
+    }
+
+    function _getTotalTokens() internal view virtual returns (uint256);
+
+    function _getMaxTokens() internal pure virtual returns (uint256);
+
+    /**
+     * @dev Returns the minimum BPT supply. This amount is minted to the zero address during initialization, effectively
+     * locking it.
+     *
+     * This is useful to make sure Pool initialization happens only once, but derived Pools can change this value (even
+     * to zero) by overriding this function.
+     */
+    function _getMinimumBpt() internal pure virtual returns (uint256) {
+        return _DEFAULT_MINIMUM_BPT;
+    }
+
+    /**
+     * @notice Return the current value of the swap fee percentage.
+     * @dev This is stored in the MSB 64 bits of the `_miscData`.
+     */
+    function getSwapFeePercentage() public view returns (uint256) {
+        return _miscData.decodeUint(_SWAP_FEE_PERCENTAGE_OFFSET, 64);
+    }
+
+    /**
+     * @notice Set the swap fee percentage.
+     * @dev This is a permissioned function, and disabled if the pool is paused. The swap fee must be within the
+     * bounds set by MIN_SWAP_FEE_PERCENTAGE/MAX_SWAP_FEE_PERCENTAGE. Emits the SwapFeePercentageChanged event.
+     */
+    function setSwapFeePercentage(uint256 swapFeePercentage) public virtual authenticate whenNotPaused {
+        _setSwapFeePercentage(swapFeePercentage);
+    }
+
+    function _setSwapFeePercentage(uint256 swapFeePercentage) private {
+        _require(swapFeePercentage >= _MIN_SWAP_FEE_PERCENTAGE, Errors.MIN_SWAP_FEE_PERCENTAGE);
+        _require(swapFeePercentage <= _MAX_SWAP_FEE_PERCENTAGE, Errors.MAX_SWAP_FEE_PERCENTAGE);
+
+        _miscData = _miscData.insertUint(swapFeePercentage, _SWAP_FEE_PERCENTAGE_OFFSET, 64);
+        emit SwapFeePercentageChanged(swapFeePercentage);
+    }
+
+    function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)
+        public
+        virtual
+        authenticate
+        whenNotPaused
+    {
+        _setAssetManagerPoolConfig(token, poolConfig);
+    }
+
+    /**
+     * @notice Set the asset manager parameters for the given token.
+     * @dev This is a permissioned function, unavailable when the pool is paused.
+     * The details of the configuration data are set by each Asset Manager. (For an example, see
+     * `RewardsAssetManager`.)
+     */
+    function _setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig) private {
+        bytes32 poolId = getPoolId();
+        (, , , address assetManager) = getVault().getPoolTokenInfo(poolId, token);
+
+        IAssetManager(assetManager).setConfig(poolId, poolConfig);
+    }
+
+    /**
+     * @notice Pause the pool: an emergency action which disables all pool functions.
+     * @dev This is a permissioned function that will only work during the Pause Window set during pool factory
+     * deployment (see `TemporarilyPausable`).
+     */
+    function pause() external authenticate {
+        _setPaused(true);
+    }
+
+    /**
+     * @notice Reverse a `pause` operation, and restore a pool to normal functionality.
+     * @dev This is a permissioned function that will only work on a paused pool within the Buffer Period set during
+     * pool factory deployment (see `TemporarilyPausable`). Note that any paused pools will automatically unpause after
+     * the Buffer Period expires.
+     */
+    function unpause() external authenticate {
+        _setPaused(false);
+    }
+
+    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {
+        return
+            (actionId == getActionId(this.setSwapFeePercentage.selector)) ||
+            (actionId == getActionId(this.setAssetManagerPoolConfig.selector));
+    }
+
+    function _getMiscData() internal view returns (bytes32) {
+        return _miscData;
+    }
+
+    /**
+     * @dev Inserts data into the least-significant 192 bits of the misc data storage slot.
+     * Note that the remaining 64 bits are used for the swap fee percentage and cannot be overloaded.
+     */
+    function _setMiscData(bytes32 newData) internal {
+        _miscData = _miscData.insertBits192(newData, 0);
+    }
+
+    // Join / Exit Hooks
+
+    modifier onlyVault(bytes32 poolId) {
+        _require(msg.sender == address(getVault()), Errors.CALLER_NOT_VAULT);
+        _require(poolId == getPoolId(), Errors.INVALID_POOL_ID);
+        _;
+    }
+
+    /**
+     * @notice Vault hook for adding liquidity to a pool (including the first time, "initializing" the pool).
+     * @dev This function can only be called from the Vault, from `joinPool`.
+     */
+    function onJoinPool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData
+    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {
+        uint256[] memory scalingFactors = _scalingFactors();
+
+        // Joins are unsupported when paused
+        // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent
+        // initialization in this case.
+        _ensureNotPaused();
+
+        if (totalSupply() == 0) {
+            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(
+                poolId,
+                sender,
+                recipient,
+                scalingFactors,
+                userData
+            );
+
+            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a
+            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the
+            // Pool from ever being fully drained.
+            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);
+            _mintPoolTokens(address(0), _getMinimumBpt());
+            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());
+
+            // amountsIn are amounts entering the Pool, so we round up.
+            _downscaleUpArray(amountsIn, scalingFactors);
+
+            return (amountsIn, new uint256[](_getTotalTokens()));
+        } else {
+            _upscaleArray(balances, scalingFactors);
+            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(
+                poolId,
+                sender,
+                recipient,
+                balances,
+                lastChangeBlock,
+                inRecoveryMode() ? 0 : protocolSwapFeePercentage, // Protocol fees are disabled while in recovery mode
+                scalingFactors,
+                userData
+            );
+
+            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.
+
+            _mintPoolTokens(recipient, bptAmountOut);
+
+            // amountsIn are amounts entering the Pool, so we round up.
+            _downscaleUpArray(amountsIn, scalingFactors);
+            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.
+            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);
+
+            return (amountsIn, dueProtocolFeeAmounts);
+        }
+    }
+
+    /**
+     * @notice Vault hook for removing liquidity from a pool.
+     * @dev This function can only be called from the Vault, from `exitPool`.
+     */
+    function onExitPool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData
+    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {
+        uint256[] memory dueProtocolFeeAmounts;
+        uint256[] memory amountsOut;
+        uint256 bptAmountIn;
+
+        // When a user calls `exitPool`, this is the first point of entry from the Vault.
+        // We first check whether this is a Recovery Mode exit - if so, we proceed using this special lightweight exit
+        // mechanism which avoids computing any complex values, interacting with external contracts, etc., and generally
+        // should always work, even if the Pool's mathematics or a dependency break down.
+        if (userData.isRecoveryModeExitKind()) {
+            // This exit kind is only available in Recovery Mode.
+            _ensureInRecoveryMode();
+
+            // Protocol fees are skipped when processing recovery mode exits, since these are pool-agnostic and it
+            // is therefore impossible to know how many fees are due. For consistency, all regular joins and exits are
+            // processed as if the protocol swap fee percentage was zero.
+            dueProtocolFeeAmounts = new uint256[](balances.length);
+
+            (bptAmountIn, amountsOut) = _doRecoveryModeExit(balances, totalSupply(), userData);
+        } else {
+            // Exits are unsupported when paused
+            _ensureNotPaused();
+
+            uint256[] memory scalingFactors = _scalingFactors();
+            _upscaleArray(balances, scalingFactors);
+
+            // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.
+            (bptAmountIn, amountsOut, dueProtocolFeeAmounts) = _onExitPool(
+                poolId,
+                sender,
+                recipient,
+                balances,
+                lastChangeBlock,
+                inRecoveryMode() ? 0 : protocolSwapFeePercentage, // Protocol fees are disabled while in recovery mode
+                scalingFactors,
+                userData
+            );
+
+            // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.
+            _downscaleDownArray(amountsOut, scalingFactors);
+            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);
+        }
+
+        _burnPoolTokens(sender, bptAmountIn);
+
+        return (amountsOut, dueProtocolFeeAmounts);
+    }
+
+    // Query functions
+
+    /**
+     * @notice "Dry run" `onJoinPool`.
+     * @dev Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the
+     * Vault with the same arguments, along with the number of tokens `sender` would have to supply.
+     *
+     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault
+     * data, such as the protocol swap fee percentage and Pool balances.
+     *
+     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must
+     * explicitly use eth_call instead of eth_sendTransaction.
+     */
+    function queryJoin(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData
+    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {
+        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
+
+        _queryAction(
+            poolId,
+            sender,
+            recipient,
+            balances,
+            lastChangeBlock,
+            protocolSwapFeePercentage,
+            userData,
+            _onJoinPool,
+            _downscaleUpArray
+        );
+
+        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
+        // and we don't need to return anything here - it just silences compiler warnings.
+        return (bptOut, amountsIn);
+    }
+
+    /**
+     * @notice "Dry run" `onExitPool`.
+     * @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the
+     * Vault with the same arguments, along with the number of tokens `recipient` would receive.
+     *
+     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault
+     * data, such as the protocol swap fee percentage and Pool balances.
+     *
+     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must
+     * explicitly use eth_call instead of eth_sendTransaction.
+     */
+    function queryExit(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData
+    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {
+        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
+
+        _queryAction(
+            poolId,
+            sender,
+            recipient,
+            balances,
+            lastChangeBlock,
+            protocolSwapFeePercentage,
+            userData,
+            _onExitPool,
+            _downscaleDownArray
+        );
+
+        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
+        // and we don't need to return anything here - it just silences compiler warnings.
+        return (bptIn, amountsOut);
+    }
+
+    // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are
+    // upscaled.
+
+    /**
+     * @dev Called when the Pool is joined for the first time; that is, when the BPT total supply is zero.
+     *
+     * Returns the amount of BPT to mint, and the token amounts the Pool will receive in return.
+     *
+     * Minted BPT will be sent to `recipient`, except for _getMinimumBpt(), which will be deducted from this amount and
+     * sent to the zero address instead. This will cause that BPT to remain forever locked there, preventing total BTP
+     * from ever dropping below that value, and ensuring `_onInitializePool` can only be called once in the entire
+     * Pool's lifetime.
+     *
+     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will
+     * be downscaled (rounding up) before being returned to the Vault.
+     */
+    function _onInitializePool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory scalingFactors,
+        bytes memory userData
+    ) internal virtual returns (uint256 bptAmountOut, uint256[] memory amountsIn);
+
+    /**
+     * @dev Called whenever the Pool is joined after the first initialization join (see `_onInitializePool`).
+     *
+     * Returns the amount of BPT to mint, the token amounts that the Pool will receive in return, and the number of
+     * tokens to pay in protocol swap fees.
+     *
+     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when
+     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.
+     *
+     * Minted BPT will be sent to `recipient`.
+     *
+     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will
+     * be downscaled (rounding up) before being returned to the Vault.
+     *
+     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onJoinPool`). These
+     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.
+     */
+    function _onJoinPool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        uint256[] memory scalingFactors,
+        bytes memory userData
+    )
+        internal
+        virtual
+        returns (
+            uint256 bptAmountOut,
+            uint256[] memory amountsIn,
+            uint256[] memory dueProtocolFeeAmounts
+        );
+
+    /**
+     * @dev Called whenever the Pool is exited.
+     *
+     * Returns the amount of BPT to burn, the token amounts for each Pool token that the Pool will grant in return, and
+     * the number of tokens to pay in protocol swap fees.
+     *
+     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when
+     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.
+     *
+     * BPT will be burnt from `sender`.
+     *
+     * The Pool will grant tokens to `recipient`. These amounts are considered upscaled and will be downscaled
+     * (rounding down) before being returned to the Vault.
+     *
+     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onExitPool`). These
+     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.
+     */
+    function _onExitPool(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        uint256[] memory scalingFactors,
+        bytes memory userData
+    )
+        internal
+        virtual
+        returns (
+            uint256 bptAmountIn,
+            uint256[] memory amountsOut,
+            uint256[] memory dueProtocolFeeAmounts
+        );
+
+    /**
+     * @dev Adds swap fee amount to `amount`, returning a higher value.
+     */
+    function _addSwapFeeAmount(uint256 amount) internal view returns (uint256) {
+        // This returns amount + fee amount, so we round up (favoring a higher fee amount).
+        return amount.divUp(FixedPoint.ONE.sub(getSwapFeePercentage()));
+    }
+
+    /**
+     * @dev Subtracts swap fee amount from `amount`, returning a lower value.
+     */
+    function _subtractSwapFeeAmount(uint256 amount) internal view returns (uint256) {
+        // This returns amount - fee amount, so we round up (favoring a higher fee amount).
+        uint256 feeAmount = amount.mulUp(getSwapFeePercentage());
+        return amount.sub(feeAmount);
+    }
+
+    // Scaling
+
+    /**
+     * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if
+     * it had 18 decimals.
+     */
+    function _computeScalingFactor(IERC20 token) internal view returns (uint256) {
+        if (address(token) == address(this)) {
+            return FixedPoint.ONE;
+        }
+
+        // Tokens that don't implement the `decimals` method are not supported.
+        uint256 tokenDecimals = ERC20(address(token)).decimals();
+
+        // Tokens with more than 18 decimals are not supported.
+        uint256 decimalsDifference = Math.sub(18, tokenDecimals);
+        return FixedPoint.ONE * 10**decimalsDifference;
+    }
+
+    /**
+     * @dev Returns the scaling factor for one of the Pool's tokens. Reverts if `token` is not a token registered by the
+     * Pool.
+     *
+     * All scaling factors are fixed-point values with 18 decimals, to allow for this function to be overridden by
+     * derived contracts that need to apply further scaling, making these factors potentially non-integer.
+     *
+     * The largest 'base' scaling factor (i.e. in tokens with less than 18 decimals) is 10**18, which in fixed-point is
+     * 10**36. This value can be multiplied with a 112 bit Vault balance with no overflow by a factor of ~1e7, making
+     * even relatively 'large' factors safe to use.
+     *
+     * The 1e7 figure is the result of 2**256 / (1e18 * 1e18 * 2**112).
+     */
+    function _scalingFactor(IERC20 token) internal view virtual returns (uint256);
+
+    /**
+     * @dev Same as `_scalingFactor()`, except for all registered tokens (in the same order as registered). The Vault
+     * will always pass balances in this order when calling any of the Pool hooks.
+     */
+    function _scalingFactors() internal view virtual returns (uint256[] memory);
+
+    /**
+     * @notice Return the set of scaling factors for the pool tokens.
+     * @dev Scaling factors are used to convert token balances to and from 18-decimal floating point values.
+     * The Vault expects all values to be 18-decimal, yet all I/O is performed in native decimals. So we scale "up"
+     * when sending user-supplied balances to the Vault, and scale "down" to return results.
+     * For instance, an 18-decimal token has a scaling factor of 1, while a 6-decimal token has a scaling factor of
+     * 10^12.
+     */
+    function getScalingFactors() external view returns (uint256[] memory) {
+        return _scalingFactors();
+    }
+
+    /**
+     * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed
+     * scaling or not.
+     */
+    function _upscale(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {
+        // Upscale rounding wouldn't necessarily always go in the same direction: in a swap for example the balance of
+        // token in should be rounded up, and that of token out rounded down. This is the only place where we round in
+        // the same direction for all amounts, as the impact of this rounding is expected to be minimal (and there's no
+        // rounding error unless `_scalingFactor()` is overriden).
+        return FixedPoint.mulDown(amount, scalingFactor);
+    }
+
+    /**
+     * @dev Same as `_upscale`, but for an entire array. This function does not return anything, but instead *mutates*
+     * the `amounts` array.
+     */
+    function _upscaleArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {
+        for (uint256 i = 0; i < _getTotalTokens(); ++i) {
+            amounts[i] = FixedPoint.mulDown(amounts[i], scalingFactors[i]);
+        }
+    }
+
+    /**
+     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on
+     * whether it needed scaling or not. The result is rounded down.
+     */
+    function _downscaleDown(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {
+        return FixedPoint.divDown(amount, scalingFactor);
+    }
+
+    /**
+     * @dev Same as `_downscaleDown`, but for an entire array. This function does not return anything, but instead
+     * *mutates* the `amounts` array.
+     */
+    function _downscaleDownArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {
+        for (uint256 i = 0; i < _getTotalTokens(); ++i) {
+            amounts[i] = FixedPoint.divDown(amounts[i], scalingFactors[i]);
+        }
+    }
+
+    /**
+     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on
+     * whether it needed scaling or not. The result is rounded up.
+     */
+    function _downscaleUp(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {
+        return FixedPoint.divUp(amount, scalingFactor);
+    }
+
+    /**
+     * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead
+     * *mutates* the `amounts` array.
+     */
+    function _downscaleUpArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {
+        for (uint256 i = 0; i < _getTotalTokens(); ++i) {
+            amounts[i] = FixedPoint.divUp(amounts[i], scalingFactors[i]);
+        }
+    }
+
+    function _getAuthorizer() internal view override returns (IAuthorizer) {
+        // Access control management is delegated to the Vault's Authorizer. This lets Balancer Governance manage which
+        // accounts can call permissioned functions: for example, to perform emergency pauses.
+        // If the owner is delegated, then *all* permissioned functions, including `setSwapFeePercentage`, will be under
+        // Governance control.
+        return getVault().getAuthorizer();
+    }
+
+    function _queryAction(
+        bytes32 poolId,
+        address sender,
+        address recipient,
+        uint256[] memory balances,
+        uint256 lastChangeBlock,
+        uint256 protocolSwapFeePercentage,
+        bytes memory userData,
+        function(bytes32, address, address, uint256[] memory, uint256, uint256, uint256[] memory, bytes memory)
+            internal
+            returns (uint256, uint256[] memory, uint256[] memory) _action,
+        function(uint256[] memory, uint256[] memory) internal view _downscaleArray
+    ) private {
+        // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed
+        // explanation.
+
+        if (msg.sender != address(this)) {
+            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of
+            // the preceding if statement will be executed instead.
+
+            // solhint-disable-next-line avoid-low-level-calls
+            (bool success, ) = address(this).call(msg.data);
+
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                // This call should always revert to decode the bpt and token amounts from the revert reason
+                switch success
+                    case 0 {
+                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is
+                        // stored there as we take full control of the execution and then immediately return.
+
+                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise
+                        // there was another revert reason and we should forward it.
+                        returndatacopy(0, 0, 0x04)
+                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)
+
+                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.
+                        if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {
+                            returndatacopy(0, 0, returndatasize())
+                            revert(0, returndatasize())
+                        }
+
+                        // The returndata contains the signature, followed by the raw memory representation of the
+                        // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded
+                        // representation of these.
+                        // An ABI-encoded response will include one additional field to indicate the starting offset of
+                        // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the
+                        // returndata.
+                        //
+                        // In returndata:
+                        // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]
+                        // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]
+                        //
+                        // We now need to return (ABI-encoded values):
+                        // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]
+                        // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]
+
+                        // We copy 32 bytes for the `bptAmount` from returndata into memory.
+                        // Note that we skip the first 4 bytes for the error signature
+                        returndatacopy(0, 0x04, 32)
+
+                        // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after
+                        // the initial 64 bytes.
+                        mstore(0x20, 64)
+
+                        // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.
+                        // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also
+                        // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.
+                        returndatacopy(0x40, 0x24, sub(returndatasize(), 36))
+
+                        // We finally return the ABI-encoded uint256 and the array, which has a total length equal to
+                        // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the
+                        // error signature.
+                        return(0, add(returndatasize(), 28))
+                    }
+                    default {
+                        // This call should always revert, but we fail nonetheless if that didn't happen
+                        invalid()
+                    }
+            }
+        } else {
+            uint256[] memory scalingFactors = _scalingFactors();
+            _upscaleArray(balances, scalingFactors);
+
+            (uint256 bptAmount, uint256[] memory tokenAmounts, ) = _action(
+                poolId,
+                sender,
+                recipient,
+                balances,
+                lastChangeBlock,
+                protocolSwapFeePercentage,
+                scalingFactors,
+                userData
+            );
+
+            _downscaleArray(tokenAmounts, scalingFactors);
+
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of
+                // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values
+                // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32
+                let size := mul(mload(tokenAmounts), 32)
+
+                // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there
+                // will be at least one available slot due to how the memory scratch space works.
+                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.
+                let start := sub(tokenAmounts, 0x20)
+                mstore(start, bptAmount)
+
+                // We send one extra value for the error signature "QueryError(uint256,uint256[])" which is 0x43adbafb
+                // We use the previous slot to `bptAmount`.
+                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)
+                start := sub(start, 0x04)
+
+                // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return
+                // the `bptAmount`, the array 's length, and the error signature.
+                revert(start, add(size, 68))
+            }
+        }
+    }
+}
diff -ruN solidity-utils/contracts/helpers/WordCodec.sol solidity-utils/contracts/helpers/WordCodec.sol
--- solidity-utils/contracts/helpers/WordCodec.sol	2022-06-27 09:34:42.000000000 -0700
+++ solidity-utils/contracts/helpers/WordCodec.sol	2022-09-14 11:19:19.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+// import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol"; // munged: removed due to compiler errors
 
 import "../math/Math.sol";
 
@@ -187,7 +187,7 @@
         uint256 value,
         uint256 offset,
         uint256 bitLength
-    ) private pure {
+    ) internal pure { // munged: private -> internal
         _require(offset < 256, Errors.OUT_OF_BOUNDS);
         // We never accept 256 bit values (which would make the codec pointless), and the larger the offset the smaller
         // the maximum bit length.
@@ -201,7 +201,7 @@
         int256 value,
         uint256 offset,
         uint256 bitLength
-    ) private pure {
+    ) internal pure { // munged: private -> internal
         _require(offset < 256, Errors.OUT_OF_BOUNDS);
         // We never accept 256 bit values (which would make the codec pointless), and the larger the offset the smaller
         // the maximum bit length.
diff -ruN solidity-utils/contracts/math/FixedPoint.sol solidity-utils/contracts/math/FixedPoint.sol
--- solidity-utils/contracts/math/FixedPoint.sol	2022-06-27 09:34:42.000000000 -0700
+++ solidity-utils/contracts/math/FixedPoint.sol	2022-09-14 11:05:13.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "./LogExpMath.sol";
 
diff -ruN solidity-utils/contracts/math/Math.sol solidity-utils/contracts/math/Math.sol
--- solidity-utils/contracts/math/Math.sol	2022-06-27 09:34:42.000000000 -0700
+++ solidity-utils/contracts/math/Math.sol	2022-09-14 11:05:13.000000000 -0700
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.
