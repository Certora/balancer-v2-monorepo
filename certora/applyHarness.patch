diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts .gitignore .gitignore
--- .gitignore	1969-12-31 16:00:00.000000000 -0800
+++ .gitignore	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,2 @@
+*
+!.gitignore
\ No newline at end of file
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts distributors/contracts/MerkleOrchard.sol distributors/contracts/MerkleOrchard.sol
--- distributors/contracts/MerkleOrchard.sol	2022-06-22 10:15:28.000000000 -0700
+++ distributors/contracts/MerkleOrchard.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,13 +14,13 @@
 
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/distributors/IDistributorCallback.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/distributors/IDistributorCallback.sol";
+import "../../../interfaces/contracts/vault/IVault.sol";
+import "../../../interfaces/contracts/vault/IAsset.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/MerkleProof.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../../solidity-utils/contracts/openzeppelin/MerkleProof.sol";
+import "../../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 pragma solidity ^0.7.0;
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts distributors/contracts/MerkleRedeem.sol distributors/contracts/MerkleRedeem.sol
--- distributors/contracts/MerkleRedeem.sol	2022-06-22 10:15:28.000000000 -0700
+++ distributors/contracts/MerkleRedeem.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,15 +14,15 @@
 
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/distributors/IDistributorCallback.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/MerkleProof.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Ownable.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/distributors/IDistributorCallback.sol";
+import "../../../interfaces/contracts/vault/IVault.sol";
+import "../../../interfaces/contracts/vault/IAsset.sol";
+
+import "../../../solidity-utils/contracts/openzeppelin/MerkleProof.sol";
+import "../../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../../solidity-utils/contracts/openzeppelin/Ownable.sol";
+import "../../../solidity-utils/contracts/math/FixedPoint.sol";
 
 pragma solidity ^0.7.0;
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts distributors/contracts/test/MockRewardCallback.sol distributors/contracts/test/MockRewardCallback.sol
--- distributors/contracts/test/MockRewardCallback.sol	2022-06-22 10:15:28.000000000 -0700
+++ distributors/contracts/test/MockRewardCallback.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/distributors/IDistributorCallback.sol";
+import "../../interfaces/contracts/distributors/IDistributorCallback.sol";
 
 contract MockRewardCallback is IDistributorCallback {
     event CallbackReceived();
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/liquidity-mining/IBaseGaugeFactory.sol interfaces/contracts/liquidity-mining/IBaseGaugeFactory.sol
--- interfaces/contracts/liquidity-mining/IBaseGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ interfaces/contracts/liquidity-mining/IBaseGaugeFactory.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,28 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-
-import "./ILiquidityGaugeFactory.sol";
-
-interface IBaseGaugeFactory is ILiquidityGaugeFactory {
-    /**
-     * @notice Deploys a new gauge for the given recipient, with an initial maximum relative weight cap.
-     * The recipient can either be a pool in mainnet, or a recipient in a child chain.
-     * @param recipient The address to receive BAL minted from the gauge
-     * @param relativeWeightCap The relative weight cap for the created gauge
-     * @return The address of the deployed gauge
-     */
-    function create(address recipient, uint256 relativeWeightCap) external returns (address);
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/liquidity-mining/IBaseRootGaugeFactory.sol interfaces/contracts/liquidity-mining/IBaseRootGaugeFactory.sol
--- interfaces/contracts/liquidity-mining/IBaseRootGaugeFactory.sol	1969-12-31 16:00:00.000000000 -0800
+++ interfaces/contracts/liquidity-mining/IBaseRootGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "./ILiquidityGaugeFactory.sol";
+
+interface IBaseRootGaugeFactory is ILiquidityGaugeFactory {
+    /**
+     * @notice Deploys a new gauge for the given recipient, with an initial maximum relative weight cap.
+     * The recipient can either be a pool in mainnet, or a recipient in a child chain.
+     * @param recipient The address to receive BAL minted from the gauge
+     * @param relativeWeightCap The relative weight cap for the created gauge
+     * @return The address of the deployed gauge
+     */
+    function create(address recipient, uint256 relativeWeightCap) external returns (address);
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/liquidity-mining/ILiquidityGauge.sol interfaces/contracts/liquidity-mining/ILiquidityGauge.sol
--- interfaces/contracts/liquidity-mining/ILiquidityGauge.sol	2022-09-16 02:04:26.000000000 -0700
+++ interfaces/contracts/liquidity-mining/ILiquidityGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -69,4 +69,9 @@
      * @param time Timestamp in the past or present.
      */
     function getCappedRelativeWeight(uint256 time) external view returns (uint256);
+
+    /**
+     * @notice Returns the gauge's relative weight for the current week, capped to its relative weight cap attribute.
+     */
+    function getCurrentCappedRelativeWeight() external view returns (uint256);
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol
--- interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol	1969-12-31 16:00:00.000000000 -0800
+++ interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "./IStakelessGauge.sol";
+
+interface ISingleRecipientGauge is IStakelessGauge {
+    function initialize(address recipient, uint256 relativeWeightCap) external;
+
+    function getRecipient() external view returns (address);
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol
--- interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol	1969-12-31 16:00:00.000000000 -0800
+++ interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "./IBaseRootGaugeFactory.sol";
+
+interface ISingleRecipientGaugeFactory is IBaseRootGaugeFactory {
+    /**
+     * @notice Returns the gauge which sends funds to `recipient`.
+     */
+    function getRecipientGauge(address recipient) external view returns (ILiquidityGauge);
+
+    /**
+     * @notice Returns the recipient of `gauge`.
+     */
+    function getGaugeRecipient(address gauge) external view returns (address);
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/liquidity-mining/IStakelessGauge.sol interfaces/contracts/liquidity-mining/IStakelessGauge.sol
--- interfaces/contracts/liquidity-mining/IStakelessGauge.sol	2022-09-16 02:04:26.000000000 -0700
+++ interfaces/contracts/liquidity-mining/IStakelessGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -18,6 +18,4 @@
 
 interface IStakelessGauge is ILiquidityGauge {
     function checkpoint() external payable returns (bool);
-
-    function getRecipient() external view returns (address);
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/pool-utils/IControlledManagedPool.sol interfaces/contracts/pool-utils/IControlledManagedPool.sol
--- interfaces/contracts/pool-utils/IControlledManagedPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ interfaces/contracts/pool-utils/IControlledManagedPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -31,9 +31,9 @@
 
     function setMustAllowlistLPs(bool mustAllowlistLPs) external;
 
-    function collectAumManagementFees() external returns (uint256);
+    function withdrawCollectedManagementFees(address recipient) external;
 
     function setManagementSwapFeePercentage(uint256 managementSwapFeePercentage) external;
 
-    function setManagementAumFeePercentage(uint256 managementAumFeePercentage) external returns (uint256);
+    function setManagementAumFeePercentage(uint256 managementAumFeePercentage) external;
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol
--- interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "./IBasePoolFactory.sol";
+import "./IBasePoolSplitCodeFactory.sol";
 
-interface ILastCreatedPoolFactory is IBasePoolFactory {
+interface ILastCreatedPoolFactory is IBasePoolSplitCodeFactory {
     /**
      * @dev Returns the address of the last Pool created by this factory.
      *
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts interfaces/contracts/pool-utils/IRateProvider.sol interfaces/contracts/pool-utils/IRateProvider.sol
--- interfaces/contracts/pool-utils/IRateProvider.sol	2022-06-22 10:15:28.000000000 -0700
+++ interfaces/contracts/pool-utils/IRateProvider.sol	2022-09-16 02:52:23.000000000 -0700
@@ -19,5 +19,5 @@
      * @dev Returns an 18 decimal fixed point number that is the exchange rate of the token to some other underlying
      * token. The meaning of this rate depends on the context.
      */
-    function getRate() external view returns (uint256);
+    function getRate() external returns (uint256);
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/BalancerMinter.sol liquidity-mining/contracts/BalancerMinter.sol
--- liquidity-mining/contracts/BalancerMinter.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/BalancerMinter.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,15 +14,15 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeController.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeMath.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EIP712.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/EOASignaturesValidator.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
+import "../../interfaces/contracts/liquidity-mining/IGaugeController.sol";
+import "../../interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeMath.sol";
+import "../../solidity-utils/contracts/openzeppelin/EIP712.sol";
+import "../../solidity-utils/contracts/helpers/EOASignaturesValidator.sol";
 
 contract BalancerMinter is IBalancerMinter, ReentrancyGuard, EOASignaturesValidator {
     using SafeMath for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/BalancerTokenAdmin.sol liquidity-mining/contracts/BalancerTokenAdmin.sol
--- liquidity-mining/contracts/BalancerTokenAdmin.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/BalancerTokenAdmin.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,12 +14,12 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // solhint-disable not-rely-on-time
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/SmartWalletChecker.sol liquidity-mining/contracts/SmartWalletChecker.sol
--- liquidity-mining/contracts/SmartWalletChecker.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/SmartWalletChecker.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ISmartWalletChecker.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/ISmartWalletChecker.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
 
 contract SmartWalletChecker is ISmartWalletChecker, SingletonAuthentication {
     using EnumerableSet for EnumerableSet.AddressSet;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/VotingEscrowDelegationProxy.sol liquidity-mining/contracts/VotingEscrowDelegationProxy.sol
--- liquidity-mining/contracts/VotingEscrowDelegationProxy.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/VotingEscrowDelegationProxy.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,10 +14,10 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IVeDelegation.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IVeDelegation.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
 
 contract VotingEscrowDelegationProxy is SingletonAuthentication {
     IERC20 private immutable _votingEscrow;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/admin/AuthorizerAdaptor.sol liquidity-mining/contracts/admin/AuthorizerAdaptor.sol
--- liquidity-mining/contracts/admin/AuthorizerAdaptor.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/admin/AuthorizerAdaptor.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,12 +14,12 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 /**
  * @title Authorizer Adaptor
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/admin/ChildChainGaugeTokenAdder.sol liquidity-mining/contracts/admin/ChildChainGaugeTokenAdder.sol
--- liquidity-mining/contracts/admin/ChildChainGaugeTokenAdder.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/admin/ChildChainGaugeTokenAdder.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
+import "../../interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
+import "../../interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
 
 /**
  * @title ChildChainGaugeTokenAdder
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/admin/DistributionScheduler.sol liquidity-mining/contracts/admin/DistributionScheduler.sol
--- liquidity-mining/contracts/admin/DistributionScheduler.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/admin/DistributionScheduler.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
+import "../../interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 // solhint-disable not-rely-on-time
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/admin/GaugeAdder.sol liquidity-mining/contracts/admin/GaugeAdder.sol
--- liquidity-mining/contracts/admin/GaugeAdder.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/admin/GaugeAdder.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,14 +14,14 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeAdder.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+import "../../interfaces/contracts/liquidity-mining/IGaugeAdder.sol";
+import "../../interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
 
 contract GaugeAdder is IGaugeAdder, SingletonAuthentication, ReentrancyGuard {
     using EnumerableSet for EnumerableSet.AddressSet;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/fee-distribution/FeeDistributor.sol liquidity-mining/contracts/fee-distribution/FeeDistributor.sol
--- liquidity-mining/contracts/fee-distribution/FeeDistributor.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/fee-distribution/FeeDistributor.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,16 +15,16 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IFeeDistributor.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IVotingEscrow.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/OptionalOnlyCaller.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeMath.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
+import "../../interfaces/contracts/liquidity-mining/IFeeDistributor.sol";
+import "../../interfaces/contracts/liquidity-mining/IVotingEscrow.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/OptionalOnlyCaller.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeMath.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // solhint-disable not-rely-on-time
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/BaseGaugeFactory.sol liquidity-mining/contracts/gauges/BaseGaugeFactory.sol
--- liquidity-mining/contracts/gauges/BaseGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/BaseGaugeFactory.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,60 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBaseGaugeFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
-
-abstract contract BaseGaugeFactory is IBaseGaugeFactory {
-    ILiquidityGauge private _gaugeImplementation;
-
-    mapping(address => bool) private _isGaugeFromFactory;
-
-    event GaugeCreated(address indexed gauge);
-
-    constructor(ILiquidityGauge gaugeImplementation) {
-        _gaugeImplementation = gaugeImplementation;
-    }
-
-    /**
-     * @notice Returns the address of the implementation used for gauge deployments.
-     */
-    function getGaugeImplementation() public view returns (ILiquidityGauge) {
-        return _gaugeImplementation;
-    }
-
-    /**
-     * @notice Returns true if `gauge` was created by this factory.
-     */
-    function isGaugeFromFactory(address gauge) external view override returns (bool) {
-        return _isGaugeFromFactory[gauge];
-    }
-
-    /**
-     * @dev Deploys a new gauge as a proxy of the implementation in storage.
-     * The deployed gauge must be initialized by the caller method.
-     * @return The address of the deployed gauge
-     */
-    function _create() internal returns (address) {
-        address gauge = Clones.clone(address(_gaugeImplementation));
-
-        _isGaugeFromFactory[gauge] = true;
-        emit GaugeCreated(gauge);
-
-        return gauge;
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ChildChainGaugeRewardHelper.sol liquidity-mining/contracts/gauges/ChildChainGaugeRewardHelper.sol
--- liquidity-mining/contracts/gauges/ChildChainGaugeRewardHelper.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/gauges/ChildChainGaugeRewardHelper.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IRewardsOnlyGauge.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IChildChainStreamer.sol";
+import "../../interfaces/contracts/liquidity-mining/IRewardsOnlyGauge.sol";
+import "../../interfaces/contracts/liquidity-mining/IChildChainStreamer.sol";
 
 /**
  * @title ChildChainGaugeRewardHelper
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol
--- liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,11 +15,11 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
+import "../../interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
 
 contract ChildChainLiquidityGaugeFactory is IChildChainLiquidityGaugeFactory {
     // RewardsOnlyGauge expects the claim function selector to be left padded with zeros.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol.orig liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol.orig
--- liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol.orig	1969-12-31 16:00:00.000000000 -0800
+++ liquidity-mining/contracts/gauges/ChildChainLiquidityGaugeFactory.sol.orig	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,126 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IChildChainLiquidityGaugeFactory.sol";
+import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
+import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+
+import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+
+contract ChildChainLiquidityGaugeFactory is IChildChainLiquidityGaugeFactory {
+    // RewardsOnlyGauge expects the claim function selector to be left padded with zeros.
+    // We then shift right 28 bytes so that the function selector (top 4 bytes) sits in the lowest 4 bytes.
+    bytes32 private constant _CLAIM_SIG = keccak256("get_reward()") >> (28 * 8);
+
+    ILiquidityGauge private immutable _gaugeImplementation;
+    IChildChainStreamer private immutable _childChainStreamerImplementation;
+
+    mapping(address => bool) private _isGaugeFromFactory;
+    mapping(address => bool) private _isStreamerFromFactory;
+    mapping(address => address) private _poolGauge;
+    mapping(address => address) private _gaugeStreamer;
+
+    constructor(ILiquidityGauge gauge, IChildChainStreamer childChainStreamer) {
+        _gaugeImplementation = gauge;
+        _childChainStreamerImplementation = childChainStreamer;
+    }
+
+    /**
+     * @notice Returns the address of the implementation used for gauge deployments.
+     */
+    function getGaugeImplementation() external view override returns (ILiquidityGauge) {
+        return _gaugeImplementation;
+    }
+
+    /**
+     * @notice Returns the address of the implementation used for streamer deployments.
+     */
+    function getChildChainStreamerImplementation() external view override returns (IChildChainStreamer) {
+        return _childChainStreamerImplementation;
+    }
+
+    /**
+     * @notice Returns the address of the gauge belonging to `pool`.
+     */
+    function getPoolGauge(address pool) public view override returns (ILiquidityGauge) {
+        return ILiquidityGauge(_poolGauge[pool]);
+    }
+
+    /**
+     * @notice Returns true if `gauge` was created by this factory.
+     */
+    function isGaugeFromFactory(address gauge) external view override returns (bool) {
+        return _isGaugeFromFactory[gauge];
+    }
+
+    /**
+     * @notice Returns the address of the streamer belonging to `gauge`.
+     */
+    function getGaugeStreamer(address gauge) public view override returns (address) {
+        return _gaugeStreamer[gauge];
+    }
+
+    /**
+     * @notice Returns true if `streamer` was created by this factory.
+     */
+    function isStreamerFromFactory(address streamer) external view override returns (bool) {
+        return _isStreamerFromFactory[streamer];
+    }
+
+    /**
+     * @notice Returns the address of the pool which `gauge` belongs.
+     */
+    function getGaugePool(address gauge) external view override returns (IERC20) {
+        return IRewardsOnlyGauge(gauge).lp_token();
+    }
+
+    /**
+     * @notice Returns the address of the streamer belonging to `pool`'s gauge.
+     */
+    function getPoolStreamer(address pool) external view override returns (address) {
+        return getGaugeStreamer(address(getPoolGauge(pool)));
+    }
+
+    /**
+     * @notice Deploys a new gauge for a Balancer pool.
+     * @dev As anyone can register arbitrary Balancer pools with the Vault,
+     * it's impossible to prove onchain that `pool` is a "valid" deployment.
+     *
+     * Care must be taken to ensure that gauges deployed from this factory are
+     * suitable before they are added to the GaugeController.
+     *
+     * This factory disallows deploying multiple gauges for a single pool.
+     * @param pool The address of the pool for which to deploy a gauge
+     * @return The address of the deployed gauge
+     */
+    function create(address pool) external returns (address) {
+        require(_poolGauge[pool] == address(0), "Gauge already exists");
+
+        address gauge = Clones.clone(address(_gaugeImplementation));
+        address streamer = Clones.clone(address(_childChainStreamerImplementation));
+
+        IChildChainStreamer(streamer).initialize(gauge);
+        IRewardsOnlyGauge(gauge).initialize(pool, streamer, _CLAIM_SIG);
+
+        _isGaugeFromFactory[gauge] = true;
+        _poolGauge[pool] = gauge;
+        _gaugeStreamer[gauge] = streamer;
+        emit RewardsOnlyGaugeCreated(gauge, pool, streamer);
+
+        return gauge;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/StakelessGauge.sol liquidity-mining/contracts/gauges/StakelessGauge.sol
--- liquidity-mining/contracts/gauges/StakelessGauge.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/StakelessGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,18 +14,15 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeController.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakelessGauge.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerTokenAdmin.sol";
+import "../../interfaces/contracts/liquidity-mining/IGaugeController.sol";
+import "../../interfaces/contracts/liquidity-mining/IStakelessGauge.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 abstract contract StakelessGauge is IStakelessGauge, ReentrancyGuard {
-    uint256 public constant MAX_RELATIVE_WEIGHT_CAP = 1e18;
-
     IERC20 internal immutable _balToken;
     IBalancerTokenAdmin private immutable _tokenAdmin;
     IBalancerMinter private immutable _minter;
@@ -192,4 +189,8 @@
     function getCappedRelativeWeight(uint256 time) public view override returns (uint256) {
         return Math.min(_gaugeController.gauge_relative_weight(address(this), time), _relativeWeightCap);
     }
+
+    function getCurrentCappedRelativeWeight() external view override returns (uint256) {
+        return getCappedRelativeWeight(_currentPeriod());
+    }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol
--- liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,12 +14,13 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IArbitrumFeeProvider.sol";
+import "../../interfaces/contracts/liquidity-mining/IArbitrumFeeProvider.sol";
+import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
 
 import "../StakelessGauge.sol";
 import "./IGatewayRouter.sol";
 
-contract ArbitrumRootGauge is StakelessGauge {
+contract ArbitrumRootGauge is ISingleRecipientGauge, StakelessGauge {
     address private immutable _gateway;
     IGatewayRouter private immutable _gatewayRouter;
     IArbitrumFeeProvider private immutable _factory;
@@ -32,7 +33,7 @@
         _factory = IArbitrumFeeProvider(msg.sender);
     }
 
-    function initialize(address recipient, uint256 relativeWeightCap) external {
+    function initialize(address recipient, uint256 relativeWeightCap) external override {
         // This will revert in all calls except the first one
         __StakelessGauge_init(relativeWeightCap);
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol
--- liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/arbitrum/ArbitrumRootGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,19 +15,25 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
 
-import "../BaseGaugeFactory.sol";
 import "./ArbitrumRootGauge.sol";
 
-contract ArbitrumRootGaugeFactory is IArbitrumFeeProvider, BaseGaugeFactory, SingletonAuthentication {
+contract ArbitrumRootGaugeFactory is ILiquidityGaugeFactory, IArbitrumFeeProvider, SingletonAuthentication {
+    ArbitrumRootGauge private _gaugeImplementation;
+
+    mapping(address => bool) private _isGaugeFromFactory;
+    mapping(address => address) private _recipientGauge;
+
     uint64 private _gasLimit;
     uint64 private _gasPrice;
     uint64 private _maxSubmissionCost;
 
+    event ArbitrumRootGaugeCreated(address indexed gauge, address indexed recipient);
     event ArbitrumFeesModified(uint256 gasLimit, uint256 gasPrice, uint256 maxSubmissionCost);
 
     constructor(
@@ -37,13 +43,43 @@
         uint64 gasLimit,
         uint64 gasPrice,
         uint64 maxSubmissionCost
-    ) BaseGaugeFactory(new ArbitrumRootGauge(minter, gatewayRouter)) SingletonAuthentication(vault) {
+    ) SingletonAuthentication(vault) {
+        _gaugeImplementation = new ArbitrumRootGauge(minter, gatewayRouter);
+
         _gasLimit = gasLimit;
         _gasPrice = gasPrice;
         _maxSubmissionCost = maxSubmissionCost;
     }
 
     /**
+     * @notice Returns the address of the implementation used for gauge deployments.
+     */
+    function getGaugeImplementation() public view returns (address) {
+        return address(_gaugeImplementation);
+    }
+
+    /**
+     * @notice Returns true if `gauge` was created by this factory.
+     */
+    function isGaugeFromFactory(address gauge) external view override returns (bool) {
+        return _isGaugeFromFactory[gauge];
+    }
+
+    /**
+     * @notice Returns the gauge which sends funds to `recipient`.
+     */
+    function getRecipientGauge(address recipient) external view override returns (ILiquidityGauge) {
+        return ILiquidityGauge(_recipientGauge[recipient]);
+    }
+
+    /**
+     * @notice Returns the recipient of `gauge`.
+     */
+    function getGaugeRecipient(address gauge) external view override returns (address) {
+        return ISingleRecipientGauge(gauge).getRecipient();
+    }
+
+    /**
      * @notice Set the fees for the Arbitrum side of the bridging transaction
      */
     function getArbitrumFees()
@@ -62,7 +98,7 @@
     }
 
     /**
-     * @notice Deploys a new gauge which bridges all of its BAL allowance to a single recipient on Arbitrum.
+     * @notice Deploys a new gauge which bridges all of its BAL allowance to a single recipient on Polygon.
      * @dev Care must be taken to ensure that gauges deployed from this factory are
      * suitable before they are added to the GaugeController.
      * @param recipient The address to receive BAL minted from the gauge
@@ -70,8 +106,16 @@
      * @return The address of the deployed gauge
      */
     function create(address recipient, uint256 relativeWeightCap) external override returns (address) {
-        address gauge = _create();
+        require(_recipientGauge[recipient] == address(0), "Gauge already exists");
+
+        address gauge = Clones.clone(address(_gaugeImplementation));
+
         ArbitrumRootGauge(gauge).initialize(recipient, relativeWeightCap);
+
+        _isGaugeFromFactory[gauge] = true;
+        _recipientGauge[recipient] = gauge;
+        emit ArbitrumRootGaugeCreated(gauge, recipient);
+
         return gauge;
     }
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/arbitrum/IGatewayRouter.sol liquidity-mining/contracts/gauges/arbitrum/IGatewayRouter.sol
--- liquidity-mining/contracts/gauges/arbitrum/IGatewayRouter.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/gauges/arbitrum/IGatewayRouter.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 interface IGatewayRouter {
     function outboundTransfer(
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol
--- liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,16 +15,42 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBaseGaugeFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+import "../../interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+import "../../interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
 
-import "../BaseGaugeFactory.sol";
+contract LiquidityGaugeFactory is ILiquidityGaugeFactory {
+    ILiquidityGauge private immutable _gaugeImplementation;
 
-contract LiquidityGaugeFactory is BaseGaugeFactory {
-    constructor(IStakingLiquidityGauge gauge) BaseGaugeFactory(gauge) {
-        // solhint-disable-previous-line no-empty-blocks
+    mapping(address => bool) private _isGaugeFromFactory;
+    mapping(address => address) private _poolGauge;
+
+    event GaugeCreated(address indexed gauge, address indexed pool);
+
+    constructor(ILiquidityGauge gauge) {
+        _gaugeImplementation = gauge;
+    }
+
+    /**
+     * @notice Returns the address of the implementation used for gauge deployments.
+     */
+    function getGaugeImplementation() public view returns (ILiquidityGauge) {
+        return _gaugeImplementation;
+    }
+
+    /**
+     * @notice Returns the address of the gauge belonging to `pool`.
+     */
+    function getPoolGauge(address pool) external view returns (ILiquidityGauge) {
+        return ILiquidityGauge(_poolGauge[pool]);
+    }
+
+    /**
+     * @notice Returns true if `gauge` was created by this factory.
+     */
+    function isGaugeFromFactory(address gauge) external view override returns (bool) {
+        return _isGaugeFromFactory[gauge];
     }
 
     /**
@@ -35,14 +61,22 @@
      * Care must be taken to ensure that gauges deployed from this factory are
      * suitable before they are added to the GaugeController.
      *
-     * It is possible to deploy multiple gauges for a single pool.
+     * This factory disallows deploying multiple gauges for a single pool.
      * @param pool The address of the pool for which to deploy a gauge
      * @param relativeWeightCap The relative weight cap for the created gauge
      * @return The address of the deployed gauge
      */
     function create(address pool, uint256 relativeWeightCap) external override returns (address) {
-        address gauge = _create();
+        require(_poolGauge[pool] == address(0), "Gauge already exists");
+
+        address gauge = Clones.clone(address(_gaugeImplementation));
+
         IStakingLiquidityGauge(gauge).initialize(pool, relativeWeightCap);
+
+        _isGaugeFromFactory[gauge] = true;
+        _poolGauge[pool] = gauge;
+        emit GaugeCreated(gauge, pool);
+
         return gauge;
     }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeV5.vy liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeV5.vy
--- liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeV5.vy	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/ethereum/LiquidityGaugeV5.vy	2022-09-16 02:18:01.000000000 -0700
@@ -873,6 +873,14 @@
     self.inflation_params = shift(TokenAdmin(BAL_TOKEN_ADMIN).future_epoch_time_write(), 216) + TokenAdmin(BAL_TOKEN_ADMIN).rate()
     self._setRelativeWeightCap(relative_weight_cap)
 
+@internal
+@view
+def _get_current_period() -> uint256:
+    """
+    @dev Returns current time rounded down to the week's start.
+    """
+    return (block.timestamp / WEEK) - 1
+
 @external
 def setRelativeWeightCap(relative_weight_cap: uint256):
     """
@@ -901,6 +909,14 @@
     return self._getCappedRelativeWeight(time)
 
 @external
+@view
+def getCurrentCappedRelativeWeight() -> uint256:
+    """
+    @notice Returns the gauge's relative weight for the current week, capped to its _relative_weight_cap attribute.
+    """
+    return self._getCappedRelativeWeight(self._get_current_period())
+
+@external
 @pure
 def getMaxRelativeWeightCap() -> uint256:
     """
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol
--- liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/ethereum/SingleRecipientGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,11 +14,13 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 import "../StakelessGauge.sol";
 
-contract SingleRecipientGauge is StakelessGauge {
+contract SingleRecipientGauge is ISingleRecipientGauge, StakelessGauge {
     using SafeERC20 for IERC20;
 
     address private _recipient;
@@ -27,7 +29,7 @@
         // solhint-disable-previous-line no-empty-blocks
     }
 
-    function initialize(address recipient, uint256 relativeWeightCap) external {
+    function initialize(address recipient, uint256 relativeWeightCap) external override {
         // This will revert in all calls except the first one
         __StakelessGauge_init(relativeWeightCap);
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol
--- liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/ethereum/SingleRecipientGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,16 +15,50 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakelessGauge.sol";
+import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
 
-import "../BaseGaugeFactory.sol";
 import "./SingleRecipientGauge.sol";
 
-contract SingleRecipientGaugeFactory is BaseGaugeFactory {
-    constructor(IBalancerMinter minter) BaseGaugeFactory(new SingleRecipientGauge(minter)) {
-        // solhint-disable-previous-line no-empty-blocks
+contract SingleRecipientGaugeFactory is ISingleRecipientGaugeFactory {
+    ISingleRecipientGauge private _gaugeImplementation;
+
+    mapping(address => bool) private _isGaugeFromFactory;
+    mapping(address => address) private _recipientGauge;
+
+    event SingleRecipientGaugeCreated(address indexed gauge, address indexed recipient);
+
+    constructor(IBalancerMinter minter) {
+        _gaugeImplementation = new SingleRecipientGauge(minter);
+    }
+
+    /**
+     * @notice Returns the address of the implementation used for gauge deployments.
+     */
+    function getGaugeImplementation() public view returns (ISingleRecipientGauge) {
+        return _gaugeImplementation;
+    }
+
+    /**
+     * @notice Returns true if `gauge` was created by this factory.
+     */
+    function isGaugeFromFactory(address gauge) external view override returns (bool) {
+        return _isGaugeFromFactory[gauge];
+    }
+
+    /**
+     * @notice Returns the gauge which sends funds to `recipient`.
+     */
+    function getRecipientGauge(address recipient) external view override returns (ILiquidityGauge) {
+        return ILiquidityGauge(_recipientGauge[recipient]);
+    }
+
+    /**
+     * @notice Returns the recipient of `gauge`.
+     */
+    function getGaugeRecipient(address gauge) external view override returns (address) {
+        return ISingleRecipientGauge(gauge).getRecipient();
     }
 
     /**
@@ -36,8 +70,16 @@
      * @return The address of the deployed gauge
      */
     function create(address recipient, uint256 relativeWeightCap) external override returns (address) {
-        address gauge = _create();
-        SingleRecipientGauge(gauge).initialize(recipient, relativeWeightCap);
+        require(_recipientGauge[recipient] == address(0), "Gauge already exists");
+
+        address gauge = Clones.clone(address(_gaugeImplementation));
+
+        ISingleRecipientGauge(gauge).initialize(recipient, relativeWeightCap);
+
+        _isGaugeFromFactory[gauge] = true;
+        _recipientGauge[recipient] = gauge;
+        emit SingleRecipientGaugeCreated(gauge, recipient);
+
         return gauge;
     }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol
--- liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/optimism/OptimismRootGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IOptimismGasLimitProvider.sol";
+import "../../interfaces/contracts/liquidity-mining/IOptimismGasLimitProvider.sol";
+import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
 
 import "../StakelessGauge.sol";
 
@@ -29,7 +30,7 @@
     ) external;
 }
 
-contract OptimismRootGauge is StakelessGauge {
+contract OptimismRootGauge is ISingleRecipientGauge, StakelessGauge {
     IL1StandardBridge private immutable _optimismL1StandardBridge;
     address private immutable _optimismBal;
     IOptimismGasLimitProvider private immutable _factory;
@@ -47,7 +48,7 @@
         _factory = IOptimismGasLimitProvider(msg.sender);
     }
 
-    function initialize(address recipient, uint256 relativeWeightCap) external {
+    function initialize(address recipient, uint256 relativeWeightCap) external override {
         // This will revert in all calls except the first one
         __StakelessGauge_init(relativeWeightCap);
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol
--- liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/optimism/OptimismRootGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,15 +15,22 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
+
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
 
-import "../BaseGaugeFactory.sol";
 import "./OptimismRootGauge.sol";
 
-contract OptimismRootGaugeFactory is IOptimismGasLimitProvider, BaseGaugeFactory, SingletonAuthentication {
+contract OptimismRootGaugeFactory is ISingleRecipientGaugeFactory, IOptimismGasLimitProvider, SingletonAuthentication {
+    ISingleRecipientGauge private _gaugeImplementation;
+
+    mapping(address => bool) private _isGaugeFromFactory;
+    mapping(address => address) private _recipientGauge;
+
     uint32 private _gasLimit;
 
+    event OptimismRootGaugeCreated(address indexed gauge, address indexed recipient);
     event OptimismGasLimitModified(uint256 gasLimit);
 
     constructor(
@@ -32,14 +39,40 @@
         IL1StandardBridge optimismL1StandardBridge,
         address optimismBal,
         uint32 gasLimit
-    )
-        BaseGaugeFactory(new OptimismRootGauge(minter, optimismL1StandardBridge, optimismBal))
-        SingletonAuthentication(vault)
-    {
+    ) SingletonAuthentication(vault) {
+        _gaugeImplementation = new OptimismRootGauge(minter, optimismL1StandardBridge, optimismBal);
         _gasLimit = gasLimit;
     }
 
     /**
+     * @notice Returns the address of the implementation used for gauge deployments.
+     */
+    function getGaugeImplementation() public view returns (ISingleRecipientGauge) {
+        return _gaugeImplementation;
+    }
+
+    /**
+     * @notice Returns true if `gauge` was created by this factory.
+     */
+    function isGaugeFromFactory(address gauge) external view override returns (bool) {
+        return _isGaugeFromFactory[gauge];
+    }
+
+    /**
+     * @notice Returns the gauge which sends funds to `recipient`.
+     */
+    function getRecipientGauge(address recipient) external view override returns (ILiquidityGauge) {
+        return ILiquidityGauge(_recipientGauge[recipient]);
+    }
+
+    /**
+     * @notice Returns the recipient of `gauge`.
+     */
+    function getGaugeRecipient(address gauge) external view override returns (address) {
+        return ISingleRecipientGauge(gauge).getRecipient();
+    }
+
+    /**
      * @notice Returns the gas limit for the Optimism side of the bridging transaction
      */
     function getOptimismGasLimit() external view override returns (uint32) {
@@ -55,8 +88,16 @@
      * @return The address of the deployed gauge
      */
     function create(address recipient, uint256 relativeWeightCap) external override returns (address) {
-        address gauge = _create();
-        OptimismRootGauge(gauge).initialize(recipient, relativeWeightCap);
+        require(_recipientGauge[recipient] == address(0), "Gauge already exists");
+
+        address gauge = Clones.clone(address(_gaugeImplementation));
+
+        ISingleRecipientGauge(gauge).initialize(recipient, relativeWeightCap);
+
+        _isGaugeFromFactory[gauge] = true;
+        _recipientGauge[recipient] = gauge;
+        emit OptimismRootGaugeCreated(gauge, recipient);
+
         return gauge;
     }
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol
--- liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/polygon/PolygonRootGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,6 +14,8 @@
 
 pragma solidity ^0.7.0;
 
+import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGauge.sol";
+
 import "../StakelessGauge.sol";
 
 interface IPolygonRootChainManager {
@@ -24,7 +26,7 @@
     ) external;
 }
 
-contract PolygonRootGauge is StakelessGauge {
+contract PolygonRootGauge is ISingleRecipientGauge, StakelessGauge {
     IPolygonRootChainManager private immutable _polygonRootChainManager;
     address private immutable _polygonERC20Predicate;
 
@@ -40,7 +42,7 @@
         _polygonERC20Predicate = polygonERC20Predicate;
     }
 
-    function initialize(address recipient, uint256 relativeWeightCap) external {
+    function initialize(address recipient, uint256 relativeWeightCap) external override {
         // This will revert in all calls except the first one
         __StakelessGauge_init(relativeWeightCap);
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol
--- liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/gauges/polygon/PolygonRootGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,18 +15,54 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+import "../../interfaces/contracts/liquidity-mining/ISingleRecipientGaugeFactory.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
 
-import "../BaseGaugeFactory.sol";
 import "./PolygonRootGauge.sol";
 
-contract PolygonRootGaugeFactory is BaseGaugeFactory {
+contract PolygonRootGaugeFactory is ISingleRecipientGaugeFactory {
+    ISingleRecipientGauge private _gaugeImplementation;
+
+    mapping(address => bool) private _isGaugeFromFactory;
+    mapping(address => address) private _recipientGauge;
+
+    event PolygonRootGaugeCreated(address indexed gauge, address indexed recipient);
+
     constructor(
         IBalancerMinter minter,
         IPolygonRootChainManager polygonRootChainManager,
         address polygonERC20Predicate
-    ) BaseGaugeFactory(new PolygonRootGauge(minter, polygonRootChainManager, polygonERC20Predicate)) {
-        // solhint-disable-previous-line no-empty-blocks
+    ) {
+        _gaugeImplementation = new PolygonRootGauge(minter, polygonRootChainManager, polygonERC20Predicate);
+    }
+
+    /**
+     * @notice Returns the address of the implementation used for gauge deployments.
+     */
+    function getGaugeImplementation() public view returns (ISingleRecipientGauge) {
+        return _gaugeImplementation;
+    }
+
+    /**
+     * @notice Returns true if `gauge` was created by this factory.
+     */
+    function isGaugeFromFactory(address gauge) external view override returns (bool) {
+        return _isGaugeFromFactory[gauge];
+    }
+
+    /**
+     * @notice Returns the gauge which sends funds to `recipient`.
+     */
+    function getRecipientGauge(address recipient) external view override returns (ILiquidityGauge) {
+        return ILiquidityGauge(_recipientGauge[recipient]);
+    }
+
+    /**
+     * @notice Returns the recipient of `gauge`.
+     */
+    function getGaugeRecipient(address gauge) external view override returns (address) {
+        return ISingleRecipientGauge(gauge).getRecipient();
     }
 
     /**
@@ -38,8 +74,16 @@
      * @return The address of the deployed gauge
      */
     function create(address recipient, uint256 relativeWeightCap) external override returns (address) {
-        address gauge = _create();
-        PolygonRootGauge(gauge).initialize(recipient, relativeWeightCap);
+        require(_recipientGauge[recipient] == address(0), "Gauge already exists");
+
+        address gauge = Clones.clone(address(_gaugeImplementation));
+
+        ISingleRecipientGauge(gauge).initialize(recipient, relativeWeightCap);
+
+        _isGaugeFromFactory[gauge] = true;
+        _recipientGauge[recipient] = gauge;
+        emit PolygonRootGaugeCreated(gauge, recipient);
+
         return gauge;
     }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockGaugeController.sol liquidity-mining/contracts/test/MockGaugeController.sol
--- liquidity-mining/contracts/test/MockGaugeController.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/test/MockGaugeController.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IGaugeController.sol";
+import "../../interfaces/contracts/liquidity-mining/IGaugeController.sol";
 
 // For compatibility, we're keeping the same function names as in the original Curve code, including the mixed-case
 // naming convention.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockLiquidityGauge.sol liquidity-mining/contracts/test/MockLiquidityGauge.sol
--- liquidity-mining/contracts/test/MockLiquidityGauge.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/test/MockLiquidityGauge.sol	2022-09-16 02:18:01.000000000 -0700
@@ -12,56 +12,14 @@
 // You should have received a copy of the GNU General Public License
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/ILiquidityGauge.sol";
-
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-contract MockLiquidityGauge is ILiquidityGauge {
+contract MockLiquidityGauge {
     // solhint-disable-next-line var-name-mixedcase
     address public lp_token;
 
-    constructor() {
-        // solhint-disable-previous-line no-empty-blocks
-    }
-
-    function initialize(address pool, uint256) external {
+    constructor(address pool) {
         lp_token = pool;
     }
-
-    // Methods below are not implemented; they are present just to comply with ILiquidityGauge.
-    // State mutability was set to "pure" to avoid compiler warnings.
-    // solhint-disable func-name-mixedcase
-
-    function integrate_fraction(address) external pure override returns (uint256) {
-        revert("Mock method; not implemented");
-    }
-
-    function user_checkpoint(address) external pure override returns (bool) {
-        revert("Mock method; not implemented");
-    }
-
-    function is_killed() external pure override returns (bool) {
-        revert("Mock method; not implemented");
-    }
-
-    function killGauge() external pure override {
-        revert("Mock method; not implemented");
-    }
-
-    function unkillGauge() external pure override {
-        revert("Mock method; not implemented");
-    }
-
-    function setRelativeWeightCap(uint256) external pure override {
-        revert("Mock method; not implemented");
-    }
-
-    function getRelativeWeightCap() external pure override returns (uint256) {
-        revert("Mock method; not implemented");
-    }
-
-    function getCappedRelativeWeight(uint256) external pure override returns (uint256) {
-        revert("Mock method; not implemented");
-    }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol
--- liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/contracts/test/MockLiquidityGaugeFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,20 +15,42 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Clones.sol";
+import "../../interfaces/contracts/liquidity-mining/ILiquidityGaugeFactory.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/Clones.sol";
 
-import "../gauges/BaseGaugeFactory.sol";
 import "./MockLiquidityGauge.sol";
 
-contract MockLiquidityGaugeFactory is BaseGaugeFactory {
-    constructor(MockLiquidityGauge gaugeImplementation) BaseGaugeFactory(gaugeImplementation) {
-        // solhint-disable-previous-line no-empty-blocks
+contract MockLiquidityGaugeFactory is ILiquidityGaugeFactory {
+    mapping(address => bool) private _isGaugeFromFactory;
+    mapping(address => address) private _poolGauge;
+
+    event GaugeCreated(address indexed gauge, address indexed pool);
+
+    /**
+     * @notice Returns the address of the gauge belonging to `pool`.
+     */
+    function getPoolGauge(address pool) external view returns (ILiquidityGauge) {
+        return ILiquidityGauge(_poolGauge[pool]);
+    }
+
+    /**
+     * @notice Returns true if `gauge` was created by this factory.
+     */
+    function isGaugeFromFactory(address gauge) external view override returns (bool) {
+        return _isGaugeFromFactory[gauge];
     }
 
-    function create(address pool, uint256 relativeWeightCap) external override returns (address) {
-        address gauge = _create();
+    function create(address pool) external returns (address) {
+        require(_poolGauge[pool] == address(0), "Gauge already exists");
+
+        address gauge = address(new MockLiquidityGauge(pool));
 
-        MockLiquidityGauge(gauge).initialize(pool, relativeWeightCap);
+        _isGaugeFromFactory[gauge] = true;
+        _poolGauge[pool] = gauge;
+        emit GaugeCreated(gauge, pool);
 
         return gauge;
     }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/MockRewardTokenDistributor.sol liquidity-mining/contracts/test/MockRewardTokenDistributor.sol
--- liquidity-mining/contracts/test/MockRewardTokenDistributor.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/test/MockRewardTokenDistributor.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/liquidity-mining/IRewardTokenDistributor.sol";
 
 // solhint-disable func-name-mixedcase, var-name-mixedcase, not-rely-on-time
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/TestAccessControl.sol liquidity-mining/contracts/test/TestAccessControl.sol
--- liquidity-mining/contracts/test/TestAccessControl.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/test/TestAccessControl.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,8 +2,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 // This contract maintains the old AccessControl behaviour which is used by BalancerGovernanceToken in production
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/contracts/test/TestBalancerToken.sol liquidity-mining/contracts/test/TestBalancerToken.sol
--- liquidity-mining/contracts/test/TestBalancerToken.sol	2022-06-22 10:15:28.000000000 -0700
+++ liquidity-mining/contracts/test/TestBalancerToken.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20Burnable.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20Permit.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20Burnable.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20Permit.sol";
 
 import "./TestAccessControl.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/test/BaseGaugeFactory.test.ts liquidity-mining/test/BaseGaugeFactory.test.ts
--- liquidity-mining/test/BaseGaugeFactory.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/test/BaseGaugeFactory.test.ts	1969-12-31 16:00:00.000000000 -0800
@@ -1,52 +0,0 @@
-import { Contract } from 'ethers';
-
-import * as expectEvent from '@balancer-labs/v2-helpers/src/test/expectEvent';
-import { deploy } from '@balancer-labs/v2-helpers/src/contract';
-import { expect } from 'chai';
-import { ANY_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
-import { fp } from '@balancer-labs/v2-helpers/src/numbers';
-
-describe('BaseGaugeFactory', () => {
-  let gaugeImplementation: Contract;
-  let gaugeFactory: Contract;
-
-  sharedBeforeEach('deploy gauge factory', async () => {
-    gaugeImplementation = await deploy('MockLiquidityGauge');
-    gaugeFactory = await deploy('MockLiquidityGaugeFactory', { args: [gaugeImplementation.address] });
-  });
-
-  describe('getGaugeImplementation', () => {
-    it('returns the implementation given in the constructor', async () => {
-      expect(await gaugeFactory.getGaugeImplementation()).to.be.eq(gaugeImplementation.address);
-    });
-  });
-
-  describe('create', () => {
-    it('emits an event', async () => {
-      const tx = await gaugeFactory.create(ANY_ADDRESS, fp(1)); // Weight cap can be anything; it's not under test.
-      expectEvent.inReceipt(await tx.wait(), 'GaugeCreated');
-    });
-  });
-
-  describe('isGaugeFromFactory', () => {
-    let gaugeAddress: string;
-    sharedBeforeEach('create gauge', async () => {
-      const tx = await gaugeFactory.create(ANY_ADDRESS, fp(1)); // Weight cap can be anything; it's not under test.
-      const event = expectEvent.inReceipt(await tx.wait(), 'GaugeCreated');
-
-      gaugeAddress = event.args.gauge;
-    });
-
-    context('when the contract was not created by the factory', () => {
-      it('returns false', async () => {
-        expect(await gaugeFactory.isGaugeFromFactory(gaugeImplementation.address)).to.be.false;
-      });
-    });
-
-    context('when the contract was created by the factory', () => {
-      it('returns true', async () => {
-        expect(await gaugeFactory.isGaugeFromFactory(gaugeAddress)).to.be.true;
-      });
-    });
-  });
-});
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/test/GaugeAdder.test.ts liquidity-mining/test/GaugeAdder.test.ts
--- liquidity-mining/test/GaugeAdder.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/test/GaugeAdder.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -8,7 +8,6 @@
 import { expect } from 'chai';
 import { actionId } from '@balancer-labs/v2-helpers/src/models/misc/actions';
 import { ANY_ADDRESS, ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
-import { fp } from '@balancer-labs/v2-helpers/src/numbers';
 
 enum GaugeType {
   LiquidityMiningCommittee = 0,
@@ -21,7 +20,6 @@
 describe('GaugeAdder', () => {
   let vault: Vault;
   let gaugeController: Contract;
-  let gaugeImplementation: Contract;
   let gaugeFactory: Contract;
   let adaptor: Contract;
   let gaugeAdder: Contract;
@@ -38,8 +36,7 @@
     adaptor = await deploy('AuthorizerAdaptor', { args: [vault.address] });
     gaugeController = await deploy('MockGaugeController', { args: [ZERO_ADDRESS, adaptor.address] });
 
-    gaugeImplementation = await deploy('MockLiquidityGauge');
-    gaugeFactory = await deploy('MockLiquidityGaugeFactory', { args: [gaugeImplementation.address] });
+    gaugeFactory = await deploy('MockLiquidityGaugeFactory');
     gaugeAdder = await deploy('GaugeAdder', { args: [gaugeController.address, ZERO_ADDRESS] });
 
     await gaugeController.add_type('LiquidityMiningCommittee', 0);
@@ -53,7 +50,7 @@
   });
 
   async function deployGauge(gaugeFactory: Contract, poolAddress: string): Promise<string> {
-    const tx = await gaugeFactory.create(poolAddress, fp(1)); // Weight cap can be anything; it's not under test.
+    const tx = await gaugeFactory.create(poolAddress);
     const event = expectEvent.inReceipt(await tx.wait(), 'GaugeCreated');
 
     return event.args.gauge;
@@ -123,7 +120,7 @@
     let gauge: string;
 
     sharedBeforeEach('deploy gauge', async () => {
-      gauge = await deployGauge(gaugeFactory, ANY_ADDRESS);
+      gauge = await deployGauge(gaugeFactory, ZERO_ADDRESS);
     });
 
     context('when factory has been added to GaugeAdder', () => {
@@ -178,9 +175,7 @@
             await gaugeAdder.connect(admin).addGaugeFactory(gaugeFactory.address, GaugeType.Ethereum);
             await gaugeAdder.connect(admin).addEthereumGauge(gauge);
 
-            const duplicateGaugeFactory = await deploy('MockLiquidityGaugeFactory', {
-              args: [gaugeImplementation.address],
-            });
+            const duplicateGaugeFactory = await deploy('MockLiquidityGaugeFactory');
             duplicateGauge = await deployGauge(duplicateGaugeFactory, ANY_ADDRESS);
           });
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts liquidity-mining/test/GaugeRelativeWeightCap.test.ts liquidity-mining/test/GaugeRelativeWeightCap.test.ts
--- liquidity-mining/test/GaugeRelativeWeightCap.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ liquidity-mining/test/GaugeRelativeWeightCap.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -72,17 +72,17 @@
     beforeEach('use liquidity gauge factory', () => {
       factory = liquidityGaugeFactory;
     });
-    testRelativeWeightCapForGauge('LiquidityGaugeV5');
+    testRelativeWeightCapForGauge('LiquidityGaugeV5', 'GaugeCreated');
   });
 
   describe('StakelessGauge', () => {
     beforeEach('use stakeless gauge factory', () => {
       factory = stakelessGaugeFactory;
     });
-    testRelativeWeightCapForGauge('SingleRecipientGauge');
+    testRelativeWeightCapForGauge('SingleRecipientGauge', 'SingleRecipientGaugeCreated');
   });
 
-  function testRelativeWeightCapForGauge(contractName: string) {
+  function testRelativeWeightCapForGauge(contractName: string, creationEventName: string) {
     let gauge: Contract;
     async function setCap(relativeWeightCap: BigNumber): Promise<ContractTransaction> {
       const calldata = gauge.interface.encodeFunctionData('setRelativeWeightCap', [relativeWeightCap]);
@@ -107,7 +107,10 @@
         });
 
         it('sets the initial cap value', async () => {
-          const gauge = await deployedAt(contractName, await deployGauge(factory, token.address, initialCap));
+          const gauge = await deployedAt(
+            contractName,
+            await deployGauge(factory, token.address, creationEventName, initialCap)
+          );
           expect(await gauge.getRelativeWeightCap()).to.be.eq(initialCap);
         });
       });
@@ -127,7 +130,7 @@
       }
 
       sharedBeforeEach('deploy gauge', async () => {
-        gauge = await deployedAt(contractName, await deployGauge(factory, token.address));
+        gauge = await deployedAt(contractName, await deployGauge(factory, token.address, creationEventName));
       });
 
       context('when the caller is not authorized', () => {
@@ -163,7 +166,7 @@
       const anyTimestamp = bn(1234);
 
       sharedBeforeEach('deploy gauge', async () => {
-        gauge = await deployedAt(contractName, await deployGauge(factory, token.address));
+        gauge = await deployedAt(contractName, await deployGauge(factory, token.address, creationEventName));
       });
 
       context('when the gauge is not added to the gauge controller', () => {
@@ -216,10 +219,11 @@
   async function deployGauge(
     gaugeFactory: Contract,
     poolAddress: string,
+    eventName: string,
     relativeWeightCap: BigNumber = defaultRelativeWeightCap
   ): Promise<string> {
     const tx = await gaugeFactory.create(poolAddress, relativeWeightCap);
-    const event = expectEvent.inReceipt(await tx.wait(), 'GaugeCreated');
+    const event = expectEvent.inReceipt(await tx.wait(), eventName);
 
     return event.args.gauge;
   }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/LinearMath.sol pool-linear/contracts/LinearMath.sol
--- pool-linear/contracts/LinearMath.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-linear/contracts/LinearMath.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // These functions start with an underscore, as if they were part of a contract and not a library. At some point this
 // should be fixed.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/LinearPool.sol pool-linear/contracts/LinearPool.sol
--- pool-linear/contracts/LinearPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/LinearPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,17 +15,18 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/BasePoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/ILinearPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/pool-linear/LinearPoolUserData.sol";
+import "../../interfaces/contracts/pool-utils/IRateProvider.sol";
+import "../../interfaces/contracts/pool-linear/ILinearPool.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
+
+// import "../../pool-utils/contracts/BasePool.sol";
+import "../../pool-utils/contracts/BasePool.sol";
+import "../../pool-utils/contracts/rates/PriceRateCache.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/BasePool.sol";
-import "@balancer-labs/v2-pool-utils/contracts/rates/PriceRateCache.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 import "./LinearMath.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/LinearPoolRebalancer.sol pool-linear/contracts/LinearPoolRebalancer.sol
--- pool-linear/contracts/LinearPoolRebalancer.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/LinearPoolRebalancer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,14 +15,14 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/ILinearPool.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IBalancerQueries.sol";
+import "../../interfaces/contracts/pool-linear/ILinearPool.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 abstract contract LinearPoolRebalancer {
     using SafeERC20 for IERC20;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/aave/AaveLinearPool.sol pool-linear/contracts/aave/AaveLinearPool.sol
--- pool-linear/contracts/aave/AaveLinearPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/aave/AaveLinearPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IStaticAToken.sol";
+import "../../interfaces/contracts/pool-linear/IStaticAToken.sol";
 
 import "../LinearPool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/aave/AaveLinearPoolFactory.sol pool-linear/contracts/aave/AaveLinearPoolFactory.sol
--- pool-linear/contracts/aave/AaveLinearPoolFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/aave/AaveLinearPoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,20 +15,25 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IBalancerQueries.sol";
+import "../../interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
-import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Create2.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/Create2.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 import "./AaveLinearPool.sol";
 import "./AaveLinearPoolRebalancer.sol";
 
-contract AaveLinearPoolFactory is ILastCreatedPoolFactory, BasePoolFactory, ReentrancyGuard, FactoryWidePauseWindow {
+contract AaveLinearPoolFactory is
+    ILastCreatedPoolFactory,
+    BasePoolSplitCodeFactory,
+    ReentrancyGuard,
+    FactoryWidePauseWindow
+{
     // Used for create2 deployments
     uint256 private _nextRebalancerSalt;
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol
--- pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/aave/AaveLinearPoolRebalancer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IStaticAToken.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol";
+import "../../interfaces/contracts/pool-linear/IStaticAToken.sol";
+import "../../interfaces/contracts/pool-utils/ILastCreatedPoolFactory.sol";
 
 import "../LinearPoolRebalancer.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/button-wood/UnbuttonAaveLinearPool.sol pool-linear/contracts/button-wood/UnbuttonAaveLinearPool.sol
--- pool-linear/contracts/button-wood/UnbuttonAaveLinearPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/button-wood/UnbuttonAaveLinearPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IUnbuttonToken.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IAToken.sol";
+import "../../interfaces/contracts/pool-linear/IUnbuttonToken.sol";
+import "../../interfaces/contracts/pool-linear/IAToken.sol";
 
 import "../LinearPool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol
--- pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/button-wood/UnbuttonAaveLinearPoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,17 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
-import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
 
 import "./UnbuttonAaveLinearPool.sol";
 
-contract UnbuttonAaveLinearPoolFactory is BasePoolFactory, FactoryWidePauseWindow {
-    constructor(IVault vault, IProtocolFeePercentagesProvider protocolFeeProvider)
-        BasePoolFactory(vault, protocolFeeProvider, type(UnbuttonAaveLinearPool).creationCode)
-    {
+contract UnbuttonAaveLinearPoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {
+    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(UnbuttonAaveLinearPool).creationCode) {
         // solhint-disable-previous-line no-empty-blocks
     }
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/erc4626/ERC4626LinearPool.sol pool-linear/contracts/erc4626/ERC4626LinearPool.sol
--- pool-linear/contracts/erc4626/ERC4626LinearPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/erc4626/ERC4626LinearPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IERC4626.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IERC4626.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "../LinearPool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol
--- pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/erc4626/ERC4626LinearPoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,17 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
-import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
 
 import "./ERC4626LinearPool.sol";
 
-contract ERC4626LinearPoolFactory is BasePoolFactory, FactoryWidePauseWindow {
-    constructor(IVault vault, IProtocolFeePercentagesProvider protocolFeeProvider)
-        BasePoolFactory(vault, protocolFeeProvider, type(ERC4626LinearPool).creationCode)
-    {
+contract ERC4626LinearPoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {
+    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(ERC4626LinearPool).creationCode) {
         // solhint-disable-previous-line no-empty-blocks
     }
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockAaveAMPLToken.sol pool-linear/contracts/test/MockAaveAMPLToken.sol
--- pool-linear/contracts/test/MockAaveAMPLToken.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-linear/contracts/test/MockAaveAMPLToken.sol	2022-09-16 02:18:01.000000000 -0700
@@ -16,7 +16,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IAToken.sol";
+import "../../interfaces/contracts/pool-linear/IAToken.sol";
 
 import "./MockUnbuttonERC20.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockERC4626Token.sol pool-linear/contracts/test/MockERC4626Token.sol
--- pool-linear/contracts/test/MockERC4626Token.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-linear/contracts/test/MockERC4626Token.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IERC4626.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IERC4626.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/test/TestToken.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/test/TestToken.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 contract MockERC4626Token is TestToken, IERC4626 {
     using FixedPoint for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockLinearPool.sol pool-linear/contracts/test/MockLinearPool.sol
--- pool-linear/contracts/test/MockLinearPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/test/MockLinearPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -51,10 +51,6 @@
         // solhint-disable-previous-line no-empty-blocks
     }
 
-    function setTotalSupply(uint256 value) external {
-        _setTotalSupply(value);
-    }
-
     function getScalingFactor(IERC20 token) external view returns (uint256) {
         return _scalingFactor(token);
     }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockStaticAToken.sol pool-linear/contracts/test/MockStaticAToken.sol
--- pool-linear/contracts/test/MockStaticAToken.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-linear/contracts/test/MockStaticAToken.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IStaticAToken.sol";
+import "../../interfaces/contracts/pool-linear/IStaticAToken.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/test/TestToken.sol";
+import "../../solidity-utils/contracts/test/TestToken.sol";
 
 contract MockStaticAToken is TestToken, IStaticAToken, ILendingPool {
     uint256 private _rate = 1e27;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-linear/contracts/test/MockUnbuttonERC20.sol pool-linear/contracts/test/MockUnbuttonERC20.sol
--- pool-linear/contracts/test/MockUnbuttonERC20.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-linear/contracts/test/MockUnbuttonERC20.sol	2022-09-16 02:18:01.000000000 -0700
@@ -16,10 +16,10 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IButtonWrapper.sol";
+import "../../interfaces/contracts/pool-linear/IButtonWrapper.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 contract MockUnbuttonERC20 is ERC20, IButtonWrapper {
     using SafeERC20 for IERC20;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/ComposableStablePool.sol pool-stable/contracts/ComposableStablePool.sol
--- pool-stable/contracts/ComposableStablePool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/ComposableStablePool.sol	2022-09-16 02:51:51.000000000 -0700
@@ -15,26 +15,25 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-stable/StablePoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../interfaces/contracts/pool-stable/StablePoolUserData.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
+import "../../interfaces/contracts/pool-utils/IRateProvider.sol";
+
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+
+// import "../../pool-utils/contracts/BaseGeneralPool.sol";
+import "../../pool-utils/contracts/BaseGeneralPool.sol";
+import "../../pool-utils/contracts/rates/PriceRateCache.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/BaseGeneralPool.sol";
-import "@balancer-labs/v2-pool-utils/contracts/rates/PriceRateCache.sol";
-
-import "./ComposableStablePoolStorage.sol";
-import "./ComposableStablePoolRates.sol";
 import "./ComposableStablePoolStorage.sol";
 import "./ComposableStablePoolRates.sol";
 import "./ComposableStablePoolProtocolFees.sol";
 import "./StablePoolAmplification.sol";
-import "./StableMath.sol";
+import "../../../harnesses/StableMathHarness.sol";
 
 /**
  * @dev StablePool with preminted BPT and rate providers for each token, allowing for e.g. wrapped tokens with a known
@@ -273,7 +272,7 @@
         uint256[] memory registeredBalances,
         uint256 registeredIndexIn,
         uint256 registeredIndexOut
-    ) private view returns (uint256) {
+    ) private returns (uint256) {
         // Adjust indices and balances for BPT token
         uint256[] memory balances = _dropBptItem(registeredBalances);
         uint256 indexIn = _skipBptIndex(registeredIndexIn);
@@ -308,17 +307,21 @@
         bool isGivenIn = swapRequest.kind == IVault.SwapKind.GIVEN_IN;
 
         _upscaleArray(registeredBalances, scalingFactors);
-        swapRequest.amount = _upscale(
-            swapRequest.amount,
-            scalingFactors[isGivenIn ? registeredIndexIn : registeredIndexOut]
-        );
+        if (isGivenIn)
+            swapRequest.amount = _upscale(
+                swapRequest.amount,
+                scalingFactors[registeredIndexIn]
+            );
+        else
+            swapRequest.amount = _upscale(
+                swapRequest.amount,
+                scalingFactors[registeredIndexOut]
+            );
+
+        (uint256 preJoinExitSupply, uint256[] memory balances) = _payProtocolFeesBeforeJoinExit(registeredBalances);
+        (uint256 currentAmp, ) = _getAmplificationParameter();
 
-        (
-            uint256 preJoinExitSupply,
-            uint256[] memory balances,
-            uint256 currentAmp,
-            uint256 preJoinExitInvariant
-        ) = _beforeJoinExit(registeredBalances);
+        uint256 preJoinExitInvariant = StableMath._calculateInvariant(currentAmp, balances);
 
         // These calls mutate `balances` so that it holds the post join-exit balances.
         (uint256 amountCalculated, uint256 postJoinExitSupply) = registeredIndexOut == getBptIndex()
@@ -365,9 +368,9 @@
         uint256[] memory balances,
         uint256 indexIn,
         uint256 currentAmp,
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant
-    ) internal view returns (uint256, uint256) {
+    ) internal returns (uint256, uint256) {
         return
             isGivenIn
                 ? _joinSwapExactTokenInForBptOut(
@@ -375,7 +378,7 @@
                     balances,
                     indexIn,
                     currentAmp,
-                    actualSupply,
+                    virtualSupply,
                     preJoinExitInvariant
                 )
                 : _joinSwapExactBptOutForTokenIn(
@@ -383,7 +386,7 @@
                     balances,
                     indexIn,
                     currentAmp,
-                    actualSupply,
+                    virtualSupply,
                     preJoinExitInvariant
                 );
     }
@@ -398,9 +401,9 @@
         uint256[] memory balances,
         uint256 indexIn,
         uint256 currentAmp,
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant
-    ) internal view returns (uint256, uint256) {
+    ) internal returns (uint256, uint256) {
         // The StableMath function was created with joins in mind, so it expects a full amounts array. We create an
         // empty one and only set the amount for the token involved.
         uint256[] memory amountsIn = new uint256[](balances.length);
@@ -410,13 +413,13 @@
             currentAmp,
             balances,
             amountsIn,
-            actualSupply,
+            virtualSupply,
             preJoinExitInvariant,
             getSwapFeePercentage()
         );
 
         balances[indexIn] = balances[indexIn].add(amountIn);
-        uint256 postJoinExitSupply = actualSupply.add(bptOut);
+        uint256 postJoinExitSupply = virtualSupply.add(bptOut);
 
         return (bptOut, postJoinExitSupply);
     }
@@ -431,21 +434,21 @@
         uint256[] memory balances,
         uint256 indexIn,
         uint256 currentAmp,
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant
-    ) internal view returns (uint256, uint256) {
+    ) internal returns (uint256, uint256) {
         uint256 amountIn = StableMath._calcTokenInGivenExactBptOut(
             currentAmp,
             balances,
             indexIn,
             bptOut,
-            actualSupply,
+            virtualSupply,
             preJoinExitInvariant,
             getSwapFeePercentage()
         );
 
         balances[indexIn] = balances[indexIn].add(amountIn);
-        uint256 postJoinExitSupply = actualSupply.add(bptOut);
+        uint256 postJoinExitSupply = virtualSupply.add(bptOut);
 
         return (amountIn, postJoinExitSupply);
     }
@@ -460,9 +463,9 @@
         uint256[] memory balances,
         uint256 indexOut,
         uint256 currentAmp,
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant
-    ) internal view returns (uint256, uint256) {
+    ) internal returns (uint256, uint256) {
         return
             isGivenIn
                 ? _exitSwapExactBptInForTokenOut(
@@ -470,7 +473,7 @@
                     balances,
                     indexOut,
                     currentAmp,
-                    actualSupply,
+                    virtualSupply,
                     preJoinExitInvariant
                 )
                 : _exitSwapExactTokenOutForBptIn(
@@ -478,7 +481,7 @@
                     balances,
                     indexOut,
                     currentAmp,
-                    actualSupply,
+                    virtualSupply,
                     preJoinExitInvariant
                 );
     }
@@ -493,21 +496,21 @@
         uint256[] memory balances,
         uint256 indexOut,
         uint256 currentAmp,
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant
-    ) internal view returns (uint256, uint256) {
+    ) internal returns (uint256, uint256) {
         uint256 amountOut = StableMath._calcTokenOutGivenExactBptIn(
             currentAmp,
             balances,
             indexOut,
             bptAmount,
-            actualSupply,
+            virtualSupply,
             preJoinExitInvariant,
             getSwapFeePercentage()
         );
 
         balances[indexOut] = balances[indexOut].sub(amountOut);
-        uint256 postJoinExitSupply = actualSupply.sub(bptAmount);
+        uint256 postJoinExitSupply = virtualSupply.sub(bptAmount);
 
         return (amountOut, postJoinExitSupply);
     }
@@ -522,9 +525,9 @@
         uint256[] memory balances,
         uint256 indexOut,
         uint256 currentAmp,
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant
-    ) internal view returns (uint256, uint256) {
+    ) internal returns (uint256, uint256) {
         // The StableMath function was created with exits in mind, so it expects a full amounts array. We create an
         // empty one and only set the amount for the token involved.
         uint256[] memory amountsOut = new uint256[](balances.length);
@@ -534,13 +537,13 @@
             currentAmp,
             balances,
             amountsOut,
-            actualSupply,
+            virtualSupply,
             preJoinExitInvariant,
             getSwapFeePercentage()
         );
 
         balances[indexOut] = balances[indexOut].sub(amountOut);
-        uint256 postJoinExitSupply = actualSupply.sub(bptAmount);
+        uint256 postJoinExitSupply = virtualSupply.sub(bptAmount);
 
         return (bptAmount, postJoinExitSupply);
     }
@@ -638,34 +641,41 @@
         uint256[] memory scalingFactors,
         bytes memory userData
     ) internal returns (uint256, uint256[] memory) {
-        (
-            uint256 preJoinExitSupply,
-            uint256[] memory balances,
-            uint256 currentAmp,
-            uint256 preJoinExitInvariant
-        ) = _beforeJoinExit(registeredBalances);
-
-
-            function(uint256[] memory, uint256, uint256, uint256, uint256[] memory, bytes memory)
-                internal
-                view
-                returns (uint256, uint256[] memory) _doJoinOrExit
-         = (isJoin ? _doJoin : _doExit);
+        (uint256 preJoinExitSupply, uint256[] memory balances) = _payProtocolFeesBeforeJoinExit(registeredBalances);
+        (uint256 currentAmp, ) = _getAmplificationParameter();
 
-        (uint256 bptAmount, uint256[] memory amountsDelta) = _doJoinOrExit(
-            balances,
-            currentAmp,
-            preJoinExitSupply,
-            preJoinExitInvariant,
-            scalingFactors,
-            userData
-        );
+        uint256 preJoinExitInvariant = StableMath._calculateInvariant(currentAmp, balances);
 
+        uint256 bptAmount;
+        uint256[] memory amountsDelta;
+        if (isJoin) {
+            (bptAmount, amountsDelta) = _doJoin(
+                balances,
+                currentAmp,
+                preJoinExitSupply,
+                preJoinExitInvariant,
+                scalingFactors,
+                userData
+            );
+        } else {
+            (bptAmount, amountsDelta) = _doExit(
+                balances,
+                currentAmp,
+                preJoinExitSupply,
+                preJoinExitInvariant,
+                scalingFactors,
+                userData
+            );
+        }
         // Unlike joinswaps, explicit joins do not mutate balances into the post join-exit balances so we must perform
         // this mutation here.
-        function(uint256, uint256) internal pure returns (uint256) _addOrSub = isJoin ? FixedPoint.add : FixedPoint.sub;
-        _mutateAmounts(balances, amountsDelta, _addOrSub);
-        uint256 postJoinExitSupply = _addOrSub(preJoinExitSupply, bptAmount);
+                function(uint256, uint256) internal pure returns (uint256) _addOrSub = isJoin ? FixedPoint.add : FixedPoint.sub;
+        _mutateAmounts(balances, amountsDelta, isJoin);
+        uint256 postJoinExitSupply;
+        if (isJoin)
+            postJoinExitSupply = FixedPoint.add(preJoinExitSupply, bptAmount);
+        else
+            postJoinExitSupply = FixedPoint.sub(preJoinExitSupply, bptAmount);
 
         // Pass in the post-join balances to reset the protocol fee basis.
         // We are minting bptAmount, increasing the total (and virtual) supply post-join
@@ -683,35 +693,6 @@
     }
 
     /**
-     * @dev Pay any due protocol fees and calculate values necessary for performing the join/exit.
-     */
-    function _beforeJoinExit(uint256[] memory registeredBalances)
-        internal
-        returns (
-            uint256,
-            uint256[] memory,
-            uint256,
-            uint256
-        )
-    {
-        (uint256 lastJoinExitAmp, uint256 lastPostJoinExitInvariant) = getLastJoinExitData();
-        (
-            uint256 preJoinExitSupply,
-            uint256[] memory balances,
-            uint256 oldAmpPreJoinExitInvariant
-        ) = _payProtocolFeesBeforeJoinExit(registeredBalances, lastJoinExitAmp, lastPostJoinExitInvariant);
-
-        // If the amplification factor is the same as it was during the last join/exit then we can reuse the
-        // value calculated using the "old" amplification factor. If not, then we have to calculate this now.
-        (uint256 currentAmp, ) = _getAmplificationParameter();
-        uint256 preJoinExitInvariant = currentAmp == lastJoinExitAmp
-            ? oldAmpPreJoinExitInvariant
-            : StableMath._calculateInvariant(currentAmp, balances);
-
-        return (preJoinExitSupply, balances, currentAmp, preJoinExitInvariant);
-    }
-
-    /**
      * @dev Support single- and multi-token joins, but not explicit proportional joins.
      */
     function _doJoin(
@@ -721,7 +702,7 @@
         uint256 preJoinExitInvariant,
         uint256[] memory scalingFactors,
         bytes memory userData
-    ) internal view returns (uint256, uint256[] memory) {
+    ) internal returns (uint256, uint256[] memory) {
         StablePoolUserData.JoinKind kind = userData.joinKind();
         if (kind == StablePoolUserData.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {
             return
@@ -744,13 +725,13 @@
      * @dev Multi-token join. Joins with proportional amounts will pay no protocol fees.
      */
     function _joinExactTokensInForBPTOut(
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant,
         uint256 currentAmp,
         uint256[] memory balances,
         uint256[] memory scalingFactors,
         bytes memory userData
-    ) private view returns (uint256, uint256[] memory) {
+    ) private returns (uint256, uint256[] memory) {
         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();
         InputHelpers.ensureInputLengthMatch(balances.length, amountsIn.length);
 
@@ -761,7 +742,7 @@
             currentAmp,
             balances,
             amountsIn,
-            actualSupply,
+            virtualSupply,
             preJoinExitInvariant,
             getSwapFeePercentage()
         );
@@ -775,12 +756,12 @@
      * @dev Single-token join, equivalent to swapping a pool token for BPT.
      */
     function _joinTokenInForExactBPTOut(
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant,
         uint256 currentAmp,
         uint256[] memory balances,
         bytes memory userData
-    ) private view returns (uint256, uint256[] memory) {
+    ) private returns (uint256, uint256[] memory) {
         // Since this index is sent in from the user, we interpret it as NOT including the BPT token.
         (uint256 bptAmountOut, uint256 tokenIndex) = userData.tokenInForExactBptOut();
         // Note that there is no maximum amountIn parameter: this is handled by `IVault.joinPool`.
@@ -797,7 +778,7 @@
             balances,
             tokenIndex,
             bptAmountOut,
-            actualSupply,
+            virtualSupply,
             preJoinExitInvariant,
             getSwapFeePercentage()
         );
@@ -818,7 +799,7 @@
         uint256 preJoinExitInvariant,
         uint256[] memory scalingFactors,
         bytes memory userData
-    ) internal view returns (uint256, uint256[] memory) {
+    ) internal returns (uint256, uint256[] memory) {
         StablePoolUserData.ExitKind kind = userData.exitKind();
         if (kind == StablePoolUserData.ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {
             return
@@ -841,13 +822,13 @@
      * @dev Multi-token exit. Proportional exits will pay no protocol fees.
      */
     function _exitBPTInForExactTokensOut(
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant,
         uint256 currentAmp,
         uint256[] memory balances,
         uint256[] memory scalingFactors,
         bytes memory userData
-    ) private view returns (uint256, uint256[] memory) {
+    ) private returns (uint256, uint256[] memory) {
         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();
         InputHelpers.ensureInputLengthMatch(amountsOut.length, balances.length);
 
@@ -858,7 +839,7 @@
             currentAmp,
             balances,
             amountsOut,
-            actualSupply,
+            virtualSupply,
             preJoinExitInvariant,
             getSwapFeePercentage()
         );
@@ -871,12 +852,12 @@
      * @dev Single-token exit, equivalent to swapping BPT for a pool token.
      */
     function _exitExactBPTInForTokenOut(
-        uint256 actualSupply,
+        uint256 virtualSupply,
         uint256 preJoinExitInvariant,
         uint256 currentAmp,
         uint256[] memory balances,
         bytes memory userData
-    ) private view returns (uint256, uint256[] memory) {
+    ) private returns (uint256, uint256[] memory) {
         // Since this index is sent in from the user, we interpret it as NOT including the BPT token
         (uint256 bptAmountIn, uint256 tokenIndex) = userData.exactBptInForTokenOut();
         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.
@@ -892,7 +873,7 @@
             balances,
             tokenIndex,
             bptAmountIn,
-            actualSupply,
+            virtualSupply,
             preJoinExitInvariant,
             getSwapFeePercentage()
         );
@@ -910,9 +891,6 @@
     ) internal virtual override returns (uint256, uint256[] memory) {
         // Since this Pool uses preminted BPT, we need to replace the total supply with the virtual total supply, and
         // adjust the balances array by removing BPT from it.
-        // Note that we don't compute the actual supply, which would require a lot of complex calculations and
-        // interactions with external components. This is fine because virtual and actual supply are the same while
-        // recovery mode is enabled (since all protocol fees are forfeit and the fee percentages zeroed out).
         (uint256 virtualSupply, uint256[] memory balances) = _dropBptItemFromBalances(registeredBalances);
 
         (uint256 bptAmountIn, uint256[] memory amountsOut) = super._doRecoveryModeExit(
@@ -928,179 +906,19 @@
     // BPT rate
 
     /**
-     * Many functions require accessing multiple internal values that might at first seem unrelated, but are actually
-     * quite intertwined, and computed at the same time for optimal performance (since calculating some of them also
-     * yields intermediate results useful for other queries). This helper function returns many of these values,
-     * greatly reducing bytecode size.
-     *
-     * The return values are:
-     *  @return balances - The current upscaled token balances (not including BPT)
-     *  @return virtualSupply - The Pool's virtual supply
-     *  @return protocolFeeAmount - The amount of unpaid protocol fees in BPT
-     *  @return lastJoinExitAmp - The Pool's amplification factor at the last join or exit operation
-     *  @return currentInvariantWithLastJoinExitAmp - The invariant of the current balances, calculated using the
-     *  amplification factor at the last join or exit operation.
-     */
-    function _getSupplyAndFeesData()
-        private
-        view
-        returns (
-            uint256[] memory balances,
-            uint256 virtualSupply,
-            uint256 protocolFeeAmount,
-            uint256 lastJoinExitAmp,
-            uint256 currentInvariantWithLastJoinExitAmp
-        )
-    {
-        // First we query the Vault for current registered balances (which includes preminted BPT), to then calculate
-        // the current scaled balances and virtual supply.
-        (, uint256[] memory registeredBalances, ) = getVault().getPoolTokens(getPoolId());
-        _upscaleArray(registeredBalances, _scalingFactors());
-        (virtualSupply, balances) = _dropBptItemFromBalances(registeredBalances);
-
-        // Now we need to calculate any BPT due in the form of protocol fees. This requires data from the last join or
-        // exit operation. `lastJoinExitAmp` can be useful in the scenario in which the amplification factor has not
-        // changed, meaning this old value is equal to the current value.
-        uint256 lastPostJoinExitInvariant;
-        (lastJoinExitAmp, lastPostJoinExitInvariant) = getLastJoinExitData();
-
-        // Computing the protocol ownership percentage also yields the invariant using the old amplification factor. If
-        // it has not changed, then this is also the current invariant.
-        uint256 expectedProtocolOwnershipPercentage;
-        (
-            expectedProtocolOwnershipPercentage,
-            currentInvariantWithLastJoinExitAmp
-        ) = _getProtocolPoolOwnershipPercentage(balances, lastJoinExitAmp, lastPostJoinExitInvariant);
-
-        protocolFeeAmount = ProtocolFees.bptForPoolOwnershipPercentage(
-            virtualSupply,
-            expectedProtocolOwnershipPercentage
-        );
-    }
-
-    /**
-     * @dev This function returns the appreciation of BPT relative to the underlying tokens, as an 18 decimal fixed
-     * point number. It is simply the ratio of the invariant to the BPT supply.
-     *
-     * The total supply is initialized to equal the invariant, so this value starts at one. During Pool operation the
-     * invariant always grows and shrinks either proportionally to the total supply (in scenarios with no price impact,
-     * e.g. proportional joins), or grows faster and shrinks more slowly than it (whenever swap fees are collected or
-     * the token rates increase). Therefore, the rate is a monotonically increasing function.
-     *
-     * WARNING: since this function reads balances directly from the Vault, it is potentially subject to manipulation
-     * via reentrancy. However, this can only happen if one of the tokens in the Pool contains some form of callback
-     * behavior in the `transferFrom` function (like ERC777 tokens do). These tokens are strictly incompatible with the
-     * Vault and Pool design, and are not safe to be used.
-     */
-    function getRate() external view virtual override returns (uint256) {
-        // We need to compute the current invariant and actual total supply. The latter includes protocol fees that have
-        // accrued but are not yet minted: in calculating these we'll actually end up fetching most of the data we need
-        // for the invariant.
-
-        (
-            uint256[] memory balances,
-            uint256 virtualSupply,
-            uint256 protocolFeeAmount,
-            uint256 lastJoinExitAmp,
-            uint256 currentInvariantWithLastJoinExitAmp
-        ) = _getSupplyAndFeesData();
-
-        // Due protocol fees will be minted at the next join or exit, so we can simply add them to the current virtual
-        // supply to get the actual supply.
-        uint256 actualTotalSupply = virtualSupply.add(protocolFeeAmount);
-
-        // All that's missing now is the invariant. We have the balances required to calculate it already, but still
-        // need the current amplification factor.
-        (uint256 currentAmp, ) = _getAmplificationParameter();
-
-        // It turns out that the process for due protocol fee calculation involves computing the current invariant,
-        // except using the amplification factor at the last join or exit. This would typically not be terribly useful,
-        // but since the amplification factor only changes rarely there is high probability of its current value being
-        // the same as it was in the last join or exit. If that is the case, then we can skip the costly invariant
-        // computation altogether.
-        uint256 currentInvariant = (currentAmp == lastJoinExitAmp)
-            ? currentInvariantWithLastJoinExitAmp
-            : StableMath._calculateInvariant(currentAmp, balances);
-
-        // With the current invariant and actual total supply, we can compute the rate as a fixed-point number.
-        return currentInvariant.divDown(actualTotalSupply);
-    }
-
-    /**
-     * @dev Returns the effective BPT supply.
-     *
-     * In other pools, this would be the same as `totalSupply`, but there are two key differences here:
-     *  - this pool pre-mints BPT and holds it in the Vault as a token, and as such we need to subtract the Vault's
-     *    balance to get the total "circulating supply". This is called the 'virtualSupply'.
-     *  - the Pool owes debt to the Protocol in the form of unminted BPT, which will be minted immediately before the
-     *    next join or exit. We need to take these into account since, even if they don't yet exist, they will
-     *    effectively be included in any Pool operation that involves BPT.
-     *
-     * In the vast majority of cases, this function should be used instead of `totalSupply()`.
-     */
-    function getActualSupply() external view returns (uint256) {
-        (, uint256 virtualSupply, uint256 protocolFeeAmount, , ) = _getSupplyAndFeesData();
-        return virtualSupply.add(protocolFeeAmount);
-    }
-
-    function _beforeProtocolFeeCacheUpdate() internal override {
-        // The `getRate()` function depends on the actual supply, which in turn depends on the cached protocol fee
-        // percentages. Changing these would therefore result in the rate changing, which is not acceptable as this is a
-        // sensitive value.
-        // Because of this, we pay any due protocol fees *before* updating the cache, making it so that the new
-        // percentages only affect future operation of the Pool, and not past fees. As a result, `getRate()` is
-        // unaffected by the cached protocol fee percentages changing.
-
-        // Given that this operation is state-changing and relatively complex, we only allow it as long as the Pool is
-        // not paused.
-        _ensureNotPaused();
-
-        // We need to calculate the amount of unminted BPT that represents protocol fees to then pay those. This yields
-        // some auxiliary values that turn out to also be useful for the rest of the tasks we want to perform.
-        (
-            uint256[] memory balances,
-            ,
-            uint256 protocolFeeAmount,
-            uint256 lastJoinExitAmp,
-            uint256 currentInvariantWithLastJoinExitAmp
-        ) = _getSupplyAndFeesData();
-
-        if (protocolFeeAmount > 0) {
-            _payProtocolFees(protocolFeeAmount);
-        }
-
-        // With the fees paid, we now need to calculate the current invariant so we can store it alongside the current
-        // amplification factor, marking the Pool as free of protocol debt.
-        (uint256 currentAmp, ) = _getAmplificationParameter();
+     * @dev This function returns the appreciation of one BPT relative to the
+     * underlying tokens. This starts at 1 when the pool is created and grows over time.
+     * Because of preminted BPT, it uses `getVirtualSupply` instead of `totalSupply`.
+     */
+    function getRate() public virtual override returns (uint256) {
+        (, uint256[] memory balancesIncludingBpt, ) = getVault().getPoolTokens(getPoolId());
+        _upscaleArray(balancesIncludingBpt, _scalingFactors());
 
-        // It turns out that the process for due protocol fee calculation involves computing the current invariant,
-        // except using the amplification factor at the last join or exit. This would typically not be terribly useful,
-        // but since the amplification factor only changes rarely there is high probability of its current value being
-        // the same as it was in the last join or exit. If that is the case, then we can skip the costly invariant
-        // computation altogether.
-        uint256 currentInvariant = (currentAmp == lastJoinExitAmp)
-            ? currentInvariantWithLastJoinExitAmp
-            : StableMath._calculateInvariant(currentAmp, balances);
-
-        _updatePostJoinExit(currentAmp, currentInvariant);
-    }
-
-    function _onDisableRecoveryMode() internal override {
-        // Enabling recovery mode short-circuits protocol fee computations, forcefully returning a zero percentage,
-        // increasing the return value of `getRate()` and effectively forfeiting due protocol fees.
-
-        // Therefore, when exiting recovery mode we store the current invariant and the amplification factor used to
-        // compute it, marking the Pool as free of protocol debt. Otherwise it'd be possible for debt to be
-        // retroactively accrued, which would be incorrect and could lead to the value of `getRate` decreasing.
-
-        (, uint256[] memory registeredBalances, ) = getVault().getPoolTokens(getPoolId());
-        _upscaleArray(registeredBalances, _scalingFactors());
-        uint256[] memory balances = _dropBptItem(registeredBalances);
+        (uint256 virtualSupply, uint256[] memory balances) = _dropBptItemFromBalances(balancesIncludingBpt);
 
         (uint256 currentAmp, ) = _getAmplificationParameter();
-        uint256 currentInvariant = StableMath._calculateInvariant(currentAmp, balances);
 
-        _updatePostJoinExit(currentAmp, currentInvariant);
+        return StableMath._getRate(balances, currentAmp, virtualSupply);
     }
 
     // Helpers
@@ -1113,13 +931,16 @@
     function _mutateAmounts(
         uint256[] memory toMutate,
         uint256[] memory arguments,
-        function(uint256, uint256) pure returns (uint256) mutation
+        bool isJoin
     ) private pure {
         uint256 length = toMutate.length;
         InputHelpers.ensureInputLengthMatch(length, arguments.length);
 
         for (uint256 i = 0; i < length; ++i) {
-            toMutate[i] = mutation(toMutate[i], arguments[i]);
+            if (isJoin) 
+                toMutate[i] = FixedPoint.add(toMutate[i], arguments[i]);
+            else
+                toMutate[i] = FixedPoint.sub(toMutate[i], arguments[i]);
         }
     }
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/ComposableStablePoolFactory.sol pool-stable/contracts/ComposableStablePoolFactory.sol
--- pool-stable/contracts/ComposableStablePoolFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/ComposableStablePoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,18 +15,21 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
-import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
 
 import "./ComposableStablePool.sol";
 
-contract ComposableStablePoolFactory is BasePoolFactory, FactoryWidePauseWindow {
+contract ComposableStablePoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {
+    IProtocolFeePercentagesProvider private _protocolFeeProvider;
+
     constructor(IVault vault, IProtocolFeePercentagesProvider protocolFeeProvider)
-        BasePoolFactory(vault, protocolFeeProvider, type(ComposableStablePool).creationCode)
+        BasePoolSplitCodeFactory(vault, type(ComposableStablePool).creationCode)
     {
-        // solhint-disable-previous-line no-empty-blocks
+        _protocolFeeProvider = protocolFeeProvider;
     }
 
     /**
@@ -50,7 +53,7 @@
                     abi.encode(
                         ComposableStablePool.NewPoolParams({
                             vault: getVault(),
-                            protocolFeeProvider: getProtocolFeePercentagesProvider(),
+                            protocolFeeProvider: _protocolFeeProvider,
                             name: name,
                             symbol: symbol,
                             tokens: tokens,
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/ComposableStablePoolProtocolFees.sol pool-stable/contracts/ComposableStablePoolProtocolFees.sol
--- pool-stable/contracts/ComposableStablePoolProtocolFees.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/ComposableStablePoolProtocolFees.sol	2022-09-16 02:48:11.000000000 -0700
@@ -15,14 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
-import "@balancer-labs/v2-pool-utils/contracts/protocol-fees/ProtocolFeeCache.sol";
-import "@balancer-labs/v2-pool-utils/contracts/protocol-fees/InvariantGrowthProtocolSwapFees.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../pool-utils/contracts/ProtocolFeeCache.sol";
 
 import "./ComposableStablePoolStorage.sol";
 import "./ComposableStablePoolRates.sol";
-import "./StableMath.sol";
+import "../../../harnesses/StableMathHarness.sol";
 
 abstract contract ComposableStablePoolProtocolFees is
     ComposableStablePoolStorage,
@@ -56,56 +55,42 @@
 
     /**
      * @dev Calculates due protocol fees originating from accumulated swap fees and yield of non-exempt tokens, pays
-     * them by minting BPT, and returns the actual supply and current balances.
-     *
-     * We also return the current invariant computed using the amplification factor at the last join or exit, which can
-     * be useful to skip computations in scenarios where the amplification factor is not changing.
+     * them by minting BPT, and returns the updated virtual supply and current balances.
      */
-    function _payProtocolFeesBeforeJoinExit(
-        uint256[] memory registeredBalances,
-        uint256 lastJoinExitAmp,
-        uint256 lastPostJoinExitInvariant
-    )
+    function _payProtocolFeesBeforeJoinExit(uint256[] memory registeredBalances)
         internal
-        returns (
-            uint256,
-            uint256[] memory,
-            uint256
-        )
+        returns (uint256, uint256[] memory)
     {
         (uint256 virtualSupply, uint256[] memory balances) = _dropBptItemFromBalances(registeredBalances);
 
         // First, we'll compute what percentage of the Pool the protocol should own due to charging protocol fees on
         // swap fees and yield.
-        (
-            uint256 expectedProtocolOwnershipPercentage,
-            uint256 currentInvariantWithLastJoinExitAmp
-        ) = _getProtocolPoolOwnershipPercentage(balances, lastJoinExitAmp, lastPostJoinExitInvariant);
-
-        // Now that we know what percentage of the Pool's current value the protocol should own, we can compute how
-        // much BPT we need to mint to get to this state. Since we're going to mint BPT for the protocol, the value
-        // of each BPT is going to be reduced as all LPs get diluted.
-        uint256 protocolFeeAmount = ProtocolFees.bptForPoolOwnershipPercentage(
-            virtualSupply,
-            expectedProtocolOwnershipPercentage
+        uint256 expectedProtocolOwnershipPercentage = _getProtocolPoolOwnershipPercentage(balances);
+
+        // Now that we know what percentage of the Pool's current value the protocol should own, we can compute how much
+        // BPT we need to mint to get to this state. Since we're going to mint BPT for the protocol, the value of each
+        // BPT is going to be reduced as all LPs get diluted. The percentage of the Pool the protocol will own after
+        // minting is given by `protocol percentage = to mint / (current supply + to mint)`.
+        // Solving for `to mint`, we arrive at:
+        // `to mint = current supply * protocol percentage / (1 - protocol percentage)`.
+
+        uint256 protocolFeeAmount = virtualSupply.mulDown(expectedProtocolOwnershipPercentage).divDown(
+            expectedProtocolOwnershipPercentage.complement()
         );
 
         if (protocolFeeAmount > 0) {
             _payProtocolFees(protocolFeeAmount);
         }
 
-        // We pay fees before a join or exit to ensure the pool is debt-free. This increases the virtual supply (making
-        // it match the actual supply).
+        // We pay fees before a join or exit to ensure the pool is debt-free, so that swap fee and quote calculations
+        // based on the virtual supply reflect only the current user's transaction. We have just increased the virtual
+        // supply by minting the protocol fee tokens, so those are included in the return value.
         //
-        // For this addition to overflow, `totalSupply` would also have already overflowed.
-        return (virtualSupply + protocolFeeAmount, balances, currentInvariantWithLastJoinExitAmp);
+        // For this addition to overflow, the actual total supply would have already overflowed.
+        return (virtualSupply + protocolFeeAmount, balances);
     }
 
-    function _getProtocolPoolOwnershipPercentage(
-        uint256[] memory balances,
-        uint256 lastJoinExitAmp,
-        uint256 lastPostJoinExitInvariant
-    ) internal view returns (uint256, uint256) {
+    function _getProtocolPoolOwnershipPercentage(uint256[] memory balances) internal returns (uint256) {
         // We compute three invariants, adjusting the balances of tokens that have rate providers by undoing the current
         // rate adjustment and then applying the old rate. This is equivalent to multiplying by old rate / current rate.
         //
@@ -123,6 +108,8 @@
         // growth. If the last join-exit amplification equals the current one, this invariant equals the current
         // invariant.
 
+        (uint256 lastJoinExitAmp, uint256 lastPostJoinExitInvariant) = getLastJoinExitData();
+
         (
             uint256 swapFeeGrowthInvariant,
             uint256 totalNonExemptGrowthInvariant,
@@ -155,15 +142,6 @@
         // Each invariant should be larger than its precedessor. In case any rounding error results in them being
         // smaller, we adjust the subtraction to equal 0.
 
-        // Note: in the unexpected scenario where the rates of the tokens shrink over time instead of growing (i.e. if
-        // the yield is negative), the non-exempt growth invariant might actually be *smaller* than the swap fee growth
-        // invariant, and the total growth invariant might be *smaller* than the non-exempt growth invariant. Depending
-        // on the order in which swaps, joins/exits and rate changes happen, as well as their relative magnitudes, it is
-        // possible for the Pool to either pay more or less protocol fees than it should.
-        // Due to the complexity that handling all of these cases would introduce, this behavior is considered out of
-        // scope, and is expected to be handled on a case-by-case basis if the token rates were to ever decrease (which
-        // would also mean that the Pool value has dropped).
-
         uint256 swapFeeGrowthInvariantDelta = (swapFeeGrowthInvariant > lastPostJoinExitInvariant)
             ? swapFeeGrowthInvariant - lastPostJoinExitInvariant
             : 0;
@@ -184,13 +162,11 @@
         );
 
         // These percentages can then be simply added to compute the total protocol Pool ownership percentage.
-        // This is naturally bounded above by FixedPoint.ONE so this addition cannot overflow.
-        return (protocolSwapFeePercentage + protocolYieldPercentage, totalGrowthInvariant);
+        return protocolSwapFeePercentage.add(protocolYieldPercentage);
     }
 
     function _getGrowthInvariants(uint256[] memory balances, uint256 lastJoinExitAmp)
         internal
-        view
         returns (
             uint256 swapFeeGrowthInvariant,
             uint256 totalNonExemptGrowthInvariant,
@@ -234,12 +210,8 @@
         }
     }
 
-    /**
-     * @dev Store the latest invariant based on the adjusted balances after the join or exit, using current rates.
-     * Also cache the amp factor, so that the invariant is not affected by amp updates between joins and exits.
-     *
-     * Pay protocol fees due on any current join or exit swap.
-     */
+    // Store the latest invariant based on the adjusted balances after the join or exit, using current rates.
+    // Also cache the amp factor, so that the invariant is not affected by amp updates between joins and exits.
     function _updateInvariantAfterJoinExit(
         uint256 currentAmp,
         uint256[] memory balances,
@@ -247,36 +219,50 @@
         uint256 preJoinExitSupply,
         uint256 postJoinExitSupply
     ) internal {
-        // `_payProtocolFeesBeforeJoinExit` paid protocol fees accumulated between the previous and current
-        // join or exit, while this code pays any protocol fees due on the current join or exit.
-        // The amp and rates are constant during a single transaction, so it doesn't matter if there
-        // is an ongoing amp change, and we can ignore yield.
+        uint256 postJoinExitInvariant = StableMath._calculateInvariant(currentAmp, balances);
 
         // Compute the growth ratio between the pre- and post-join/exit balances.
         // Note that the pre-join/exit invariant is *not* the invariant from the last join,
         // but computed from the balances before this particular join/exit.
 
-        uint256 postJoinExitInvariant = StableMath._calculateInvariant(currentAmp, balances);
+        uint256 protocolSwapFeePercentage = getProtocolFeePercentageCache(ProtocolFeeType.SWAP);
 
-        uint256 protocolFeeAmount = InvariantGrowthProtocolSwapFees.calcDueProtocolFees(
-            postJoinExitInvariant.divDown(preJoinExitInvariant),
-            preJoinExitSupply,
-            postJoinExitSupply,
-            getProtocolFeePercentageCache(ProtocolFeeType.SWAP)
-        );
+        if (protocolSwapFeePercentage > 0) {
+            uint256 invariantGrowthRatio = (
+                postJoinExitInvariant > preJoinExitInvariant
+                    ? postJoinExitInvariant.sub(preJoinExitInvariant)
+                    : preJoinExitInvariant.sub(postJoinExitInvariant)
+            )
+                .divDown(preJoinExitInvariant);
+
+            // Compute the bpt ratio
+            uint256 bptGrowthRatio = (
+                postJoinExitSupply > preJoinExitInvariant
+                    ? postJoinExitSupply.sub(preJoinExitSupply)
+                    : preJoinExitSupply.sub(postJoinExitSupply)
+            )
+                .divDown(preJoinExitSupply);
+
+            // The difference between the invariant growth and bpt increase rates must be due to the
+            // balance change from this join/exit.
+            // Protocol fees due = (invariant growth / bpt increase - 1) * virtual supply * protocol fee %
+            // For instance, if the invariant growth is 1.05, and the bpt increase is 1.0475, with 1000 supply,
+            // and a protocol fee of 50%, we would mint (1.05/1.0475 - 1) * 1000 * 0.5 = 1.193 BPT.
+
+            if (invariantGrowthRatio > bptGrowthRatio) {
+                uint256 protocolFeeAmount = invariantGrowthRatio
+                    .divDown(bptGrowthRatio)
+                    .sub(FixedPoint.ONE)
+                    .mulDown(preJoinExitSupply)
+                    .mulDown(protocolSwapFeePercentage);
 
-        if (protocolFeeAmount > 0) {
-            _payProtocolFees(protocolFeeAmount);
+                _payProtocolFees(protocolFeeAmount);
+            }
         }
 
         _updatePostJoinExit(currentAmp, postJoinExitInvariant);
     }
 
-    /**
-     * @dev Update the stored values of the amp and final post-join/exit invariant, to reset the basis for protocol
-     * swap fees. Also copy the current rates to the old rates, to establish the new protocol yield basis for protocol
-     * yield fees.
-     */
     function _updatePostJoinExit(uint256 currentAmp, uint256 postJoinExitInvariant) internal {
         _lastJoinExitData =
             WordCodec.encodeUint(currentAmp, _LAST_JOIN_EXIT_AMPLIFICATION_OFFSET, _LAST_JOIN_EXIT_AMPLIFICATION_SIZE) |
@@ -289,25 +275,20 @@
         _updateOldRates();
     }
 
-    /**
-     * @notice Return the amplification factor and invariant as of the most recent join or exit (including BPT swaps)
-     */
-    function getLastJoinExitData()
-        public
-        view
-        returns (uint256 lastJoinExitAmplification, uint256 lastPostJoinExitInvariant)
-    {
+    function getLastJoinExitData() public view returns (uint256, uint256) {
         bytes32 rawData = _lastJoinExitData;
 
-        lastJoinExitAmplification = rawData.decodeUint(
+        uint256 lastJoinExitAmplification = rawData.decodeUint(
             _LAST_JOIN_EXIT_AMPLIFICATION_OFFSET,
             _LAST_JOIN_EXIT_AMPLIFICATION_SIZE
         );
 
-        lastPostJoinExitInvariant = rawData.decodeUint(
+        uint256 lastPostJoinExitInvariant = rawData.decodeUint(
             _LAST_POST_JOIN_EXIT_INVARIANT_OFFSET,
             _LAST_POST_JOIN_EXIT_INVARIANT_SIZE
         );
+
+        return (lastJoinExitAmplification, lastPostJoinExitInvariant);
     }
 
     /**
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/ComposableStablePoolRates.sol pool-stable/contracts/ComposableStablePoolRates.sol
--- pool-stable/contracts/ComposableStablePoolRates.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/ComposableStablePoolRates.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,12 +14,12 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/pool-utils/IRateProvider.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-pool-utils/contracts/rates/PriceRateCache.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../pool-utils/contracts/rates/PriceRateCache.sol";
 
 import "./ComposableStablePoolStorage.sol";
 
@@ -186,9 +186,21 @@
      */
     function _cacheTokenRatesIfNecessary() internal {
         uint256 totalTokens = _getTotalTokens();
-        for (uint256 i = 0; i < totalTokens; ++i) {
-            _cacheTokenRateIfNecessary(i);
-        }
+
+        // The Pool will always have at least 3 tokens so we always try to update these three caches.
+        _cacheTokenRateIfNecessary(0);
+        _cacheTokenRateIfNecessary(1);
+        _cacheTokenRateIfNecessary(2);
+
+        // Before we update the remaining caches we must check that the Pool contains enough tokens.
+        if (totalTokens == 3) return;
+        _cacheTokenRateIfNecessary(3);
+
+        if (totalTokens == 4) return;
+        _cacheTokenRateIfNecessary(4);
+
+        if (totalTokens == 5) return;
+        _cacheTokenRateIfNecessary(5);
     }
 
     /**
@@ -215,10 +227,13 @@
     // To compute the yield protocol fees, we need the oldRate for all tokens, even if the exempt flag is not set.
     // We do need to ensure the token has a rate provider before updating; otherwise it will not be in the cache.
     function _updateOldRates() internal {
-        uint256 totalTokens = _getTotalTokens();
-        for (uint256 i = 0; i < totalTokens; ++i) {
-            if (_hasRateProvider(i)) _updateOldRate(i);
-        }
+        // _hasRateProvider returns false for unused indices so we don't need to check for token existence.
+        if (_hasRateProvider(0)) _updateOldRate(0);
+        if (_hasRateProvider(1)) _updateOldRate(1);
+        if (_hasRateProvider(2)) _updateOldRate(2);
+        if (_hasRateProvider(3)) _updateOldRate(3);
+        if (_hasRateProvider(4)) _updateOldRate(4);
+        if (_hasRateProvider(5)) _updateOldRate(5);
     }
 
     /**
@@ -259,9 +274,21 @@
         uint256 totalTokens = _getTotalTokens();
         uint256[] memory scalingFactors = new uint256[](totalTokens);
 
-        for (uint256 i = 0; i < totalTokens; ++i) {
-            scalingFactors[i] = _getScalingFactor(i).mulDown(_getTokenRate(i));
-        }
+        // The Pool will always have at least 3 tokens so we always load these three scaling factors.
+        // Given there is no generic direction for this rounding, it follows the same strategy as the BasePool.
+        scalingFactors[0] = _getScalingFactor0().mulDown(_getTokenRate(0));
+        scalingFactors[1] = _getScalingFactor1().mulDown(_getTokenRate(1));
+        scalingFactors[2] = _getScalingFactor2().mulDown(_getTokenRate(2));
+
+        // Before we load the remaining scaling factors we must check that the Pool contains enough tokens.
+        if (totalTokens == 3) return scalingFactors;
+        scalingFactors[3] = _getScalingFactor3().mulDown(_getTokenRate(3));
+
+        if (totalTokens == 4) return scalingFactors;
+        scalingFactors[4] = _getScalingFactor4().mulDown(_getTokenRate(4));
+
+        if (totalTokens == 5) return scalingFactors;
+        scalingFactors[5] = _getScalingFactor5().mulDown(_getTokenRate(5));
 
         return scalingFactors;
     }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/ComposableStablePoolStorage.sol pool-stable/contracts/ComposableStablePoolStorage.sol
--- pool-stable/contracts/ComposableStablePoolStorage.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/ComposableStablePoolStorage.sol	2022-09-16 02:44:00.000000000 -0700
@@ -14,13 +14,14 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/pool-utils/IRateProvider.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/BasePool.sol";
+// import "../../pool-utils/contracts/BasePool.sol";
+import "../../pool-utils/contracts/BasePool.sol";
 
-import "./StableMath.sol";
+// import "../../../harnesses/StableMathHarness.sol";
 
 abstract contract ComposableStablePoolStorage is BasePool {
     using FixedPoint for uint256;
@@ -33,8 +34,8 @@
     }
 
     // This minimum refers not to the total tokens, but rather to the non-BPT tokens. The minimum value for _totalTokens
-    // is therefore _MIN_NON_BPT_TOKENS + 1.
-    uint256 private constant _MIN_NON_BPT_TOKENS = 2;
+    // is therefore _MIN_TOKENS + 1.
+    uint256 private constant _MIN_TOKENS = 2;
 
     // The Pool will register n+1 tokens, where n are the actual tokens in the Pool, and the other one is the BPT
     // itself.
@@ -44,12 +45,12 @@
     uint256 private immutable _bptIndex;
 
     // These are the registered tokens: one of them will be the BPT.
-    IERC20 private immutable _token0;
-    IERC20 private immutable _token1;
-    IERC20 private immutable _token2;
-    IERC20 private immutable _token3;
-    IERC20 private immutable _token4;
-    IERC20 private immutable _token5;
+    IERC20 internal immutable _token0;
+    IERC20 internal immutable _token1;
+    IERC20 internal immutable _token2;
+    IERC20 internal immutable _token3;
+    IERC20 internal immutable _token4;
+    IERC20 internal immutable _token5;
 
     // All token balances are normalized to behave as if the token had 18 decimals. We assume a token's decimals will
     // not change throughout its lifetime, and store the corresponding scaling factor for each at construction time.
@@ -64,12 +65,12 @@
 
     // Rate Providers accommodate tokens with a known price ratio, such as Compound's cTokens.
 
-    IRateProvider internal immutable _rateProvider0;
-    IRateProvider internal immutable _rateProvider1;
-    IRateProvider internal immutable _rateProvider2;
-    IRateProvider internal immutable _rateProvider3;
-    IRateProvider internal immutable _rateProvider4;
-    IRateProvider internal immutable _rateProvider5;
+    IRateProvider private immutable _rateProvider0;
+    IRateProvider private immutable _rateProvider1;
+    IRateProvider private immutable _rateProvider2;
+    IRateProvider private immutable _rateProvider3;
+    IRateProvider private immutable _rateProvider4;
+    IRateProvider private immutable _rateProvider5;
 
     // This is a bitmap which allows querying whether a token at a particular index:
     // - has a rate provider associated with it.
@@ -94,7 +95,7 @@
         // need to check ourselves that there are at least creator-supplied tokens (i.e. the minimum number of total
         // tokens for this contract is actually three, including the BPT).
         uint256 totalTokens = params.registeredTokens.length;
-        _require(totalTokens > _MIN_NON_BPT_TOKENS, Errors.MIN_TOKENS);
+        _require(totalTokens > _MIN_TOKENS, Errors.MIN_TOKENS);
         InputHelpers.ensureInputLengthMatch(
             totalTokens - 1,
             params.tokenRateProviders.length,
@@ -221,6 +222,30 @@
         _revert(Errors.INVALID_TOKEN);
     }
 
+    function _getScalingFactor0() internal view returns (uint256) {
+        return _scalingFactor0;
+    }
+
+    function _getScalingFactor1() internal view returns (uint256) {
+        return _scalingFactor1;
+    }
+
+    function _getScalingFactor2() internal view returns (uint256) {
+        return _scalingFactor2;
+    }
+
+    function _getScalingFactor3() internal view returns (uint256) {
+        return _scalingFactor3;
+    }
+
+    function _getScalingFactor4() internal view returns (uint256) {
+        return _scalingFactor4;
+    }
+
+    function _getScalingFactor5() internal view returns (uint256) {
+        return _scalingFactor5;
+    }
+
     function _scalingFactor(IERC20) internal view virtual override returns (uint256) {
         // We never use a single token's scaling factor by itself, we always process the entire array at once.
         // Therefore we don't bother providing an implementation for this.
@@ -296,39 +321,60 @@
 
     // Rate Providers
 
-    function _getScalingFactor(uint256 index) internal view returns (uint256) {
-        if (index == 0) return _scalingFactor0;
-        if (index == 1) return _scalingFactor1;
-        if (index == 2) return _scalingFactor2;
-        if (index == 3) return _scalingFactor3;
-        if (index == 4) return _scalingFactor4;
-        if (index == 5) return _scalingFactor5;
-        else {
-            _revert(Errors.INVALID_TOKEN);
-        }
+    function _getRateProvider0() internal view returns (IRateProvider) {
+        return _rateProvider0;
+    }
+
+    function _getRateProvider1() internal view returns (IRateProvider) {
+        return _rateProvider1;
+    }
+
+    function _getRateProvider2() internal view returns (IRateProvider) {
+        return _rateProvider2;
+    }
+
+    function _getRateProvider3() internal view returns (IRateProvider) {
+        return _rateProvider3;
+    }
+
+    function _getRateProvider4() internal view returns (IRateProvider) {
+        return _rateProvider4;
+    }
+
+    function _getRateProvider5() internal view returns (IRateProvider) {
+        return _rateProvider5;
     }
 
     /**
      * @dev Returns the rate providers configured for each token (in the same order as registered).
      */
-    function getRateProviders() external view returns (IRateProvider[] memory) {
+    function getRateProviders() external view returns (IRateProvider[] memory providers) {
         uint256 totalTokens = _getTotalTokens();
-        IRateProvider[] memory providers = new IRateProvider[](totalTokens);
+        providers = new IRateProvider[](totalTokens);
 
-        for (uint256 i = 0; i < totalTokens; ++i) {
-            providers[i] = _getRateProvider(i);
-        }
+        // The Pool will always have at least 3 tokens so we always load these three rate providers.
+        providers[0] = _getRateProvider0();
+        providers[1] = _getRateProvider1();
+        providers[2] = _getRateProvider2();
+
+        // Before we load the remaining rate providers we must check that the Pool contains enough tokens.
+        if (totalTokens == 3) return providers;
+        providers[3] = _getRateProvider3();
+
+        if (totalTokens == 4) return providers;
+        providers[4] = _getRateProvider4();
 
-        return providers;
+        if (totalTokens == 5) return providers;
+        providers[5] = _getRateProvider5();
     }
 
     function _getRateProvider(uint256 index) internal view returns (IRateProvider) {
-        if (index == 0) return _rateProvider0;
-        if (index == 1) return _rateProvider1;
-        if (index == 2) return _rateProvider2;
-        if (index == 3) return _rateProvider3;
-        if (index == 4) return _rateProvider4;
-        if (index == 5) return _rateProvider5;
+        if (index == 0) return _getRateProvider0();
+        if (index == 1) return _getRateProvider1();
+        if (index == 2) return _getRateProvider2();
+        if (index == 3) return _getRateProvider3();
+        if (index == 4) return _getRateProvider4();
+        if (index == 5) return _getRateProvider5();
         else {
             _revert(Errors.INVALID_TOKEN);
         }
@@ -376,20 +422,29 @@
     /**
      * @dev Returns the number of tokens in circulation.
      *
-     * WARNING: in the vast majority of cases this is not a useful value, since it does not include the debt the Pool
-     * accrued in the form of unminted BPT for the ProtocolFeesCollector. Look into `getActualSupply()` and how that's
-     * different.
-     *
      * In other pools, this would be the same as `totalSupply`, but since this pool pre-mints BPT and holds it in the
      * Vault as a token, we need to subtract the Vault's balance to get the total "circulating supply". Both the
      * totalSupply and Vault balance can change. If users join or exit using swaps, some of the preminted BPT are
      * exchanged, so the Vault's balance increases after joins and decreases after exits. If users call the regular
      * joins/exit functions, the totalSupply can change as BPT are minted for joins or burned for exits.
      */
+    function getVirtualSupply() external view returns (uint256) {
+        // For a 3 token General Pool, it is cheaper to query the balance for a single token than to read all balances,
+        // as getPoolTokenInfo will check for token existence, token balance and Asset Manager (3 reads), while
+        // getPoolTokens will read the number of tokens, their addresses and balances (7 reads).
+        // The more tokens the Pool has, the more expensive `getPoolTokens` becomes, while `getPoolTokenInfo`'s gas
+        // remains constant.
+        (uint256 cash, uint256 managed, , ) = getVault().getPoolTokenInfo(getPoolId(), IERC20(this));
+
+        // Note that unlike all other balances, the Vault's BPT balance does not need scaling as its scaling factor is
+        // ONE. This addition cannot overflow due to the Vault's balance limits.
+        return _getVirtualSupply(cash + managed);
+    }
+
+    // The initial amount of BPT pre-minted is _PREMINTED_TOKEN_BALANCE, and it goes entirely to the pool balance in the
+    // vault. So the virtualSupply (the actual supply in circulation) is defined as:
+    // virtualSupply = totalSupply() - _balances[_bptIndex]
     function _getVirtualSupply(uint256 bptBalance) internal view returns (uint256) {
-        // The initial amount of BPT pre-minted is _PREMINTED_TOKEN_BALANCE, and it goes entirely to the pool balance in
-        // the vault. So the virtualSupply (the amount of BPT supply in circulation) is defined as:
-        // virtualSupply = totalSupply() - _balances[_bptIndex]
         return totalSupply().sub(bptBalance);
     }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/StableMath.sol pool-stable/contracts/StableMath.sol
--- pool-stable/contracts/StableMath.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/StableMath.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // These functions start with an underscore, as if they were part of a contract and not a library. At some point this
 // should be fixed. Additionally, some variables have non mixed case names (e.g. P_D) that relate to the mathematical
@@ -447,4 +447,15 @@
 
         _revert(Errors.STABLE_GET_BALANCE_DIDNT_CONVERGE);
     }
+
+    function _getRate(
+        uint256[] memory balances,
+        uint256 amp,
+        uint256 supply
+    ) internal pure returns (uint256) {
+        // When calculating the current BPT rate, we may not have paid the protocol fees, therefore
+        // the invariant should be smaller than its current value. Then, we round down overall.
+        uint256 invariant = _calculateInvariant(amp, balances);
+        return invariant.divDown(supply);
+    }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/StablePoolAmplification.sol pool-stable/contracts/StablePoolAmplification.sol
--- pool-stable/contracts/StablePoolAmplification.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/StablePoolAmplification.sol	2022-09-19 22:39:36.000000000 -0700
@@ -14,12 +14,12 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-pool-utils/contracts/BasePoolAuthorization.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../pool-utils/contracts/BasePoolAuthorization.sol";
+import "../../solidity-utils/contracts/helpers/WordCodec.sol";
 
-import "./StableMath.sol";
+import "../../../harnesses/StableMathHarness.sol";
 
-abstract contract StablePoolAmplification is BasePoolAuthorization {
+abstract contract StablePoolAmplification is BasePoolAuthorization, StableMath {
     using WordCodec for bytes32;
 
     // This contract uses timestamps to slowly update its Amplification parameter over time. These changes must occur
@@ -31,8 +31,8 @@
     // WARNING: this only limits *a single* amplification change to have a maximum rate of change of twice the original
     // value daily. It is possible to perform multiple amplification changes in sequence to increase this value more
     // rapidly: for example, by doubling the value every day it can increase by a factor of 8 over three days (2^3).
-    uint256 private constant _MIN_UPDATE_TIME = 1 days;
-    uint256 private constant _MAX_AMP_UPDATE_DAILY_RATE = 2;
+    uint256 public constant _MIN_UPDATE_TIME = 1 days; // HARNESS: Made both of these public
+    uint256 public constant _MAX_AMP_UPDATE_DAILY_RATE = 2;
 
     // The amplification data structure is as follows:
     // [  64 bits |   64 bits  |  64 bits  |   64 bits   ]
@@ -193,7 +193,6 @@
     function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {
         return
             (actionId == getActionId(this.startAmplificationParameterUpdate.selector)) ||
-            (actionId == getActionId(this.stopAmplificationParameterUpdate.selector)) ||
-            super._isOwnerOnlyAction(actionId);
+            (actionId == getActionId(this.stopAmplificationParameterUpdate.selector));
     }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/test/MockComposableStablePool.sol pool-stable/contracts/test/MockComposableStablePool.sol
--- pool-stable/contracts/test/MockComposableStablePool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/test/MockComposableStablePool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-pool-utils/contracts/test/MockFailureModes.sol";
+import "../../pool-utils/contracts/test/MockFailureModes.sol";
 
 import "../ComposableStablePool.sol";
 
@@ -28,10 +28,6 @@
         _cacheTokenRateIfNecessary(index);
     }
 
-    function isOwnerOnlyAction(bytes32 actionId) external view returns (bool) {
-        return _isOwnerOnlyAction(actionId);
-    }
-
     function _updateTokenRateCache(
         uint256 index,
         IRateProvider provider,
@@ -57,29 +53,4 @@
     ) internal virtual override whenNotInFailureMode(FailureMode.INVARIANT) returns (uint256 amountIn) {
         return super._onSwapGivenOut(request, balancesIncludingBpt, indexIn, indexOut);
     }
-
-    function beforeJoinExit(uint256[] memory registeredBalances)
-        external
-        returns (
-            uint256 preJoinExitSupply,
-            uint256[] memory balances,
-            uint256 currentAmp,
-            uint256 preJoinExitInvariant
-        )
-    {
-        return _beforeJoinExit(registeredBalances);
-    }
-
-    function getVirtualSupply() external view returns (uint256) {
-        // For a 3 token General Pool, it is cheaper to query the balance for a single token than to read all balances,
-        // as getPoolTokenInfo will check for token existence, token balance and Asset Manager (3 reads), while
-        // getPoolTokens will read the number of tokens, their addresses and balances (7 reads).
-        // The more tokens the Pool has, the more expensive `getPoolTokens` becomes, while `getPoolTokenInfo`'s gas
-        // remains constant.
-        (uint256 cash, uint256 managed, , ) = getVault().getPoolTokenInfo(getPoolId(), IERC20(this));
-
-        // Note that unlike all other balances, the Vault's BPT balance does not need scaling as its scaling factor is
-        // ONE. This addition cannot overflow due to the Vault's balance limits.
-        return _getVirtualSupply(cash + managed);
-    }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/test/MockComposableStablePoolProtocolFees.sol pool-stable/contracts/test/MockComposableStablePoolProtocolFees.sol
--- pool-stable/contracts/test/MockComposableStablePoolProtocolFees.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/test/MockComposableStablePoolProtocolFees.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
 
 import "../ComposableStablePoolProtocolFees.sol";
 
@@ -59,21 +59,16 @@
         // solhint-disable-previous-line no-empty-blocks
     }
 
-    function payProtocolFeesBeforeJoinExit(
-        uint256[] memory registeredBalances,
-        uint256 lastJoinExitAmp,
-        uint256 lastPostJoinExitInvariant
-    ) external returns (uint256 virtualSupply, uint256[] memory balances) {
-        (virtualSupply, balances, ) = _payProtocolFeesBeforeJoinExit(
-            registeredBalances,
-            lastJoinExitAmp,
-            lastPostJoinExitInvariant
-        );
+    function payProtocolFeesBeforeJoinExit(uint256[] memory balancesWithBpt)
+        external
+        returns (uint256 virtualSupply, uint256[] memory balances)
+    {
+        return _payProtocolFeesBeforeJoinExit(balancesWithBpt);
     }
 
     function updateInvariantAfterJoinExit(
         uint256 currentAmp,
-        uint256[] memory balances,
+        uint256[] memory balancesWithoutBpt,
         uint256 preJoinExitInvariant,
         uint256 preJoinExitSupply,
         uint256 postJoinExitSupply
@@ -81,7 +76,7 @@
         return
             _updateInvariantAfterJoinExit(
                 currentAmp,
-                balances,
+                balancesWithoutBpt,
                 preJoinExitInvariant,
                 preJoinExitSupply,
                 postJoinExitSupply
@@ -108,17 +103,8 @@
         return _getGrowthInvariants(balances, lastPostJoinExitAmp);
     }
 
-    function getProtocolPoolOwnershipPercentage(
-        uint256[] memory balances,
-        uint256 lastJoinExitAmp,
-        uint256 lastPostJoinExitInvariant
-    ) external view returns (uint256) {
-        (uint256 percentage, ) = _getProtocolPoolOwnershipPercentage(
-            balances,
-            lastJoinExitAmp,
-            lastPostJoinExitInvariant
-        );
-        return percentage;
+    function getProtocolPoolOwnershipPercentage(uint256[] memory balances) external view returns (uint256) {
+        return _getProtocolPoolOwnershipPercentage(balances);
     }
 
     // Stubbed functions
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/test/MockComposableStablePoolRates.sol pool-stable/contracts/test/MockComposableStablePoolRates.sol
--- pool-stable/contracts/test/MockComposableStablePoolRates.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/test/MockComposableStablePoolRates.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
 
 import "../ComposableStablePoolRates.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/test/MockComposableStablePoolStorage.sol pool-stable/contracts/test/MockComposableStablePoolStorage.sol
--- pool-stable/contracts/test/MockComposableStablePoolStorage.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/test/MockComposableStablePoolStorage.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
 
 import "../ComposableStablePoolStorage.sol";
 
@@ -70,51 +70,51 @@
     }
 
     function getRateProvider0() external view returns (IRateProvider) {
-        return _rateProvider0;
+        return _getRateProvider0();
     }
 
     function getRateProvider1() external view returns (IRateProvider) {
-        return _rateProvider1;
+        return _getRateProvider1();
     }
 
     function getRateProvider2() external view returns (IRateProvider) {
-        return _rateProvider2;
+        return _getRateProvider2();
     }
 
     function getRateProvider3() external view returns (IRateProvider) {
-        return _rateProvider3;
+        return _getRateProvider3();
     }
 
     function getRateProvider4() external view returns (IRateProvider) {
-        return _rateProvider4;
+        return _getRateProvider4();
     }
 
     function getRateProvider5() external view returns (IRateProvider) {
-        return _rateProvider5;
+        return _getRateProvider5();
     }
 
     function getScalingFactor0() external view returns (uint256) {
-        return _scalingFactor0;
+        return _getScalingFactor0();
     }
 
     function getScalingFactor1() external view returns (uint256) {
-        return _scalingFactor1;
+        return _getScalingFactor1();
     }
 
     function getScalingFactor2() external view returns (uint256) {
-        return _scalingFactor2;
+        return _getScalingFactor2();
     }
 
     function getScalingFactor3() external view returns (uint256) {
-        return _scalingFactor3;
+        return _getScalingFactor3();
     }
 
     function getScalingFactor4() external view returns (uint256) {
-        return _scalingFactor4;
+        return _getScalingFactor4();
     }
 
     function getScalingFactor5() external view returns (uint256) {
-        return _scalingFactor5;
+        return _getScalingFactor5();
     }
 
     function getRateProvider(uint256 index) external view returns (IRateProvider) {
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/test/MockStableMath.sol pool-stable/contracts/test/MockStableMath.sol
--- pool-stable/contracts/test/MockStableMath.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/test/MockStableMath.sol	2022-09-16 02:18:01.000000000 -0700
@@ -151,4 +151,12 @@
                 tokenIndex
             );
     }
+
+    function getRate(
+        uint256[] memory balances,
+        uint256 amp,
+        uint256 supply
+    ) external pure returns (uint256) {
+        return StableMath._getRate(balances, amp, supply);
+    }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/contracts/test/MockStablePoolAmplification.sol pool-stable/contracts/test/MockStablePoolAmplification.sol
--- pool-stable/contracts/test/MockStablePoolAmplification.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/contracts/test/MockStablePoolAmplification.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "../StablePoolAmplification.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/test/ComposableStablePool.test.ts pool-stable/test/ComposableStablePool.test.ts
--- pool-stable/test/ComposableStablePool.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/test/ComposableStablePool.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -3,22 +3,11 @@
 import { BigNumber, Contract } from 'ethers';
 import { random, range } from 'lodash';
 
-import { deploy, deployedAt, getArtifact } from '@balancer-labs/v2-helpers/src/contract';
+import { deploy, deployedAt } from '@balancer-labs/v2-helpers/src/contract';
 import { sharedBeforeEach } from '@balancer-labs/v2-common/sharedBeforeEach';
 import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signer-with-address';
 import { PoolSpecialization, SwapKind } from '@balancer-labs/balancer-js';
-
-import {
-  BigNumberish,
-  bn,
-  fp,
-  pct,
-  arrayAdd,
-  bnSum,
-  arrayFpMul,
-  fpDiv,
-  fpMul,
-} from '@balancer-labs/v2-helpers/src/numbers';
+import { BigNumberish, bn, fp, pct, FP_SCALING_FACTOR, arrayAdd, bnSum } from '@balancer-labs/v2-helpers/src/numbers';
 import { MAX_UINT112, ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
 import { RawStablePoolDeployment } from '@balancer-labs/v2-helpers/src/models/pools/stable/types';
 import { currentTimestamp, advanceTime, MONTH, WEEK, DAY } from '@balancer-labs/v2-helpers/src/time';
@@ -26,9 +15,6 @@
 import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
 import StablePool from '@balancer-labs/v2-helpers/src/models/pools/stable/StablePool';
 import { calculateInvariant } from '@balancer-labs/v2-helpers/src/models/pools/stable/math';
-import { actionId } from '@balancer-labs/v2-helpers/src/models/misc/actions';
-import { ProtocolFee } from '@balancer-labs/v2-helpers/src/models/vault/types';
-import * as expectEvent from '@balancer-labs/v2-helpers/src/test/expectEvent';
 
 describe('ComposableStablePool', () => {
   let lp: SignerWithAddress,
@@ -347,12 +333,11 @@
 
               const deltaSum = bnSum(deltas);
               const currSum = bnSum(registeredBalancesWithFees.filter((_, i) => i != bptIndex));
-              const poolPercentageDueToDeltas = fpDiv(deltaSum, currSum);
+              const poolPercentageDueToDeltas = deltaSum.mul(FP_SCALING_FACTOR).div(currSum);
 
-              const expectedProtocolOwnershipPercentage = fpMul(
-                poolPercentageDueToDeltas,
-                PROTOCOL_SWAP_FEE_PERCENTAGE
-              );
+              const expectedProtocolOwnershipPercentage = poolPercentageDueToDeltas
+                .mul(PROTOCOL_SWAP_FEE_PERCENTAGE)
+                .div(FP_SCALING_FACTOR);
 
               // protocol ownership = to mint / (supply + to mint)
               // to mint = supply * protocol ownership / (1 - protocol ownership)
@@ -1536,11 +1521,11 @@
         await deployPool({ swapFeePercentage });
         await pool.vault.setSwapFeePercentage(protocolFeePercentage);
 
+        await pool.updateProtocolFeePercentageCache();
+
         // Init pool with equal balances so that each BPT accounts for approximately one underlying token.
         equalBalances = Array.from({ length: numberOfTokens + 1 }).map((_, i) => (i == bptIndex ? bn(0) : fp(100)));
         await pool.init({ recipient: lp.address, initialBalances: equalBalances });
-
-        await pool.updateProtocolFeePercentageCache();
       });
 
       context('without protocol fees', () => {
@@ -1554,39 +1539,30 @@
       });
     });
 
-    describe('getRate and protocol fees', () => {
+    describe('getRate', () => {
       const swapFeePercentage = fp(0.1); // 10 %
       const protocolFeePercentage = fp(0.5); // 50 %
 
-      sharedBeforeEach('deploy  pool', async () => {
+      sharedBeforeEach('deploy pool', async () => {
         await deployPool({ swapFeePercentage });
+        await pool.vault.setSwapFeePercentage(protocolFeePercentage);
+
+        await pool.updateProtocolFeePercentageCache();
       });
 
       context('before initialized', () => {
-        it('rate is undefined', async () => {
+        it('rate is zero', async () => {
           await expect(pool.getRate()).to.be.revertedWith('ZERO_DIVISION');
         });
       });
 
       context('once initialized', () => {
-        const initialBalance = fp(100);
-
         sharedBeforeEach('initialize pool', async () => {
           // Init pool with equal balances so that each BPT accounts for approximately one underlying token.
           const equalBalances = Array.from({ length: numberOfTokens + 1 }).map((_, i) =>
-            i == bptIndex ? bn(0) : initialBalance
+            i == bptIndex ? bn(0) : fp(100)
           );
           await pool.init({ recipient: lp.address, initialBalances: equalBalances });
-
-          await tokens.mint({ to: lp, amount: initialBalance.mul(100) });
-          await tokens.approve({ from: lp, to: pool.vault });
-        });
-
-        sharedBeforeEach('set fees', async () => {
-          await pool.vault.setFeeTypePercentage(ProtocolFee.SWAP, protocolFeePercentage);
-          await pool.vault.setFeeTypePercentage(ProtocolFee.YIELD, protocolFeePercentage);
-
-          await pool.updateProtocolFeePercentageCache();
         });
 
         context('without protocol fees', () => {
@@ -1594,235 +1570,35 @@
             const virtualSupply = await pool.getVirtualSupply();
             const invariant = await pool.estimateInvariant();
 
-            const expectedRate = fpDiv(invariant, virtualSupply);
+            const expectedRate = invariant.mul(FP_SCALING_FACTOR).div(virtualSupply);
 
             const rate = await pool.getRate();
 
-            expect(rate).to.be.almostEqual(expectedRate, 0.0001);
+            expect(rate).to.be.equalWithError(expectedRate, 0.0001);
           });
         });
 
         context('with protocol fees', () => {
-          let feeAmount: BigNumber; // The number of tokens in the Pool that are fees
-
-          function itReportsRateCorrectly() {
-            let unmintedBPT: BigNumber;
-
-            sharedBeforeEach('compute protocol ownership', async () => {
-              const balanceSum = initialBalance.mul(numberOfTokens).add(feeAmount);
-              const feePercentage = fpDiv(feeAmount, balanceSum);
-              const protocolOwnership = fpMul(feePercentage, protocolFeePercentage);
-
-              // The virtual supply does not include the unminted protocol fees. We need to adjust it by computing those.
-              // Since all balances are relatively close and the pool is balanced, we can simply add the fee amount
-              // to the current balances to obtain the final sum.
-              const virtualSupply = await pool.getVirtualSupply();
-
-              // The unminted BPT is supply * protocolOwnership / (1 - protocolOwnership)
-              unmintedBPT = virtualSupply.mul(protocolOwnership).div(fp(1).sub(protocolOwnership));
-            });
-
-            it('the actual supply takes into account unminted protocol fees', async () => {
-              const virtualSupply = await pool.getVirtualSupply();
-              const expectedActualSupply = virtualSupply.add(unmintedBPT);
-
-              expect(await pool.getActualSupply()).to.almostEqual(expectedActualSupply, 1e-6);
-            });
-
-            it('rate takes into account unminted protocol fees', async () => {
-              const scaledBalances = arrayFpMul(await pool.getBalances(), await pool.getScalingFactors()).filter(
-                (_, i) => i != bptIndex
-              );
-              const invariant = calculateInvariant(
-                scaledBalances,
-                (await pool.getAmplificationParameter()).value.div(1000)
-              );
-
-              // The virtual supply does not include the unminted protocol fees. We need to adjust it by computing those.
-              // Since all balances are relatively close and the pool is balanced, we can simply add the fee amount
-              // to the current balances to obtain the final sum.
-              const virtualSupply = await pool.getVirtualSupply();
-
-              const actualSupply = virtualSupply.add(unmintedBPT);
-
-              const rateAssumingNoProtocolFees = fpDiv(invariant, virtualSupply);
-              const rateConsideringProtocolFees = fpDiv(invariant, actualSupply);
-
-              // The rate considering fees should be lower. Check that we have a difference of at least 0.01% to discard
-              // rounding error.
-              expect(rateConsideringProtocolFees).to.be.lt(rateAssumingNoProtocolFees.mul(9999).div(10000));
-
-              expect(await pool.getRate()).to.be.almostEqual(rateConsideringProtocolFees, 1e-6);
-            });
-
-            async function expectNoRateChange(action: () => Promise<void>): Promise<void> {
-              const rateBeforeAction = await pool.getRate();
-
-              await action();
-
-              const rateAfterAction = await pool.getRate();
-
-              // There's some minute diference due to rounding error
-              const rateDelta = rateAfterAction.sub(rateBeforeAction);
-              expect(rateDelta.abs()).to.be.lte(2);
-            }
-
-            it('rate does not change due to proportional joins', async () => {
-              await expectNoRateChange(async () => {
-                // Perform a proportional join. These have no swap fees, which means that the rate should remain the same
-                // (even though this triggers a due protocol fee payout).
-
-                // Note that we join with proportional *unscaled* balances - otherwise we'd need to take their different
-                // scaling factors into account.
-                const { balances: unscaledBalances } = await pool.getTokens();
-                const amountsIn = unscaledBalances.map((balance, i) => (i == bptIndex ? bn(0) : balance.div(100)));
-                await pool.joinGivenIn({ from: lp, amountsIn });
-              });
-            });
-
-            it('rate does not change due to proportional exits', async () => {
-              await expectNoRateChange(async () => {
-                // Perform a proportional exit. These have no swap fees, which means that the rate should remain the same
-                // (even though this triggers a due protocol fee payout).
-
-                // Note that we exit with proportional *unscaled* balances - otherwise we'd need to take their different
-                // scaling factors into account.
-                const { balances: unscaledBalances } = await pool.getTokens();
-                const amountsOut = unscaledBalances.map((balance, i) => (i == bptIndex ? bn(0) : balance.div(100)));
-                await pool.exitGivenOut({ from: lp, amountsOut });
-              });
-            });
-
-            it('rate increases when enabling recovery mode', async () => {
-              const initialRate = await pool.getRate();
-
-              // When enabling recovery mode, protocol fees are forfeit and the percentages drop to zero. This causes
-              // an increase in the rate, since the BPT's value increases (as it no longer carries any protocol debt).
-              await pool.enableRecoveryMode(admin);
-              const newRate = await pool.getRate();
-
-              expect(newRate).to.be.gt(initialRate);
-
-              // We can compute the new rate by computing the ratio of invariant and total supply, not considering any
-              // due protocol fees (because there should be none).
-              const scaledBalances = arrayFpMul(await pool.getBalances(), await pool.getScalingFactors()).filter(
-                (_, i) => i != bptIndex
-              );
-              const invariant = calculateInvariant(
-                scaledBalances,
-                (await pool.getAmplificationParameter()).value.div(AMP_PRECISION)
-              );
-
-              const virtualSupply = await pool.getVirtualSupply();
+          sharedBeforeEach('swap bpt in', async () => {
+            const amount = fp(50);
+            const tokenIn = pool.bpt;
+            const tokenOut = tokens.second;
 
-              const rateAssumingNoProtocolFees = fpDiv(invariant, virtualSupply);
-
-              expect(newRate).to.be.almostEqual(rateAssumingNoProtocolFees, 1e-6);
-            });
-
-            it('rate does not change when disabling recovery mode', async () => {
-              await pool.enableRecoveryMode(admin);
-
-              await expectNoRateChange(async () => {
-                // Disabling recovery mode should cause no rate changes - fees have already been forfeit when recovery
-                // mode was enabled.
-                await pool.disableRecoveryMode(admin);
-              });
-            });
-
-            function itReactsToProtocolFeePercentageChangesCorrectly(feeType: number) {
-              it('rate does not change on protocol fee update', async () => {
-                await expectNoRateChange(async () => {
-                  // Changing the fee on the providere should cause no changes as the Pool ignores the provider outside
-                  // of cache updates.
-                  await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(2));
-                });
-              });
-
-              it('rate does not change on protocol fee cache update', async () => {
-                await expectNoRateChange(async () => {
-                  // Even though there's due protocol fees, which are a function of the protocol fee percentage, changing
-                  // this value should not change the Pool's rate (to avoid manipulation).
-                  await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(2));
-                  await pool.updateProtocolFeePercentageCache();
-                });
-              });
-
-              it('due protocol fees are minted on protocol fee cache update', async () => {
-                await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(2));
-                const receipt = await (await pool.updateProtocolFeePercentageCache()).wait();
-
-                const event = expectEvent.inReceipt(receipt, 'Transfer', {
-                  from: ZERO_ADDRESS,
-                  to: (await pool.vault.getFeesCollector()).address,
-                });
-
-                expect(event.args.value).to.be.almostEqual(unmintedBPT, 1e-3);
-              });
-
-              it('repeated protocol fee cache updates do not mint any more fees', async () => {
-                await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(2));
-                await pool.updateProtocolFeePercentageCache();
-
-                await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(4));
-                const receipt = await (await pool.updateProtocolFeePercentageCache()).wait();
-
-                expectEvent.notEmitted(receipt, 'Transfer');
-              });
-
-              context('when paused', () => {
-                sharedBeforeEach('pause pool', async () => {
-                  await pool.pause();
-                });
-
-                it('reverts on protocol fee cache updated', async () => {
-                  await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(2));
-                  await expect(pool.updateProtocolFeePercentageCache()).to.be.revertedWith('PAUSED');
-                });
-              });
-            }
-
-            context('on swap protocol fee change', () => {
-              itReactsToProtocolFeePercentageChangesCorrectly(ProtocolFee.SWAP);
-            });
-
-            context('on yield protocol fee change', () => {
-              itReactsToProtocolFeePercentageChangesCorrectly(ProtocolFee.YIELD);
-            });
-
-            context('on aum protocol fee change', () => {
-              itReactsToProtocolFeePercentageChangesCorrectly(ProtocolFee.AUM);
-            });
-          }
-
-          context('with swap protocol fees', () => {
-            sharedBeforeEach('accrue fees due to a swap', async () => {
-              const amount = initialBalance.div(20);
-              feeAmount = fpMul(amount, swapFeePercentage);
-
-              const tokenIn = tokens.first;
-              const tokenOut = tokens.second;
-              await pool.swapGivenIn({ in: tokenIn, out: tokenOut, amount, from: lp, recipient: lp });
-            });
+            await tokens.mint({ to: lp, amount });
+            await tokens.approve({ from: lp, to: pool.vault });
 
-            itReportsRateCorrectly();
+            await pool.swapGivenIn({ in: tokenIn, out: tokenOut, amount, from: lp, recipient });
           });
 
-          context('with yield protocol fees', () => {
-            sharedBeforeEach('accrue fees due to yield', async () => {
-              // Even tokens are exempt from yield fee, so we cause some on an odd one.
-              const rateProvider = rateProviders[1];
-              const currentRate = await rateProvider.getRate();
+          it('reports correctly', async () => {
+            const virtualSupply = await pool.getVirtualSupply();
+            const invariant = await pool.estimateInvariant();
 
-              // Cause a 0.5% (1/200) rate increase
-              const newRate = fpMul(currentRate, fp(1.005));
-              await rateProvider.mockRate(newRate);
-              await pool.updateTokenRateCache(tokens.second);
+            const expectedRate = invariant.mul(FP_SCALING_FACTOR).div(virtualSupply);
 
-              feeAmount = fpMul(initialBalance, newRate.sub(currentRate));
-            });
+            const rate = await pool.getRate();
 
-            itReportsRateCorrectly();
+            expect(rate).to.be.equalWithError(expectedRate, 0.0001);
           });
         });
       });
@@ -1971,53 +1747,5 @@
         });
       });
     });
-
-    describe('permissioned actions', () => {
-      sharedBeforeEach('deploy pool', async () => {
-        await deployPool();
-      });
-
-      function itIsOwnerOnly(method: string) {
-        it(`${method} can only be called by non-delegated owners`, async () => {
-          expect(await pool.instance.isOwnerOnlyAction(await actionId(pool.instance, method))).to.be.true;
-        });
-      }
-
-      function itIsNotOwnerOnly(method: string) {
-        it(`${method} can never be called by the owner`, async () => {
-          expect(await pool.instance.isOwnerOnlyAction(await actionId(pool.instance, method))).to.be.false;
-        });
-      }
-
-      const poolArtifact = getArtifact('v2-pool-stable/MockComposableStablePool');
-      const nonViewFunctions = poolArtifact.abi
-        .filter(
-          (elem) =>
-            elem.type === 'function' && (elem.stateMutability === 'payable' || elem.stateMutability === 'nonpayable')
-        )
-        .map((fn) => fn.name);
-
-      const expectedOwnerOnlyFunctions = [
-        'setSwapFeePercentage',
-        'setAssetManagerPoolConfig',
-        'startAmplificationParameterUpdate',
-        'stopAmplificationParameterUpdate',
-        'setTokenRateCacheDuration',
-      ];
-
-      const expectedNotOwnerOnlyFunctions = nonViewFunctions.filter((fn) => !expectedOwnerOnlyFunctions.includes(fn));
-
-      describe('owner only actions', () => {
-        for (const expectedOwnerOnlyFunction of expectedOwnerOnlyFunctions) {
-          itIsOwnerOnly(expectedOwnerOnlyFunction);
-        }
-      });
-
-      describe('non owner only actions', () => {
-        for (const expectedNotOwnerOnlyFunction of expectedNotOwnerOnlyFunctions) {
-          itIsNotOwnerOnly(expectedNotOwnerOnlyFunction);
-        }
-      });
-    });
   }
 });
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/test/ComposableStablePoolIntegration.test.ts pool-stable/test/ComposableStablePoolIntegration.test.ts
--- pool-stable/test/ComposableStablePoolIntegration.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/test/ComposableStablePoolIntegration.test.ts	1969-12-31 16:00:00.000000000 -0800
@@ -1,182 +0,0 @@
-import { expect } from 'chai';
-import { ethers } from 'hardhat';
-import { BigNumber, Contract } from 'ethers';
-import { deploy } from '@balancer-labs/v2-helpers/src/contract';
-import { sharedBeforeEach } from '@balancer-labs/v2-common/sharedBeforeEach';
-import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signer-with-address';
-import { BigNumberish, bn, fp } from '@balancer-labs/v2-helpers/src/numbers';
-import { RawStablePoolDeployment } from '@balancer-labs/v2-helpers/src/models/pools/stable/types';
-import { MONTH } from '@balancer-labs/v2-helpers/src/time';
-import Token from '@balancer-labs/v2-helpers/src/models/tokens/Token';
-import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
-import StablePool from '@balancer-labs/v2-helpers/src/models/pools/stable/StablePool';
-
-describe('ComposableStablePoolIntegration', () => {
-  let lp: SignerWithAddress, owner: SignerWithAddress, admin: SignerWithAddress, other: SignerWithAddress;
-
-  sharedBeforeEach('setup signers', async () => {
-    [, lp, owner, admin, other] = await ethers.getSigners();
-  });
-
-  context('for a 2 token pool', () => {
-    itPerformsIntegrationTests(2);
-  });
-
-  context('for a 3 token pool', () => {
-    itPerformsIntegrationTests(3);
-  });
-
-  context('for a 4 token pool', () => {
-    itPerformsIntegrationTests(4);
-  });
-
-  context('for a 5 token pool', () => {
-    itPerformsIntegrationTests(5);
-  });
-
-  function itPerformsIntegrationTests(totalTokens: number) {
-    let pool: StablePool, tokens: TokenList;
-    let bptIndex: number;
-
-    const rateProviders: Contract[] = [];
-    const tokenRateCacheDurations: number[] = [];
-    const exemptFromYieldProtocolFeeFlags: boolean[] = [];
-    const swapFeePercentage = fp(0.1); // 10 %
-    const protocolFeePercentage = fp(0.5); // 50 %
-
-    async function deployPool(
-      numberOfTokens: number,
-      params: RawStablePoolDeployment = {},
-      rates: BigNumberish[] = [],
-      durations: number[] = []
-    ): Promise<void> {
-      tokens = params.tokens || (await TokenList.create(numberOfTokens, { sorted: true }));
-
-      for (let i = 0; i < numberOfTokens; i++) {
-        rateProviders[i] = await deploy('v2-pool-utils/MockRateProvider');
-        await rateProviders[i].mockRate(rates[i] || fp(1));
-        tokenRateCacheDurations[i] = MONTH + i;
-        exemptFromYieldProtocolFeeFlags[i] = i % 2 == 0; // set true for even tokens
-      }
-
-      pool = await StablePool.create({
-        tokens,
-        rateProviders,
-        tokenRateCacheDurations: durations.length > 0 ? durations : tokenRateCacheDurations,
-        exemptFromYieldProtocolFeeFlags,
-        owner,
-        admin,
-        ...params,
-      });
-
-      bptIndex = await pool.getBptIndex();
-    }
-
-    describe('protocol fee minting vs value extraction', () => {
-      let equalBalances: BigNumber[];
-      let poolNested: StablePool;
-      let otherToken: Token;
-
-      sharedBeforeEach('deploy primary pool', async () => {
-        await deployPool(totalTokens, { swapFeePercentage });
-        await pool.vault.setSwapFeePercentage(protocolFeePercentage);
-
-        // Init pool with equal balances so that each BPT accounts for approximately one underlying token.
-        equalBalances = Array.from({ length: totalTokens + 1 }).map((_, i) => (i == bptIndex ? bn(0) : fp(100)));
-        await pool.init({ recipient: lp.address, initialBalances: equalBalances });
-
-        await pool.updateProtocolFeePercentageCache();
-      });
-
-      sharedBeforeEach('deploy nested pool', async () => {
-        otherToken = await Token.create({ symbol: 'OTHER-TOKEN' });
-        const tokensNested = new TokenList([pool.bpt, otherToken]).sort();
-        const rateProvider: Contract = await deploy('v2-pool-utils/MockRateProvider');
-
-        poolNested = await StablePool.create({
-          tokens: tokensNested,
-          rateProviders: tokensNested.map((token) => (token.address === pool.bpt.address ? pool : rateProvider)),
-          tokenRateCacheDurations: [0, 0],
-          exemptFromYieldProtocolFeeFlags: [false, false],
-          owner,
-          admin,
-          swapFeePercentage: fp(0.00001),
-          vault: pool.vault,
-        });
-
-        await tokens.mint({ to: [lp, other], amount: fp(10000) });
-        await otherToken.mint(lp, fp(10000));
-        await otherToken.mint(other, fp(10000));
-
-        const bptIdx = await poolNested.getBptIndex();
-        const { tokens: allTokens } = await poolNested.getTokens();
-
-        const bptBalance = await pool.balanceOf(lp);
-        const initialBalances = allTokens.map((token, i) =>
-          i == bptIdx ? bn(0) : token == pool.bpt.address ? bptBalance.div(2) : fp(10)
-        );
-
-        await tokens.approve({ from: [lp, other], to: pool.vault });
-        await tokensNested.approve({ from: [lp, other], to: pool.vault });
-        await pool.instance.connect(lp).approve(pool.vault.address, bptBalance);
-
-        await poolNested.init({ from: lp, recipient: lp.address, initialBalances, skipMint: true });
-      });
-
-      it('a balanced downstream join should not impact swap amount out on the parent pool', async () => {
-        // Accrue protocol fees in the downstream pool
-        await pool.swapGivenIn({
-          in: tokens.tokens[0],
-          out: tokens.tokens[1],
-          amount: fp(50),
-          from: lp,
-          recipient: lp,
-        });
-
-        await pool.swapGivenIn({
-          in: tokens.tokens[1],
-          out: tokens.tokens[0],
-          amount: fp(50),
-          from: lp,
-          recipient: lp,
-        });
-
-        // Swap in the nested pool
-        const firstSwap = await poolNested.swapGivenIn({
-          in: pool.bpt,
-          out: otherToken,
-          amount: fp(1),
-          from: lp,
-          recipient: lp,
-        });
-
-        // Query the reverse swap in the nested pool
-        const secondSwapQuery = await poolNested.querySwapGivenIn({
-          in: otherToken,
-          out: pool.bpt,
-          amount: firstSwap.amountOut,
-          from: lp,
-          recipient: lp,
-        });
-
-        // Join the downstream pool proportionally, triggering minting protocol fee BPT, but otherwise not accruing any
-        // further fees (and therefore not changing the value of the BPT).
-        const { balances: unscaledBalances } = await pool.getTokens();
-        const amountsIn = unscaledBalances.map((balance, i) => (i == bptIndex ? bn(0) : balance.div(100)));
-        await pool.joinGivenIn({ from: other, amountsIn });
-
-        // Perform the queried reverse swap in the nested pool
-        const secondSwap = await poolNested.swapGivenIn({
-          in: otherToken,
-          out: pool.bpt,
-          amount: firstSwap.amountOut,
-          from: lp,
-          recipient: lp,
-        });
-
-        // The query should match the swap, since the value of the underlying BPT did not change
-        expect(secondSwapQuery).to.be.almostEqual(secondSwap.amountOut, 1e-12);
-      });
-    });
-  }
-});
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/test/ComposableStablePoolProtocolFees.test.ts pool-stable/test/ComposableStablePoolProtocolFees.test.ts
--- pool-stable/test/ComposableStablePoolProtocolFees.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/test/ComposableStablePoolProtocolFees.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -8,14 +8,13 @@
 import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signer-with-address';
 import {
   arrayAdd,
+  arrayFpMul,
   BigNumberish,
   bn,
   bnSum,
   fp,
+  FP_SCALING_FACTOR,
   arraySub,
-  arrayFpMul,
-  fpMul,
-  fpDiv,
 } from '@balancer-labs/v2-helpers/src/numbers';
 
 import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
@@ -356,7 +355,7 @@
         preInvariant = await math.invariant(AMPLIFICATION_FACTOR, preBalances);
 
         // The virtual supply is some factor of the invariant
-        preVirtualSupply = fpMul(preInvariant, fp(random(1.5, 10)));
+        preVirtualSupply = preInvariant.mul(fp(random(1.5, 10))).div(FP_SCALING_FACTOR);
 
         // We don't use the stored amplification factor and invariant as the lastJoinExit values in tests as we pass
         // them in. However this function also sets the old token rates which we *do* use.
@@ -443,9 +442,9 @@
 
               const deltaSum = bnSum(deltas);
               const currSum = bnSum(currentBalances);
-              const poolPercentageDueToDeltas = fpDiv(deltaSum, currSum);
+              const poolPercentageDueToDeltas = deltaSum.mul(FP_SCALING_FACTOR).div(currSum);
 
-              expectedProtocolOwnershipPercentage = fpMul(poolPercentageDueToDeltas, swapFee);
+              expectedProtocolOwnershipPercentage = poolPercentageDueToDeltas.mul(swapFee).div(FP_SCALING_FACTOR);
             });
           }
 
@@ -466,14 +465,16 @@
 
               const deltaSum = bnSum(
                 preBalances.map((balance, i) =>
-                  exemptFromYieldProtocolFeeFlags[i] ? 0 : fpMul(balance, rates[i].sub(fp(1)))
+                  exemptFromYieldProtocolFeeFlags[i]
+                    ? 0
+                    : balance.mul(rates[i].sub(FP_SCALING_FACTOR)).div(FP_SCALING_FACTOR)
                 )
               );
 
               const currSum = bnSum(currentBalances);
-              const poolPercentageDueToDeltas = fpDiv(deltaSum, currSum);
+              const poolPercentageDueToDeltas = deltaSum.mul(FP_SCALING_FACTOR).div(currSum);
 
-              expectedProtocolOwnershipPercentage = fpMul(poolPercentageDueToDeltas, yieldFee);
+              expectedProtocolOwnershipPercentage = poolPercentageDueToDeltas.mul(yieldFee).div(FP_SCALING_FACTOR);
             });
           }
 
@@ -502,17 +503,18 @@
               const swapFeeDeltaSum = bnSum(swapFeeDeltas);
               const yieldDeltaSum = bnSum(
                 preBalances.map((balance, i) =>
-                  exemptFromYieldProtocolFeeFlags[i] ? 0 : fpMul(balance, rates[i].sub(fp(1)))
+                  exemptFromYieldProtocolFeeFlags[i] ? 0 : balance.mul(rates[i].sub(fp(1))).div(FP_SCALING_FACTOR)
                 )
               );
               const currSum = bnSum(currentBalances);
 
-              const poolPercentageDueToSwapFeeDeltas = fpDiv(swapFeeDeltaSum, currSum);
-              const poolPercentageDueToYieldDeltas = fpDiv(yieldDeltaSum, currSum);
+              const poolPercentageDueToSwapFeeDeltas = swapFeeDeltaSum.mul(FP_SCALING_FACTOR).div(currSum);
+              const poolPercentageDueToYieldDeltas = yieldDeltaSum.mul(FP_SCALING_FACTOR).div(currSum);
 
-              expectedProtocolOwnershipPercentage = fpMul(poolPercentageDueToSwapFeeDeltas, swapFee).add(
-                fpMul(poolPercentageDueToYieldDeltas, yieldFee)
-              );
+              expectedProtocolOwnershipPercentage = poolPercentageDueToSwapFeeDeltas
+                .mul(swapFee)
+                .div(FP_SCALING_FACTOR)
+                .add(poolPercentageDueToYieldDeltas.mul(yieldFee).div(FP_SCALING_FACTOR));
             });
           }
 
@@ -698,15 +700,15 @@
               const ratio = fp(random(0.1, 0.9));
 
               // Generate amounts for a proportional join/exit
-              const amounts = preBalances.map((balance) => fpMul(balance, ratio));
+              const amounts = preBalances.map((balance) => balance.mul(ratio).div(fp(1)));
 
               // Compute the balances, and increase/decrease the virtual supply proportionally
               if (op == Operation.JOIN) {
                 currentBalances = arrayAdd(preBalances, amounts);
-                currentVirtualSupply = fpMul(preVirtualSupply, fp(1).add(ratio));
+                currentVirtualSupply = preVirtualSupply.mul(fp(1).add(ratio)).div(fp(1));
               } else {
                 currentBalances = arraySub(preBalances, amounts);
-                currentVirtualSupply = fpMul(preVirtualSupply, fp(1).sub(ratio));
+                currentVirtualSupply = preVirtualSupply.mul(fp(1).sub(ratio)).div(fp(1));
               }
             });
           }
@@ -716,21 +718,21 @@
               const ratio = fp(random(0.1, 0.9));
 
               // Generate amounts for a proportional join/exit
-              const proportionalAmounts = preBalances.map((balance) => fpMul(balance, ratio));
+              const proportionalAmounts = preBalances.map((balance) => balance.mul(ratio).div(fp(1)));
 
               // Compute deltas that are going to modify the proportional amounts. These will be swap fees.
-              const deltas = proportionalAmounts.map((amount) => fpMul(amount, fp(random(0.05, 0.1))));
+              const deltas = proportionalAmounts.map((amount) => fp(random(0.05, 0.1)).mul(amount).div(fp(1)));
 
               // Compute the balances with the added deltas, and the virtual supply without taking them into account
               // (because they are fees).
               if (op == Operation.JOIN) {
                 const proportionalBalances = arrayAdd(preBalances, proportionalAmounts);
-                currentVirtualSupply = fpMul(preVirtualSupply, fp(1).add(ratio));
+                currentVirtualSupply = preVirtualSupply.mul(fp(1).add(ratio)).div(fp(1));
 
                 currentBalances = arrayAdd(proportionalBalances, deltas);
               } else {
                 const proportionalBalances = arraySub(preBalances, proportionalAmounts);
-                currentVirtualSupply = fpMul(preVirtualSupply, fp(1).sub(ratio));
+                currentVirtualSupply = preVirtualSupply.mul(fp(1).sub(ratio)).div(fp(1));
 
                 currentBalances = arrayAdd(proportionalBalances, deltas);
               }
@@ -741,8 +743,8 @@
               const deltaSum = bnSum(deltas);
               const currSum = bnSum(currentBalances);
 
-              const poolFeePercentage = fpDiv(deltaSum, currSum);
-              expectedProtocolOwnershipPercentage = fpMul(poolFeePercentage, swapFee);
+              const poolFeePercentage = deltaSum.mul(fp(1)).div(currSum);
+              expectedProtocolOwnershipPercentage = poolFeePercentage.mul(swapFee).div(fp(1));
             });
           }
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/test/ComposableStablePoolRates.test.ts pool-stable/test/ComposableStablePoolRates.test.ts
--- pool-stable/test/ComposableStablePoolRates.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/test/ComposableStablePoolRates.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -5,7 +5,7 @@
 import { deploy, deployedAt } from '@balancer-labs/v2-helpers/src/contract';
 import { sharedBeforeEach } from '@balancer-labs/v2-common/sharedBeforeEach';
 import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signer-with-address';
-import { bn, fp, fpDiv } from '@balancer-labs/v2-helpers/src/numbers';
+import { bn, fp } from '@balancer-labs/v2-helpers/src/numbers';
 import { ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
 
 import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
@@ -807,7 +807,7 @@
         it('returns the array with elements scaled by the ratio of current and old cached token rates', async () => {
           for (let i = 0; i < 5; i++) {
             const inputArray = tokens.map(() => fp(Math.random()));
-            const expectedOutputArray = inputArray.map((input, i) => fpDiv(input, rates[i]));
+            const expectedOutputArray = inputArray.map((input, i) => input.mul(fp(1)).div(rates[i]));
 
             expect(await pool.getAdjustedBalances(inputArray, true)).to.be.deep.eq(expectedOutputArray);
           }
@@ -819,7 +819,7 @@
           for (let i = 0; i < 5; i++) {
             const inputArray = tokens.map(() => fp(Math.random()));
             const expectedOutputArray = inputArray.map((input, i) =>
-              exemptFromYieldProtocolFeeFlags[i] ? fpDiv(input, rates[i]) : input
+              exemptFromYieldProtocolFeeFlags[i] ? input.mul(fp(1)).div(rates[i]) : input
             );
 
             expect(await pool.getAdjustedBalances(inputArray, false)).to.be.deep.eq(expectedOutputArray);
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-stable/test/StableMath.test.ts pool-stable/test/StableMath.test.ts
--- pool-stable/test/StableMath.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-stable/test/StableMath.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -1,6 +1,6 @@
 import { Contract } from 'ethers';
 import { deploy } from '@balancer-labs/v2-helpers/src/contract';
-import { bn, fp, BigNumber } from '@balancer-labs/v2-helpers/src/numbers';
+import { bn, fp, BigNumber, fromFp } from '@balancer-labs/v2-helpers/src/numbers';
 import { expectEqualWithError } from '@balancer-labs/v2-helpers/src/test/relativeError';
 import {
   calculateAnalyticalInvariantForTwoTokens,
@@ -426,4 +426,30 @@
       }
     });
   });
+
+  context('get rate', () => {
+    async function checkRate(balances: BigNumber[], amp: number, supply: BigNumber): Promise<void> {
+      const ampParameter = bn(amp).mul(AMP_PRECISION);
+      const actualRate = await mock.getRate(balances, ampParameter, supply);
+      const currentInvariant = calculateInvariant(balances, ampParameter);
+      const expectedRate = fp(fromFp(currentInvariant).div(fromFp(supply)));
+
+      expectEqualWithError(actualRate, expectedRate, MAX_RELATIVE_ERROR);
+    }
+
+    context('check over a range of inputs', () => {
+      for (let numTokens = 2; numTokens <= 5; numTokens++) {
+        const balances = Array.from({ length: numTokens }, () => random(250, 350)).map(fp);
+
+        // Supply if all balances were maxed; rate should be ~ 0.7 - 1.0
+        const supply = fp(350).mul(numTokens);
+
+        it(`computes the rate for ${numTokens} tokens`, async () => {
+          for (let amp = 100; amp <= 5000; amp += 100) {
+            await checkRate(balances, amp, supply);
+          }
+        });
+      }
+    });
+  });
 });
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BalancerPoolToken.sol pool-utils/contracts/BalancerPoolToken.sol
--- pool-utils/contracts/BalancerPoolToken.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-utils/contracts/BalancerPoolToken.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20Permit.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20Permit.sol";
 
 /**
  * @title Highly opinionated token implementation
@@ -33,7 +33,7 @@
  * - Assigns infinite allowance for all token holders to the Vault
  */
 contract BalancerPoolToken is ERC20Permit {
-    IVault private immutable _vault;
+    IVault internal immutable _vault;
 
     constructor(
         string memory tokenName,
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BaseGeneralPool.sol pool-utils/contracts/BaseGeneralPool.sol
--- pool-utils/contracts/BaseGeneralPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/BaseGeneralPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
 
 import "./BasePool.sol";
 
@@ -34,7 +34,7 @@
         uint256[] memory balances,
         uint256 indexIn,
         uint256 indexOut
-    ) external override onlyVault(swapRequest.poolId) returns (uint256) {
+    ) public virtual override onlyVault(swapRequest.poolId) returns (uint256) { // MUNGED external => public, +virtual
         _beforeSwapJoinExit();
 
         _validateIndexes(indexIn, indexOut, _getTotalTokens());
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BaseMinimalSwapInfoPool.sol pool-utils/contracts/BaseMinimalSwapInfoPool.sol
--- pool-utils/contracts/BaseMinimalSwapInfoPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/BaseMinimalSwapInfoPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
+import "../../interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
 
 import "./BasePool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BasePool.sol pool-utils/contracts/BasePool.sol
--- pool-utils/contracts/BasePool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/BasePool.sol	2022-09-16 02:43:39.000000000 -0700
@@ -15,21 +15,21 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IAssetManager.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IControlledPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/TemporarilyPausable.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/pool-utils/IAssetManager.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IBasePool.sol";
+
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../solidity-utils/contracts/helpers/TemporarilyPausable.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./BalancerPoolToken.sol";
 import "./BasePoolAuthorization.sol";
 import "./RecoveryMode.sol";
+import "../../../harnesses/StableMathHarness.sol";
 
 // solhint-disable max-states-count
 
@@ -52,14 +52,7 @@
  * BaseGeneralPool or BaseMinimalSwapInfoPool. Otherwise, subclasses must inherit from the corresponding interfaces
  * and implement the swap callbacks themselves.
  */
-abstract contract BasePool is
-    IBasePool,
-    IControlledPool,
-    BasePoolAuthorization,
-    BalancerPoolToken,
-    TemporarilyPausable,
-    RecoveryMode
-{
+abstract contract BasePool is IBasePool, BasePoolAuthorization, BalancerPoolToken, TemporarilyPausable, RecoveryMode, StableMath {
     using WordCodec for bytes32;
     using FixedPoint for uint256;
     using BasePoolUserData for bytes;
@@ -187,7 +180,7 @@
      * @dev This is a permissioned function, and disabled if the pool is paused. The swap fee must be within the
      * bounds set by MIN_SWAP_FEE_PERCENTAGE/MAX_SWAP_FEE_PERCENTAGE. Emits the SwapFeePercentageChanged event.
      */
-    function setSwapFeePercentage(uint256 swapFeePercentage) public virtual override authenticate whenNotPaused {
+    function setSwapFeePercentage(uint256 swapFeePercentage) public virtual authenticate whenNotPaused {
         _setSwapFeePercentage(swapFeePercentage);
     }
 
@@ -226,19 +219,9 @@
         _miscData = _miscData.insertBool(enabled, _RECOVERY_MODE_BIT_OFFSET);
 
         emit RecoveryModeStateChanged(enabled);
-
-        // Some pools need to update their state when leaving recovery mode to ensure proper functioning of the Pool.
-        // We do not allow an `_onEnableRecoveryMode()` hook as this may jeopardize the ability to enable Recovery mode.
-        if (!enabled) _onDisableRecoveryMode();
     }
 
     /**
-     * @dev Performs any necessary actions on the disabling of Recovery Mode.
-     * This is usually to reset any fee collection mechanisms to ensure that they operate correctly going forward.
-     */
-    function _onDisableRecoveryMode() internal virtual {}
-
-    /**
      * @notice Set the asset manager parameters for the given token.
      * @dev This is a permissioned function, unavailable when the pool is paused.
      * The details of the configuration data are set by each Asset Manager. (For an example, see
@@ -247,7 +230,6 @@
     function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)
         public
         virtual
-        override
         authenticate
         whenNotPaused
     {
@@ -283,8 +265,7 @@
     function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {
         return
             (actionId == getActionId(this.setSwapFeePercentage.selector)) ||
-            (actionId == getActionId(this.setAssetManagerPoolConfig.selector)) ||
-            super._isOwnerOnlyAction(actionId);
+            (actionId == getActionId(this.setAssetManagerPoolConfig.selector));
     }
 
     function _getMiscData() internal view returns (bytes32) {
@@ -319,7 +300,7 @@
         uint256 lastChangeBlock,
         uint256 protocolSwapFeePercentage,
         bytes memory userData
-    ) external override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {
+    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) { // MUNGED external => public, + virtual
         _beforeSwapJoinExit();
 
         uint256[] memory scalingFactors = _scalingFactors();
@@ -381,7 +362,7 @@
         uint256 lastChangeBlock,
         uint256 protocolSwapFeePercentage,
         bytes memory userData
-    ) external override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {
+    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) { // MUNGED external => public, + virtual
         uint256[] memory amountsOut;
         uint256 bptAmountIn;
 
@@ -448,6 +429,7 @@
         uint256 protocolSwapFeePercentage,
         bytes memory userData
     ) external override returns (uint256 bptOut, uint256[] memory amountsIn) {
+        /*
         InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
 
         _queryAction(
@@ -458,13 +440,13 @@
             lastChangeBlock,
             protocolSwapFeePercentage,
             userData,
-            _onJoinPool,
-            _downscaleUpArray
+            true, // _onJoinPool,
+            true // _downscaleUpArray
         );
 
         // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
         // and we don't need to return anything here - it just silences compiler warnings.
-        return (bptOut, amountsIn);
+        return (bptOut, amountsIn);*/
     }
 
     /**
@@ -487,6 +469,7 @@
         uint256 protocolSwapFeePercentage,
         bytes memory userData
     ) external override returns (uint256 bptIn, uint256[] memory amountsOut) {
+        /*
         InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
 
         _queryAction(
@@ -497,13 +480,13 @@
             lastChangeBlock,
             protocolSwapFeePercentage,
             userData,
-            _onExitPool,
-            _downscaleDownArray
+            false, // _onExitPool,
+            false // _downscaleDownArray
         );
 
         // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
         // and we don't need to return anything here - it just silences compiler warnings.
-        return (bptIn, amountsOut);
+        return (bptIn, amountsOut);*/
     }
 
     // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are
@@ -747,7 +730,7 @@
         // Governance control.
         return getVault().getAuthorizer();
     }
-
+    /*
     function _queryAction(
         bytes32 poolId,
         address sender,
@@ -756,10 +739,12 @@
         uint256 lastChangeBlock,
         uint256 protocolSwapFeePercentage,
         bytes memory userData,
-        function(bytes32, address, address, uint256[] memory, uint256, uint256, uint256[] memory, bytes memory)
-            internal
-            returns (uint256, uint256[] memory) _action,
-        function(uint256[] memory, uint256[] memory) internal view _downscaleArray
+        bool isJoin,
+        bool scaleUp
+        // function(bytes32, address, address, uint256[] memory, uint256, uint256, uint256[] memory, bytes memory)
+        //     internal
+        //     returns (uint256, uint256[] memory) _action,
+        // function(uint256[] memory, uint256[] memory) internal view _downscaleArray
     ) private {
         // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed
         // explanation.
@@ -837,18 +822,35 @@
             uint256[] memory scalingFactors = _scalingFactors();
             _upscaleArray(balances, scalingFactors);
 
-            (uint256 bptAmount, uint256[] memory tokenAmounts) = _action(
-                poolId,
-                sender,
-                recipient,
-                balances,
-                lastChangeBlock,
-                protocolSwapFeePercentage,
-                scalingFactors,
-                userData
-            );
-
-            _downscaleArray(tokenAmounts, scalingFactors);
+            uint256 bptAmount; uint256[] memory tokenAmounts;
+            if (isJoin)
+                (bptAmount, tokenAmounts) = _onJoinPool(
+                    poolId,
+                    sender,
+                    recipient,
+                    balances,
+                    lastChangeBlock,
+                    protocolSwapFeePercentage,
+                    scalingFactors,
+                    userData
+                );
+            else
+                (bptAmount, tokenAmounts) = _onExitPool(
+                    poolId,
+                    sender,
+                    recipient,
+                    balances,
+                    lastChangeBlock,
+                    protocolSwapFeePercentage,
+                    scalingFactors,
+                    userData
+                );
+
+
+            if (scaleUp) 
+                _downscaleUpArray(tokenAmounts, scalingFactors);
+            else
+                _downscaleDownArray(tokenAmounts, scalingFactors);
 
             // solhint-disable-next-line no-inline-assembly
             assembly {
@@ -874,4 +876,5 @@
             }
         }
     }
+    */
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/BasePoolAuthorization.sol pool-utils/contracts/BasePoolAuthorization.sol
--- pool-utils/contracts/BasePoolAuthorization.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/BasePoolAuthorization.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
 
 /**
  * @dev Base authorization layer implementation for Pools.
@@ -55,9 +55,7 @@
         }
     }
 
-    function _isOwnerOnlyAction(bytes32) internal view virtual returns (bool) {
-        return false;
-    }
+    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual returns (bool);
 
     function _getAuthorizer() internal view virtual returns (IAuthorizer);
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/ProtocolFeeCache.sol pool-utils/contracts/ProtocolFeeCache.sol
--- pool-utils/contracts/ProtocolFeeCache.sol	1969-12-31 16:00:00.000000000 -0800
+++ pool-utils/contracts/ProtocolFeeCache.sol	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/SafeCast.sol";
+
+import "./RecoveryMode.sol";
+
+/**
+ * @dev The Vault does not provide the protocol swap fee percentage in swap hooks (as swaps don't typically need this
+ * value), so for swaps that need this value, we would have to to fetch it ourselves from the
+ * ProtocolFeePercentagesProvider. Additionally, other protocol fee types (such as Yield or AUM) can only be obtained
+ * by making said call.
+ *
+ * However, these values change so rarely that it doesn't make sense to perform the required calls to get the current
+ * values in every single user interaction. Instead, we keep a local copy that can be permissionlessly updated by anyone
+ * with the real value. We also pack these values together, performing a single storage read to get them all.
+ *
+ * When initialized with a special sentinel value, the swap fee is delegated, meaning the mutable protocol swap fee
+ * cache is set to the current value stored in the ProtocolFeePercentagesProvider, and can be updated by anyone with a
+ * call to `updateProtocolFeePercentageCache`. Any other value means the protocol swap fee is fixed, so it is instead
+ * stored in the immutable `_fixedProtocolSwapFeePercentage`.
+ */
+abstract contract ProtocolFeeCache is RecoveryMode {
+    using SafeCast for uint256;
+
+    IProtocolFeePercentagesProvider private immutable _protocolFeeProvider;
+
+    // Protocol Fee Percentages can never be larger than 100% (1e18), which fits in ~59 bits, so using 64 for each type
+    // is sufficient.
+    struct FeeTypeCache {
+        uint64 swapFee;
+        uint64 yieldFee;
+        uint64 aumFee;
+    }
+
+    FeeTypeCache private _cache;
+
+    event ProtocolFeePercentageCacheUpdated(uint256 indexed feeType, uint256 protocolSwapFeePercentage);
+
+    // Swap fees can be set to a fixed value at construction, or delegated to the ProtocolFeePercentagesProvider if
+    // passing the special sentinel value.
+    uint256 public constant DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL = type(uint256).max;
+
+    bool private immutable _delegatedProtocolSwapFees;
+
+    // Only valid when `_delegatedProtocolSwapFees` is false
+    uint256 private immutable _fixedProtocolSwapFeePercentage;
+
+    constructor(IProtocolFeePercentagesProvider protocolFeeProvider, uint256 protocolSwapFeePercentage) {
+        // Protocol swap fees are delegated to the value reported by the ProtocolFeePercentagesProvider if the sentinel
+        // value is passed.
+        bool delegatedProtocolSwapFees = protocolSwapFeePercentage == DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL;
+
+        _delegatedProtocolSwapFees = delegatedProtocolSwapFees;
+        _protocolFeeProvider = protocolFeeProvider;
+
+        _updateProtocolFeeCache(protocolFeeProvider, ProtocolFeeType.YIELD);
+        _updateProtocolFeeCache(protocolFeeProvider, ProtocolFeeType.AUM);
+
+        if (delegatedProtocolSwapFees) {
+            _updateProtocolFeeCache(protocolFeeProvider, ProtocolFeeType.SWAP);
+        } else {
+            _require(
+                protocolSwapFeePercentage <= protocolFeeProvider.getFeeTypeMaximumPercentage(ProtocolFeeType.SWAP),
+                Errors.SWAP_FEE_PERCENTAGE_TOO_HIGH
+            );
+
+            // We cannot set `_fixedProtocolSwapFeePercentage` here due to it being immutable so instead we must set it
+            // in the main function scope with a value based on whether protocol fees are delegated.
+
+            // Emit an event as we do in `_updateProtocolFeeCache` to appear the same to offchain indexers.
+            emit ProtocolFeePercentageCacheUpdated(ProtocolFeeType.SWAP, protocolSwapFeePercentage);
+        }
+
+        // As `_fixedProtocolSwapFeePercentage` is immutable we must set a value, but just set to zero if it's not used.
+        _fixedProtocolSwapFeePercentage = delegatedProtocolSwapFees ? 0 : protocolSwapFeePercentage;
+    }
+
+    /**
+     * @dev Returns the cached protocol fee percentage. If `getProtocolSwapFeeDelegation()` is false, this value is
+     * immutable for swap fee queries. Alternatively, it will track the global fee percentage set in the
+     * ProtocolFeePercentagesProvider.
+     */
+    function getProtocolFeePercentageCache(uint256 feeType) public view returns (uint256) {
+        if (inRecoveryMode()) {
+            return 0;
+        }
+
+        if (feeType == ProtocolFeeType.SWAP) {
+            return getProtocolSwapFeeDelegation() ? _cache.swapFee : _fixedProtocolSwapFeePercentage;
+        } else if (feeType == ProtocolFeeType.YIELD) {
+            return _cache.yieldFee;
+        } else if (feeType == ProtocolFeeType.AUM) {
+            return _cache.aumFee;
+        } else {
+            _revert(Errors.UNHANDLED_FEE_TYPE);
+        }
+    }
+
+    /**
+     * @dev Can be called by anyone to update the cached fee percentages (swap fee is only updated when delegated).
+     * Updates the cache to the latest value set by governance.
+     */
+    function updateProtocolFeePercentageCache() external {
+        if (getProtocolSwapFeeDelegation()) {
+            _updateProtocolFeeCache(_protocolFeeProvider, ProtocolFeeType.SWAP);
+        }
+
+        _updateProtocolFeeCache(_protocolFeeProvider, ProtocolFeeType.YIELD);
+        _updateProtocolFeeCache(_protocolFeeProvider, ProtocolFeeType.AUM);
+    }
+
+    /**
+     * @dev Returns whether this Pool tracks protocol swap fee changes in the IProtocolFeePercentagesProvider.
+     */
+    function getProtocolSwapFeeDelegation() public view returns (bool) {
+        return _delegatedProtocolSwapFees;
+    }
+
+    function _updateProtocolFeeCache(IProtocolFeePercentagesProvider protocolFeeProvider, uint256 feeType) private {
+        uint256 currentValue = protocolFeeProvider.getFeeTypePercentage(feeType);
+
+        if (feeType == ProtocolFeeType.SWAP) {
+            _cache.swapFee = currentValue.toUint64();
+        } else if (feeType == ProtocolFeeType.YIELD) {
+            _cache.yieldFee = currentValue.toUint64();
+        } else if (feeType == ProtocolFeeType.AUM) {
+            _cache.aumFee = currentValue.toUint64();
+        } else {
+            _revert(Errors.UNHANDLED_FEE_TYPE);
+        }
+
+        emit ProtocolFeePercentageCacheUpdated(feeType, currentValue);
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/RecoveryMode.sol pool-utils/contracts/RecoveryMode.sol
--- pool-utils/contracts/RecoveryMode.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/RecoveryMode.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/BasePoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRecoveryMode.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/pool-utils/BasePoolUserData.sol";
+import "../../interfaces/contracts/pool-utils/IRecoveryMode.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 import "./BasePoolAuthorization.sol";
 
@@ -60,7 +60,7 @@
      * @dev Does not otherwise affect pool operations (beyond deferring payment of protocol fees), though some pools may
      * perform certain operations in a "safer" manner that is less likely to fail, in an attempt to keep the pool
      * running, even in a pathological state. Unlike the Pause operation, which is only available during a short window
-     * after factory deployment, Recovery Mode can always be enabled.
+     * after factory deployment, Recovery Mode can always be enableed.
      */
     function enableRecoveryMode() external override authenticate {
         _setRecoveryMode(true);
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/controllers/BasePoolController.sol pool-utils/contracts/controllers/BasePoolController.sol
--- pool-utils/contracts/controllers/BasePoolController.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-utils/contracts/controllers/BasePoolController.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IBasePoolController.sol";
+import "../../interfaces/contracts/pool-utils/IBasePoolController.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../solidity-utils/contracts/helpers/WordCodec.sol";
 
 import "../BasePoolAuthorization.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/controllers/ManagedPoolController.sol pool-utils/contracts/controllers/ManagedPoolController.sol
--- pool-utils/contracts/controllers/ManagedPoolController.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/controllers/ManagedPoolController.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IControlledManagedPool.sol";
+import "../../interfaces/contracts/pool-utils/IControlledManagedPool.sol";
 
 import "./BasePoolController.sol";
 
@@ -29,7 +29,7 @@
  * While Balancer pool owners are immutable, ownership of this pool controller can be transferrable,
  * if the corresponding permission is set.
  */
-contract ManagedPoolController is BasePoolController {
+contract ManagedPoolController is BasePoolController, IControlledManagedPool {
     using WordCodec for bytes32;
 
     // There are six managed pool rights: all corresponding to permissioned functions of ManagedPool.
@@ -151,7 +151,7 @@
         uint256 startTime,
         uint256 endTime,
         uint256[] calldata endWeights
-    ) external virtual onlyManager withBoundPool {
+    ) external virtual override onlyManager withBoundPool {
         _require(canChangeWeights(), Errors.FEATURE_DISABLED);
         _require(
             endTime >= startTime && endTime - startTime >= _minWeightChangeDuration,
@@ -164,7 +164,7 @@
     /**
      * @dev Pass a call to ManagedPool's setSwapEnabled through to the underlying pool.
      */
-    function setSwapEnabled(bool swapEnabled) external virtual onlyManager withBoundPool {
+    function setSwapEnabled(bool swapEnabled) external virtual override onlyManager withBoundPool {
         _require(canDisableSwaps(), Errors.FEATURE_DISABLED);
 
         IControlledManagedPool(pool).setSwapEnabled(swapEnabled);
@@ -179,7 +179,7 @@
      * Adding a set of addresses to the allowlist enables multiple seed funding sources. Disabling the
      * allowlist, or re-enabling it after allowing public LPs, can impose or remove a "cap" on the total supply.
      */
-    function setMustAllowlistLPs(bool mustAllowlistLPs) external virtual onlyManager withBoundPool {
+    function setMustAllowlistLPs(bool mustAllowlistLPs) external virtual override onlyManager withBoundPool {
         _require(canSetMustAllowlistLPs(), Errors.FEATURE_DISABLED);
 
         IControlledManagedPool(pool).setMustAllowlistLPs(mustAllowlistLPs);
@@ -189,7 +189,7 @@
      * @dev Pass a call to ManagedPool's addAllowedAddress through to the underlying pool.
      * The underlying pool handles all state/permission checks. It will revert if the LP allowlist is off.
      */
-    function addAllowedAddress(address member) external virtual onlyManager withBoundPool {
+    function addAllowedAddress(address member) external virtual override onlyManager withBoundPool {
         IControlledManagedPool(pool).addAllowedAddress(member);
     }
 
@@ -198,14 +198,14 @@
      * The underlying pool handles all state/permission checks. It will revert if the address was not
      * previouslly added to the allowlist.
      */
-    function removeAllowedAddress(address member) external virtual onlyManager withBoundPool {
+    function removeAllowedAddress(address member) external virtual override onlyManager withBoundPool {
         IControlledManagedPool(pool).removeAllowedAddress(member);
     }
 
     /**
      * @dev Transfer any BPT management fees from this contract to the recipient.
      */
-    function withdrawCollectedManagementFees(address recipient) external virtual onlyManager withBoundPool {
+    function withdrawCollectedManagementFees(address recipient) external virtual override onlyManager withBoundPool {
         IERC20(pool).transfer(recipient, IERC20(pool).balanceOf(address(this)));
     }
 
@@ -215,6 +215,7 @@
     function setManagementSwapFeePercentage(uint256 managementSwapFeePercentage)
         external
         virtual
+        override
         onlyManager
         withBoundPool
     {
@@ -229,12 +230,12 @@
     function setManagementAumFeePercentage(uint256 managementAumFeePercentage)
         external
         virtual
+        override
         onlyManager
         withBoundPool
-        returns (uint256)
     {
         _require(canChangeManagementFees(), Errors.FEATURE_DISABLED);
 
-        return IControlledManagedPool(pool).setManagementAumFeePercentage(managementAumFeePercentage);
+        IControlledManagedPool(pool).setManagementAumFeePercentage(managementAumFeePercentage);
     }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/protocol-fees/InvariantGrowthProtocolSwapFees.sol pool-utils/contracts/protocol-fees/InvariantGrowthProtocolSwapFees.sol
--- pool-utils/contracts/protocol-fees/InvariantGrowthProtocolSwapFees.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/protocol-fees/InvariantGrowthProtocolSwapFees.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,100 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
-import "./ProtocolFees.sol";
-
-library InvariantGrowthProtocolSwapFees {
-    using FixedPoint for uint256;
-
-    function getProtocolOwnershipPercentage(
-        uint256 invariantGrowthRatio,
-        uint256 supplyGrowthRatio,
-        uint256 protocolSwapFeePercentage
-    ) internal pure returns (uint256) {
-        // Joins and exits are symmetrical; for simplicity, we consider a join, where the invariant and supply
-        // both increase.
-
-        // |-------------------------|-- original invariant * invariantGrowthRatio
-        // |   increase from fees    |
-        // |-------------------------|-- original invariant * supply growth ratio (fee-less invariant)
-        // |                         |
-        // | increase from balances  |
-        // |-------------------------|-- original invariant
-        // |                         |
-        // |                         |  |------------------|-- currentSupply
-        // |                         |  |    BPT minted    |
-        // |                         |  |------------------|-- previousSupply
-        // |   original invariant    |  |  original supply |
-        // |_________________________|  |__________________|
-        //
-        // If the join is proportional, the invariant and supply will likewise increase proportionally,
-        // so the growth ratios (invariantGrowthRatio / supplyGrowthRatio) will be equal. In this case, we do not charge
-        // any protocol fees.
-        // We also charge no protocol fees in the case where `invariantGrowthRatio < supplyGrowthRatio` to avoid
-        // potential underflows, however this should only occur in extremely low volume actions due solely to rounding
-        // error.
-
-        if ((supplyGrowthRatio >= invariantGrowthRatio) || (protocolSwapFeePercentage == 0)) return 0;
-
-        // If the join is non-proportional, the supply increase will be proportionally less than the invariant increase,
-        // since the BPT minted will be based on fewer tokens (because swap fees are not included). So the supply growth
-        // is due entirely to the balance changes, while the invariant growth also includes swap fees.
-        //
-        // To isolate the amount of increase by fees then, we multiply the original invariant by the supply growth
-        // ratio to get the "feeless invariant". The difference between the final invariant and this value is then
-        // the amount of the invariant due to fees, which we convert to a percentage by normalizing against the
-        // final invariant. This is expressed as the expression below:
-        //
-        // invariantGrowthFromFees = currentInvariant - supplyGrowthRatio * previousInvariant
-        //
-        // We then divide through by current invariant so the LHS can be identified as the fraction of the pool which
-        // is made up of accumulated swap fees.
-        //
-        // swapFeesPercentage = 1 - supplyGrowthRatio * previousInvariant / currentInvariant
-        //
-        // We then define `invariantGrowthRatio` in a similar fashion to `supplyGrowthRatio` to give the result:
-        //
-        // swapFeesPercentage = 1 - supplyGrowthRatio / invariantGrowthRatio
-        //
-        // Using this form allows us to consider only the ratios of the two invariants, rather than their absolute
-        // values: a useful property, as this is sometimes easier than calculating the full invariant twice.
-
-        // We've already checked that `supplyGrowthRatio` is smaller than `invariantGrowthRatio`, and hence their ratio
-        // smaller than FixedPoint.ONE, allowing for unchecked arithmetic.
-        uint256 swapFeesPercentage = FixedPoint.ONE - supplyGrowthRatio.divDown(invariantGrowthRatio);
-
-        // We then multiply by the protocol swap fee percentage to get the fraction of the pool which the protocol
-        // should own once fees have been collected.
-        return swapFeesPercentage.mulDown(protocolSwapFeePercentage);
-    }
-
-    function calcDueProtocolFees(
-        uint256 invariantGrowthRatio,
-        uint256 previousSupply,
-        uint256 currentSupply,
-        uint256 protocolSwapFeePercentage
-    ) internal pure returns (uint256) {
-        uint256 protocolOwnershipPercentage = getProtocolOwnershipPercentage(
-            invariantGrowthRatio,
-            currentSupply.divDown(previousSupply),
-            protocolSwapFeePercentage
-        );
-
-        return ProtocolFees.bptForPoolOwnershipPercentage(currentSupply, protocolOwnershipPercentage);
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/protocol-fees/ProtocolFeeCache.sol pool-utils/contracts/protocol-fees/ProtocolFeeCache.sol
--- pool-utils/contracts/protocol-fees/ProtocolFeeCache.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/protocol-fees/ProtocolFeeCache.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,160 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeCast.sol";
-
-import "../RecoveryMode.sol";
-
-/**
- * @dev The Vault does not provide the protocol swap fee percentage in swap hooks (as swaps don't typically need this
- * value), so for swaps that need this value, we would have to to fetch it ourselves from the
- * ProtocolFeePercentagesProvider. Additionally, other protocol fee types (such as Yield or AUM) can only be obtained
- * by making said call.
- *
- * However, these values change so rarely that it doesn't make sense to perform the required calls to get the current
- * values in every single user interaction. Instead, we keep a local copy that can be permissionlessly updated by anyone
- * with the real value. We also pack these values together, performing a single storage read to get them all.
- *
- * When initialized with a special sentinel value, the swap fee is delegated, meaning the mutable protocol swap fee
- * cache is set to the current value stored in the ProtocolFeePercentagesProvider, and can be updated by anyone with a
- * call to `updateProtocolFeePercentageCache`. Any other value means the protocol swap fee is fixed, so it is instead
- * stored in the immutable `_fixedProtocolSwapFeePercentage`.
- */
-abstract contract ProtocolFeeCache is RecoveryMode {
-    using SafeCast for uint256;
-
-    IProtocolFeePercentagesProvider private immutable _protocolFeeProvider;
-
-    // Protocol Fee Percentages can never be larger than 100% (1e18), which fits in ~59 bits, so using 64 for each type
-    // is sufficient.
-    struct FeeTypeCache {
-        uint64 swapFee;
-        uint64 yieldFee;
-        uint64 aumFee;
-    }
-
-    FeeTypeCache private _cache;
-
-    event ProtocolFeePercentageCacheUpdated(uint256 indexed feeType, uint256 protocolFeePercentage);
-
-    // Swap fees can be set to a fixed value at construction, or delegated to the ProtocolFeePercentagesProvider if
-    // passing the special sentinel value.
-    uint256 public constant DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL = type(uint256).max;
-
-    bool private immutable _delegatedProtocolSwapFees;
-
-    // Only valid when `_delegatedProtocolSwapFees` is false
-    uint256 private immutable _fixedProtocolSwapFeePercentage;
-
-    constructor(IProtocolFeePercentagesProvider protocolFeeProvider, uint256 protocolSwapFeePercentage) {
-        // Protocol swap fees are delegated to the value reported by the ProtocolFeePercentagesProvider if the sentinel
-        // value is passed.
-        bool delegatedProtocolSwapFees = protocolSwapFeePercentage == DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL;
-
-        _delegatedProtocolSwapFees = delegatedProtocolSwapFees;
-        _protocolFeeProvider = protocolFeeProvider;
-
-        _updateProtocolFeeCache(protocolFeeProvider, ProtocolFeeType.YIELD);
-        _updateProtocolFeeCache(protocolFeeProvider, ProtocolFeeType.AUM);
-
-        if (delegatedProtocolSwapFees) {
-            _updateProtocolFeeCache(protocolFeeProvider, ProtocolFeeType.SWAP);
-        } else {
-            _require(
-                protocolSwapFeePercentage <= protocolFeeProvider.getFeeTypeMaximumPercentage(ProtocolFeeType.SWAP),
-                Errors.SWAP_FEE_PERCENTAGE_TOO_HIGH
-            );
-
-            // We cannot set `_fixedProtocolSwapFeePercentage` here due to it being immutable so instead we must set it
-            // in the main function scope with a value based on whether protocol fees are delegated.
-
-            // Emit an event as we do in `_updateProtocolFeeCache` to appear the same to offchain indexers.
-            emit ProtocolFeePercentageCacheUpdated(ProtocolFeeType.SWAP, protocolSwapFeePercentage);
-        }
-
-        // As `_fixedProtocolSwapFeePercentage` is immutable we must set a value, but just set to zero if it's not used.
-        _fixedProtocolSwapFeePercentage = delegatedProtocolSwapFees ? 0 : protocolSwapFeePercentage;
-    }
-
-    /**
-     * @dev Returns the cached protocol fee percentage. If `getProtocolSwapFeeDelegation()` is false, this value is
-     * immutable for swap fee queries. Alternatively, it will track the global fee percentage set in the
-     * ProtocolFeePercentagesProvider.
-     */
-    function getProtocolFeePercentageCache(uint256 feeType) public view returns (uint256) {
-        if (inRecoveryMode()) {
-            return 0;
-        }
-
-        if (feeType == ProtocolFeeType.SWAP) {
-            return getProtocolSwapFeeDelegation() ? _cache.swapFee : _fixedProtocolSwapFeePercentage;
-        } else if (feeType == ProtocolFeeType.YIELD) {
-            return _cache.yieldFee;
-        } else if (feeType == ProtocolFeeType.AUM) {
-            return _cache.aumFee;
-        } else {
-            _revert(Errors.UNHANDLED_FEE_TYPE);
-        }
-    }
-
-    /**
-     * @dev Can be called by anyone to update the cached fee percentages (swap fee is only updated when delegated).
-     * Updates the cache to the latest value set by governance.
-     */
-    function updateProtocolFeePercentageCache() external {
-        _beforeProtocolFeeCacheUpdate();
-
-        if (getProtocolSwapFeeDelegation()) {
-            _updateProtocolFeeCache(_protocolFeeProvider, ProtocolFeeType.SWAP);
-        }
-
-        _updateProtocolFeeCache(_protocolFeeProvider, ProtocolFeeType.YIELD);
-        _updateProtocolFeeCache(_protocolFeeProvider, ProtocolFeeType.AUM);
-    }
-
-    /**
-     * @dev Override in derived contracts to perform some action before the cache is updated. This is typically relevant
-     * to Pools that incur protocol debt between operations. To avoid altering the amount due retroactively, this debt
-     * needs to be paid before the fee percentages change.
-     */
-    function _beforeProtocolFeeCacheUpdate() internal virtual {}
-
-    /**
-     * @dev Returns whether this Pool tracks protocol swap fee changes in the IProtocolFeePercentagesProvider.
-     */
-    function getProtocolSwapFeeDelegation() public view returns (bool) {
-        return _delegatedProtocolSwapFees;
-    }
-
-    function _updateProtocolFeeCache(IProtocolFeePercentagesProvider protocolFeeProvider, uint256 feeType) private {
-        uint256 currentValue = protocolFeeProvider.getFeeTypePercentage(feeType);
-
-        if (feeType == ProtocolFeeType.SWAP) {
-            _cache.swapFee = currentValue.toUint64();
-        } else if (feeType == ProtocolFeeType.YIELD) {
-            _cache.yieldFee = currentValue.toUint64();
-        } else if (feeType == ProtocolFeeType.AUM) {
-            _cache.aumFee = currentValue.toUint64();
-        } else {
-            _revert(Errors.UNHANDLED_FEE_TYPE);
-        }
-
-        emit ProtocolFeePercentageCacheUpdated(feeType, currentValue);
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/protocol-fees/ProtocolFees.sol pool-utils/contracts/protocol-fees/ProtocolFees.sol
--- pool-utils/contracts/protocol-fees/ProtocolFees.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/protocol-fees/ProtocolFees.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,41 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
-
-library ProtocolFees {
-    using FixedPoint for uint256;
-
-    /**
-     * @dev Calculates the amount of BPT necessary to give ownership of a given percentage of the Pool.
-     * Note that this function reverts if `poolPercentage` >= 100%, it's expected that the caller will enforce this.
-     * @param totalSupply - The total supply of the pool prior to minting BPT.
-     * @param poolOwnershipPercentage - The desired ownership percentage of the pool to have as a result of minting BPT.
-     * @return bptAmount - The amount of BPT to mint such that it is `poolPercentage` of the resultant total supply.
-     */
-    function bptForPoolOwnershipPercentage(uint256 totalSupply, uint256 poolOwnershipPercentage)
-        internal
-        pure
-        returns (uint256)
-    {
-        // If we mint some amount `bptAmount` of BPT then the percentage ownership of the pool this grants is given by:
-        // `poolOwnershipPercentage = bptAmount / (totalSupply + bptAmount)`.
-        // Solving for `bptAmount`, we arrive at:
-        // `bptAmount = totalSupply * poolOwnershipPercentage / (1 - poolOwnershipPercentage)`.
-        return Math.divDown(Math.mul(totalSupply, poolOwnershipPercentage), poolOwnershipPercentage.complement());
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/rates/PriceRateCache.sol pool-utils/contracts/rates/PriceRateCache.sol
--- pool-utils/contracts/rates/PriceRateCache.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/rates/PriceRateCache.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../../solidity-utils/contracts/helpers/WordCodec.sol";
 
 /**
  * Price rate caches are used to avoid querying the price rate for a token every time we need to work with it. It is
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockAssetManager.sol pool-utils/contracts/test/MockAssetManager.sol
--- pool-utils/contracts/test/MockAssetManager.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/test/MockAssetManager.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IAssetManager.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/pool-utils/IAssetManager.sol";
 
 contract MockAssetManager is IAssetManager {
     event Rebalanced(address assetManager, bytes32 poolId, IERC20 token, bool force);
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockBalancerPoolToken.sol pool-utils/contracts/test/MockBalancerPoolToken.sol
--- pool-utils/contracts/test/MockBalancerPoolToken.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-utils/contracts/test/MockBalancerPoolToken.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "../BalancerPoolToken.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockBasePool.sol pool-utils/contracts/test/MockBasePool.sol
--- pool-utils/contracts/test/MockBasePool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/test/MockBasePool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
 
 import "../BasePool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockFailureModes.sol pool-utils/contracts/test/MockFailureModes.sol
--- pool-utils/contracts/test/MockFailureModes.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-utils/contracts/test/MockFailureModes.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 abstract contract MockFailureModes {
     enum FailureMode { INVARIANT, PRICE_RATE }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockInvariantGrowthProtocolSwapFees.sol pool-utils/contracts/test/MockInvariantGrowthProtocolSwapFees.sol
--- pool-utils/contracts/test/MockInvariantGrowthProtocolSwapFees.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/test/MockInvariantGrowthProtocolSwapFees.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,34 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-
-import "../protocol-fees/InvariantGrowthProtocolSwapFees.sol";
-
-contract MockInvariantGrowthProtocolSwapFees {
-    function calculateDueProtocolFees(
-        uint256 invariantGrowthRatio,
-        uint256 previousSupply,
-        uint256 currentSupply,
-        uint256 protocolSwapFeePercentage
-    ) external pure returns (uint256) {
-        return
-            InvariantGrowthProtocolSwapFees.calcDueProtocolFees(
-                invariantGrowthRatio,
-                previousSupply,
-                currentSupply,
-                protocolSwapFeePercentage
-            );
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockProtocolFeeCache.sol pool-utils/contracts/test/MockProtocolFeeCache.sol
--- pool-utils/contracts/test/MockProtocolFeeCache.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/test/MockProtocolFeeCache.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "../protocol-fees/ProtocolFeeCache.sol";
+import "../ProtocolFeeCache.sol";
 import "./MockRecoveryModeStorage.sol";
 
 contract MockProtocolFeeCache is ProtocolFeeCache, MockRecoveryModeStorage {
@@ -28,16 +28,6 @@
         // solhint-disable-previous-line no-empty-blocks
     }
 
-    event FeesInBeforeHook(uint256 swap, uint256 yield, uint256 aum);
-
-    function _beforeProtocolFeeCacheUpdate() internal override {
-        emit FeesInBeforeHook(
-            getProtocolFeePercentageCache(ProtocolFeeType.SWAP),
-            getProtocolFeePercentageCache(ProtocolFeeType.YIELD),
-            getProtocolFeePercentageCache(ProtocolFeeType.AUM)
-        );
-    }
-
     function _isOwnerOnlyAction(bytes32) internal pure override returns (bool) {
         return true;
     }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockProtocolFees.sol pool-utils/contracts/test/MockProtocolFees.sol
--- pool-utils/contracts/test/MockProtocolFees.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/test/MockProtocolFees.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-
-import "../protocol-fees/ProtocolFees.sol";
-
-contract MockProtocolFees {
-    function bptForPoolOwnershipPercentage(uint256 totalSupply, uint256 poolPercentage)
-        external
-        pure
-        returns (uint256)
-    {
-        return ProtocolFees.bptForPoolOwnershipPercentage(totalSupply, poolPercentage);
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockRateProvider.sol pool-utils/contracts/test/MockRateProvider.sol
--- pool-utils/contracts/test/MockRateProvider.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-utils/contracts/test/MockRateProvider.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
+import "../../interfaces/contracts/pool-utils/IRateProvider.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 contract MockRateProvider is IRateProvider {
     uint256 internal _rate;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockRecoveryModeStorage.sol pool-utils/contracts/test/MockRecoveryModeStorage.sol
--- pool-utils/contracts/test/MockRecoveryModeStorage.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/test/MockRecoveryModeStorage.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "../RecoveryMode.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/contracts/test/MockVault.sol pool-utils/contracts/test/MockVault.sol
--- pool-utils/contracts/test/MockVault.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/contracts/test/MockVault.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,15 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IPoolSwapStructs.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IBasePool.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/vault/IPoolSwapStructs.sol";
+import "../../interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
 
-import "@balancer-labs/v2-vault/contracts/ProtocolFeesCollector.sol";
+import "../../vault/contracts/ProtocolFeesCollector.sol";
 
 contract MockVault is IPoolSwapStructs {
     struct Pool {
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/test/InvariantGrowthProtocolSwapFees.test.ts pool-utils/test/InvariantGrowthProtocolSwapFees.test.ts
--- pool-utils/test/InvariantGrowthProtocolSwapFees.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/test/InvariantGrowthProtocolSwapFees.test.ts	1969-12-31 16:00:00.000000000 -0800
@@ -1,84 +0,0 @@
-import { Contract } from 'ethers';
-
-import { bn, fp, fpDiv, fpMul } from '@balancer-labs/v2-helpers/src/numbers';
-import { deploy } from '@balancer-labs/v2-helpers/src/contract';
-import { expectEqualWithError } from '@balancer-labs/v2-helpers/src/test/relativeError';
-import {
-  calculateInvariant,
-  calculateBPTSwapFeeAmount,
-} from '@balancer-labs/v2-helpers/src/models/pools/weighted/math';
-import { expect } from 'chai';
-
-const MAX_RELATIVE_ERROR = 0.0001; // Max relative error
-
-describe('InvariantGrowthProtocolSwapFees', function () {
-  let mock: Contract;
-
-  sharedBeforeEach(async function () {
-    mock = await deploy('MockInvariantGrowthProtocolSwapFees');
-  });
-
-  context('with invariant growth', () => {
-    it('returns protocol swap fees', async () => {
-      const normalizedWeights = [bn(0.3e18), bn(0.7e18)];
-      const lastBalances = [bn(25e18), bn(500e18)];
-
-      // Both balances increase by 40%
-      const currentBalances = [bn(35e18), bn(700e18)];
-
-      const protocolSwapFeePercentage = fp(0.3);
-      // The protocol is due 30% of the 10 extra tokens in token A (3 tokens), and 30% of the 200 extra tokens in token B
-      // (60 tokens).
-
-      const totalSupply = fp(100);
-
-      const lastInvariant = calculateInvariant(lastBalances, normalizedWeights);
-      const currentInvariant = calculateInvariant(currentBalances, normalizedWeights);
-
-      const toMint = await mock.calculateDueProtocolFees(
-        fpDiv(currentInvariant, lastInvariant),
-        totalSupply,
-        totalSupply,
-        protocolSwapFeePercentage
-      );
-
-      // The BPT to mint should be such that it'd let the protocol claim the tokens it is due if exiting proportionally
-      const protocolPoolOwnership = fpDiv(toMint, totalSupply.add(toMint)); // The BPT supply grows
-
-      const tokenAFeeAmount = fpMul(currentBalances[0], protocolPoolOwnership);
-      const tokenBFeeAmount = fpMul(currentBalances[1], protocolPoolOwnership);
-
-      expectEqualWithError(tokenAFeeAmount, bn(3e18), MAX_RELATIVE_ERROR);
-      expectEqualWithError(tokenBFeeAmount, bn(60e18), MAX_RELATIVE_ERROR);
-
-      // The TS helper outputs the same value
-      const expectedToMint = calculateBPTSwapFeeAmount(
-        fpDiv(currentInvariant, lastInvariant),
-        totalSupply,
-        totalSupply,
-        protocolSwapFeePercentage
-      );
-
-      expectEqualWithError(toMint, expectedToMint, MAX_RELATIVE_ERROR);
-    });
-  });
-
-  context('with smaller invariant', () => {
-    it('returns zero', async () => {
-      const protocolSwapFeePercentage = fp(0.3);
-      const totalSupply = fp(100);
-
-      const lastInvariant = fp(300);
-      const currentInvariant = fp(299);
-
-      const toMint = await mock.calculateDueProtocolFees(
-        fpDiv(currentInvariant, lastInvariant),
-        totalSupply,
-        totalSupply,
-        protocolSwapFeePercentage
-      );
-
-      expect(toMint).to.equal(0);
-    });
-  });
-});
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/test/ProtocolFeeCache.test.ts pool-utils/test/ProtocolFeeCache.test.ts
--- pool-utils/test/ProtocolFeeCache.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/test/ProtocolFeeCache.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -85,26 +85,12 @@
           expect(await protocolFeeCache.getProtocolFeePercentageCache(feeType)).to.equal(NEW_VALUE);
         });
 
-        it('calls the hook before the cache is updated', async () => {
-          const preSwapFee = await protocolFeeCache.getProtocolFeePercentageCache(ProtocolFee.SWAP);
-          const preYieldFee = await protocolFeeCache.getProtocolFeePercentageCache(ProtocolFee.YIELD);
-          const preAumFee = await protocolFeeCache.getProtocolFeePercentageCache(ProtocolFee.AUM);
-
-          const receipt = await protocolFeeCache.updateProtocolFeePercentageCache();
-
-          expectEvent.inReceipt(await receipt.wait(), 'FeesInBeforeHook', {
-            swap: preSwapFee,
-            yield: preYieldFee,
-            aum: preAumFee,
-          });
-        });
-
         it('emits an event when updating the cache', async () => {
           const receipt = await protocolFeeCache.updateProtocolFeePercentageCache();
 
           expectEvent.inReceipt(await receipt.wait(), 'ProtocolFeePercentageCacheUpdated', {
             feeType,
-            protocolFeePercentage: NEW_VALUE,
+            protocolSwapFeePercentage: NEW_VALUE,
           });
         });
       });
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-utils/test/ProtocolFees.test.ts pool-utils/test/ProtocolFees.test.ts
--- pool-utils/test/ProtocolFees.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-utils/test/ProtocolFees.test.ts	1969-12-31 16:00:00.000000000 -0800
@@ -1,41 +0,0 @@
-import { Contract } from 'ethers';
-
-import { fp } from '@balancer-labs/v2-helpers/src/numbers';
-import { deploy } from '@balancer-labs/v2-helpers/src/contract';
-import { expect } from 'chai';
-
-describe('ProtocolFees', function () {
-  let mock: Contract;
-
-  sharedBeforeEach(async function () {
-    mock = await deploy('MockProtocolFees');
-  });
-
-  describe('bptForPoolOwnershipPercentage', () => {
-    context('when poolPercentage >= 100%', () => {
-      it('reverts', async () => {
-        await expect(mock.bptForPoolOwnershipPercentage(0, fp(1))).to.be.revertedWith('ZERO_DIVISION');
-        await expect(mock.bptForPoolOwnershipPercentage(fp(1), fp(1))).to.be.revertedWith('ZERO_DIVISION');
-        await expect(mock.bptForPoolOwnershipPercentage(fp(1), fp(1).add(1))).to.be.revertedWith('ZERO_DIVISION');
-        await expect(mock.bptForPoolOwnershipPercentage(fp(1), fp(100))).to.be.revertedWith('ZERO_DIVISION');
-      });
-    });
-
-    context('when poolPercentage == 0%', () => {
-      it('returns zero', async () => {
-        expect(await mock.bptForPoolOwnershipPercentage(0, 0)).to.be.eq(0);
-        expect(await mock.bptForPoolOwnershipPercentage(fp(100), 0)).to.be.eq(0);
-      });
-    });
-
-    context('when poolPercentage < 100%', () => {
-      it('returns the expected value', async () => {
-        expect(await mock.bptForPoolOwnershipPercentage(0, fp(1).sub(1))).to.be.eq(0);
-        expect(await mock.bptForPoolOwnershipPercentage(1, fp(1).sub(1))).to.be.eq(fp(1).sub(1));
-
-        expect(await mock.bptForPoolOwnershipPercentage(fp(1), fp(0.5))).to.be.eq(fp(1));
-        expect(await mock.bptForPoolOwnershipPercentage(fp(1), fp(0.25))).to.be.almostEqual(fp(0.333333333333333333));
-      });
-    });
-  });
-});
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/BaseWeightedPool.sol pool-weighted/contracts/BaseWeightedPool.sol
--- pool-weighted/contracts/BaseWeightedPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/BaseWeightedPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,12 +15,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/BaseMinimalSwapInfoPool.sol";
+import "../../pool-utils/contracts/BaseMinimalSwapInfoPool.sol";
 
 import "./WeightedMath.sol";
 
@@ -107,6 +107,8 @@
         uint256 currentBalanceTokenIn,
         uint256 currentBalanceTokenOut
     ) internal virtual override returns (uint256) {
+        // Swaps are disabled while the contract is paused.
+
         return
             WeightedMath._calcOutGivenIn(
                 currentBalanceTokenIn,
@@ -122,6 +124,8 @@
         uint256 currentBalanceTokenIn,
         uint256 currentBalanceTokenOut
     ) internal virtual override returns (uint256) {
+        // Swaps are disabled while the contract is paused.
+
         return
             WeightedMath._calcInGivenOut(
                 currentBalanceTokenIn,
@@ -133,39 +137,34 @@
     }
 
     /**
-     * @dev Called before any join or exit operation. Returns the Pool's total supply by default, but derived contracts
-     * may choose to add custom behavior at these steps. This often has to do with protocol fee processing.
+     * @dev Called before any join or exit operation. Empty by default, but derived contracts may choose to add custom
+     * behavior at these steps. This often has to do with protocol fee processing.
      */
     function _beforeJoinExit(
-        uint256[] memory, /* preBalances */
-        uint256[] memory /* normalizedWeights */
-    ) internal virtual returns (uint256) {
-        return totalSupply();
+        uint256[] memory preBalances,
+        uint256[] memory normalizedWeights,
+        uint256 protocolSwapFeePercentage
+    ) internal virtual {
+        // solhint-disable-previous-line no-empty-blocks
     }
 
     /**
-     * @dev Called after any regular join or exit operation. Empty by default, but derived contracts
+     * @dev Called after any join or exit operation (including initialization). Empty by default, but derived contracts
      * may choose to add custom behavior at these steps. This often has to do with protocol fee processing.
      *
-     * If performing a join operation, balanceDeltas are the amounts in: otherwise they are the amounts out.
+     * If isJoin is true, balanceDeltas are the amounts in: otherwise they are the amounts out.
      *
      * This function is free to mutate the `preBalances` array.
      */
     function _afterJoinExit(
+        bool isJoin,
         uint256[] memory preBalances,
         uint256[] memory balanceDeltas,
-        uint256[] memory normalizedWeights,
-        uint256 preJoinExitSupply,
-        uint256 postJoinExitSupply
+        uint256[] memory normalizedWeights
     ) internal virtual {
         // solhint-disable-previous-line no-empty-blocks
     }
 
-    // Derived contracts may call this to update state after a join or exit.
-    function _updatePostJoinExit(uint256 postJoinExitInvariant) internal virtual {
-        // solhint-disable-previous-line no-empty-blocks
-    }
-
     // Initialize
 
     function _onInitializePool(
@@ -175,6 +174,9 @@
         uint256[] memory scalingFactors,
         bytes memory userData
     ) internal virtual override returns (uint256, uint256[] memory) {
+        // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent
+        // initialization in this case.
+
         WeightedPoolUserData.JoinKind kind = userData.joinKind();
         _require(kind == WeightedPoolUserData.JoinKind.INIT, Errors.UNINITIALIZED);
 
@@ -189,9 +191,7 @@
         // consistent in Pools with similar compositions but different number of tokens.
         uint256 bptAmountOut = Math.mul(invariantAfterJoin, amountsIn.length);
 
-        // Initialization is still a join, so we need to do post-join work. Since we are not paying protocol fees,
-        // and all we need to do is update the invariant, call `_updatePostJoinExit` here instead of `_afterJoinExit`.
-        _updatePostJoinExit(invariantAfterJoin);
+        _afterJoinExit(true, new uint256[](amountsIn.length), amountsIn, normalizedWeights);
 
         return (bptAmountOut, amountsIn);
     }
@@ -204,24 +204,23 @@
         address,
         uint256[] memory balances,
         uint256,
-        uint256,
+        uint256 protocolSwapFeePercentage,
         uint256[] memory scalingFactors,
         bytes memory userData
     ) internal virtual override returns (uint256, uint256[] memory) {
-        uint256[] memory normalizedWeights = _getNormalizedWeights();
+        // All joins are disabled while the contract is paused.
 
-        uint256 preJoinExitSupply = _beforeJoinExit(balances, normalizedWeights);
+        uint256[] memory normalizedWeights = _getNormalizedWeights();
 
+        _beforeJoinExit(balances, normalizedWeights, protocolSwapFeePercentage);
         (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(
             sender,
             balances,
             normalizedWeights,
             scalingFactors,
-            preJoinExitSupply,
             userData
         );
-
-        _afterJoinExit(balances, amountsIn, normalizedWeights, preJoinExitSupply, preJoinExitSupply.add(bptAmountOut));
+        _afterJoinExit(true, balances, amountsIn, normalizedWeights);
 
         return (bptAmountOut, amountsIn);
     }
@@ -236,17 +235,16 @@
         uint256[] memory balances,
         uint256[] memory normalizedWeights,
         uint256[] memory scalingFactors,
-        uint256 totalSupply,
         bytes memory userData
     ) internal view virtual returns (uint256, uint256[] memory) {
         WeightedPoolUserData.JoinKind kind = userData.joinKind();
 
         if (kind == WeightedPoolUserData.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {
-            return _joinExactTokensInForBPTOut(balances, normalizedWeights, scalingFactors, totalSupply, userData);
+            return _joinExactTokensInForBPTOut(balances, normalizedWeights, scalingFactors, userData);
         } else if (kind == WeightedPoolUserData.JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {
-            return _joinTokenInForExactBPTOut(balances, normalizedWeights, totalSupply, userData);
+            return _joinTokenInForExactBPTOut(balances, normalizedWeights, userData);
         } else if (kind == WeightedPoolUserData.JoinKind.ALL_TOKENS_IN_FOR_EXACT_BPT_OUT) {
-            return _joinAllTokensInForExactBPTOut(balances, totalSupply, userData);
+            return _joinAllTokensInForExactBPTOut(balances, userData);
         } else {
             _revert(Errors.UNHANDLED_JOIN_KIND);
         }
@@ -256,7 +254,6 @@
         uint256[] memory balances,
         uint256[] memory normalizedWeights,
         uint256[] memory scalingFactors,
-        uint256 totalSupply,
         bytes memory userData
     ) private view returns (uint256, uint256[] memory) {
         (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();
@@ -268,7 +265,7 @@
             balances,
             normalizedWeights,
             amountsIn,
-            totalSupply,
+            totalSupply(),
             getSwapFeePercentage()
         );
 
@@ -280,7 +277,6 @@
     function _joinTokenInForExactBPTOut(
         uint256[] memory balances,
         uint256[] memory normalizedWeights,
-        uint256 totalSupply,
         bytes memory userData
     ) private view returns (uint256, uint256[] memory) {
         (uint256 bptAmountOut, uint256 tokenIndex) = userData.tokenInForExactBptOut();
@@ -292,7 +288,7 @@
             balances[tokenIndex],
             normalizedWeights[tokenIndex],
             bptAmountOut,
-            totalSupply,
+            totalSupply(),
             getSwapFeePercentage()
         );
 
@@ -304,15 +300,19 @@
         return (bptAmountOut, amountsIn);
     }
 
-    function _joinAllTokensInForExactBPTOut(
-        uint256[] memory balances,
-        uint256 totalSupply,
-        bytes memory userData
-    ) private pure returns (uint256, uint256[] memory) {
+    function _joinAllTokensInForExactBPTOut(uint256[] memory balances, bytes memory userData)
+        private
+        view
+        returns (uint256, uint256[] memory)
+    {
         uint256 bptAmountOut = userData.allTokensInForExactBptOut();
         // Note that there is no maximum amountsIn parameter: this is handled by `IVault.joinPool`.
 
-        uint256[] memory amountsIn = WeightedMath._calcAllTokensInGivenExactBptOut(balances, bptAmountOut, totalSupply);
+        uint256[] memory amountsIn = WeightedMath._calcAllTokensInGivenExactBptOut(
+            balances,
+            bptAmountOut,
+            totalSupply()
+        );
 
         return (bptAmountOut, amountsIn);
     }
@@ -325,24 +325,25 @@
         address,
         uint256[] memory balances,
         uint256,
-        uint256,
+        uint256 protocolSwapFeePercentage,
         uint256[] memory scalingFactors,
         bytes memory userData
     ) internal virtual override returns (uint256, uint256[] memory) {
-        uint256[] memory normalizedWeights = _getNormalizedWeights();
+        // Exits are not disabled by default while the contract is paused, as some of them remain available to allow LPs
+        // to safely exit the Pool in case of an emergency. Other exit kinds are disabled on a case-by-case basis in
+        // their handlers.
 
-        uint256 preJoinExitSupply = _beforeJoinExit(balances, normalizedWeights);
+        uint256[] memory normalizedWeights = _getNormalizedWeights();
 
+        _beforeJoinExit(balances, normalizedWeights, protocolSwapFeePercentage);
         (uint256 bptAmountIn, uint256[] memory amountsOut) = _doExit(
             sender,
             balances,
             normalizedWeights,
             scalingFactors,
-            preJoinExitSupply,
             userData
         );
-
-        _afterJoinExit(balances, amountsOut, normalizedWeights, preJoinExitSupply, preJoinExitSupply.sub(bptAmountIn));
+        _afterJoinExit(false, balances, amountsOut, normalizedWeights);
 
         return (bptAmountIn, amountsOut);
     }
@@ -357,17 +358,16 @@
         uint256[] memory balances,
         uint256[] memory normalizedWeights,
         uint256[] memory scalingFactors,
-        uint256 totalSupply,
         bytes memory userData
     ) internal view virtual returns (uint256, uint256[] memory) {
         WeightedPoolUserData.ExitKind kind = userData.exitKind();
 
         if (kind == WeightedPoolUserData.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT) {
-            return _exitExactBPTInForTokenOut(balances, normalizedWeights, totalSupply, userData);
+            return _exitExactBPTInForTokenOut(balances, normalizedWeights, userData);
         } else if (kind == WeightedPoolUserData.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {
-            return _exitExactBPTInForTokensOut(balances, totalSupply, userData);
+            return _exitExactBPTInForTokensOut(balances, userData);
         } else if (kind == WeightedPoolUserData.ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {
-            return _exitBPTInForExactTokensOut(balances, normalizedWeights, scalingFactors, totalSupply, userData);
+            return _exitBPTInForExactTokensOut(balances, normalizedWeights, scalingFactors, userData);
         } else {
             _revert(Errors.UNHANDLED_EXIT_KIND);
         }
@@ -376,9 +376,10 @@
     function _exitExactBPTInForTokenOut(
         uint256[] memory balances,
         uint256[] memory normalizedWeights,
-        uint256 totalSupply,
         bytes memory userData
     ) private view returns (uint256, uint256[] memory) {
+        // This exit function is disabled if the contract is paused.
+
         (uint256 bptAmountIn, uint256 tokenIndex) = userData.exactBptInForTokenOut();
         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.
 
@@ -388,7 +389,7 @@
             balances[tokenIndex],
             normalizedWeights[tokenIndex],
             bptAmountIn,
-            totalSupply,
+            totalSupply(),
             getSwapFeePercentage()
         );
 
@@ -401,15 +402,20 @@
         return (bptAmountIn, amountsOut);
     }
 
-    function _exitExactBPTInForTokensOut(
-        uint256[] memory balances,
-        uint256 totalSupply,
-        bytes memory userData
-    ) private pure returns (uint256, uint256[] memory) {
+    function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)
+        private
+        view
+        returns (uint256, uint256[] memory)
+    {
+        // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted
+        // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.
+        // This particular exit function is the only one that remains available because it is the simplest one, and
+        // therefore the one with the lowest likelihood of errors.
+
         uint256 bptAmountIn = userData.exactBptInForTokensOut();
         // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.
 
-        uint256[] memory amountsOut = WeightedMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply);
+        uint256[] memory amountsOut = WeightedMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());
         return (bptAmountIn, amountsOut);
     }
 
@@ -417,9 +423,10 @@
         uint256[] memory balances,
         uint256[] memory normalizedWeights,
         uint256[] memory scalingFactors,
-        uint256 totalSupply,
         bytes memory userData
     ) private view returns (uint256, uint256[] memory) {
+        // This exit function is disabled if the contract is paused.
+
         (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();
         InputHelpers.ensureInputLengthMatch(amountsOut.length, balances.length);
         _upscaleArray(amountsOut, scalingFactors);
@@ -429,11 +436,22 @@
             balances,
             normalizedWeights,
             amountsOut,
-            totalSupply,
+            totalSupply(),
             getSwapFeePercentage()
         );
         _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);
 
         return (bptAmountIn, amountsOut);
     }
+
+    // Helpers
+
+    /**
+     * @dev This function returns the appreciation of one BPT relative to the
+     * underlying tokens. This starts at 1 when the pool is created and grows over time
+     */
+    function getRate() public view returns (uint256) {
+        // The initial BPT supply is equal to the invariant times the number of tokens.
+        return Math.mul(getInvariant(), _getTotalTokens()).divDown(totalSupply());
+    }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/InvariantGrowthProtocolFees.sol pool-weighted/contracts/InvariantGrowthProtocolFees.sol
--- pool-weighted/contracts/InvariantGrowthProtocolFees.sol	1969-12-31 16:00:00.000000000 -0800
+++ pool-weighted/contracts/InvariantGrowthProtocolFees.sol	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "@balancer-labs/v2-pool-utils/contracts/ProtocolFeeCache.sol";
+
+import "./BaseWeightedPool.sol";
+
+abstract contract InvariantGrowthProtocolFees is BaseWeightedPool, ProtocolFeeCache {
+    using FixedPoint for uint256;
+
+    // This Pool pays protocol fees by measuring the growth of the invariant between joins and exits. Since weights are
+    // immutable, the invariant only changes due to accumulated swap fees, which saves gas by freeing the Pool
+    // from performing any computation or accounting associated with protocol fees during swaps.
+    // This mechanism requires keeping track of the invariant after the last join or exit.
+    uint256 private _lastPostJoinExitInvariant;
+
+    /**
+     * @dev Returns the value of the invariant after the last join or exit operation.
+     */
+    function getLastInvariant() public view returns (uint256) {
+        return _lastPostJoinExitInvariant;
+    }
+
+    function _getSwapProtocolFees(
+        uint256[] memory preBalances,
+        uint256[] memory normalizedWeights,
+        uint256 preJoinExitSupply
+    ) internal view returns (uint256) {
+        uint256 protocolSwapFeePercentage = getProtocolFeePercentageCache(ProtocolFeeType.SWAP);
+
+        // We return immediately if the fee percentage is zero to avoid unnecessary computation.
+        if (protocolSwapFeePercentage == 0) return 0;
+
+        // Before joins and exits, we measure the growth of the invariant compared to the invariant after the last join
+        // or exit, which will have been caused by swap fees, and use it to mint BPT as protocol fees. This dilutes all
+        // LPs, which means that new LPs will join the pool debt-free, and exiting LPs will pay any amounts due
+        // before leaving.
+
+        uint256 preJoinExitInvariant = WeightedMath._calculateInvariant(normalizedWeights, preBalances);
+
+        return
+            WeightedMath._calcDueProtocolSwapFeeBptAmount(
+                preJoinExitSupply,
+                _lastPostJoinExitInvariant,
+                preJoinExitInvariant,
+                protocolSwapFeePercentage
+            );
+    }
+
+    function _afterJoinExit(
+        bool isJoin,
+        uint256[] memory preBalances,
+        uint256[] memory balanceDeltas,
+        uint256[] memory normalizedWeights
+    ) internal virtual override {
+        // After all joins and exits we store the post join/exit invariant in order to compute growth due to swap fees
+        // in the next one.
+
+        // Compute the post balances by adding or removing the deltas. Note that we're allowed to mutate preBalances.
+        for (uint256 i = 0; i < preBalances.length; ++i) {
+            preBalances[i] = isJoin
+                ? SafeMath.add(preBalances[i], balanceDeltas[i])
+                : SafeMath.sub(preBalances[i], balanceDeltas[i]);
+        }
+
+        uint256 postJoinExitInvariant = WeightedMath._calculateInvariant(normalizedWeights, preBalances);
+        _lastPostJoinExitInvariant = postJoinExitInvariant;
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/WeightedMath.sol pool-weighted/contracts/WeightedMath.sol
--- pool-weighted/contracts/WeightedMath.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/WeightedMath.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 // These functions start with an underscore, as if they were part of a contract and not a library. At some point this
 // should be fixed.
@@ -406,6 +406,44 @@
         return amountsOut;
     }
 
+    function _calcDueProtocolSwapFeeBptAmount(
+        uint256 totalSupply,
+        uint256 previousInvariant,
+        uint256 currentInvariant,
+        uint256 protocolSwapFeePercentage
+    ) internal pure returns (uint256) {
+        // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol
+        // fees to the Vault.
+        uint256 growth = currentInvariant.divDown(previousInvariant);
+
+        // Shortcut in case there was no growth when comparing the current against the previous invariant.
+        // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool
+        // from entering a locked state in which joins and exits revert while computing accumulated swap fees.
+        if (growth <= FixedPoint.ONE) {
+            return 0;
+        }
+
+        // Assuming the Pool is balanced and token weights have not changed, a growth of the invariant translates into
+        // proportional growth of all token balances. The protocol is due a percentage of that growth: more precisely,
+        // it is due `k = protocol fee * (growth - 1) * balance / growth` for each token.
+        // We compute the amount of BPT to mint for the protocol that would allow it to proportionally exit the Pool and
+        // receive these balances. Note that the total BPT supply will increase when minting, so we need to account for
+        // this in order to compute the percentage of Pool ownership the protocol will have.
+
+        // The formula is:
+        //
+        // toMint = supply * k / (1 - k)
+
+        // We compute protocol fee * (growth - 1) / growth, as we'll use that value twice.
+        // There is no need to use SafeMath since we already checked growth is strictly greater than one.
+        uint256 k = protocolSwapFeePercentage.mulDown(growth - FixedPoint.ONE).divDown(growth);
+
+        uint256 numerator = totalSupply.mulDown(k);
+        uint256 denominator = k.complement();
+
+        return denominator == 0 ? 0 : numerator.divDown(denominator);
+    }
+
     /**
      * @dev Calculate the amount of BPT which should be minted when adding a new token to the Pool.
      *
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/WeightedPool.sol pool-weighted/contracts/WeightedPool.sol
--- pool-weighted/contracts/WeightedPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/WeightedPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -16,15 +16,15 @@
 pragma experimental ABIEncoderV2;
 
 import "./BaseWeightedPool.sol";
-import "./WeightedPoolProtocolFees.sol";
+import "./InvariantGrowthProtocolFees.sol";
 
 /**
  * @dev Basic Weighted Pool with immutable weights.
  */
-contract WeightedPool is BaseWeightedPool, WeightedPoolProtocolFees {
+contract WeightedPool is BaseWeightedPool, InvariantGrowthProtocolFees {
     using FixedPoint for uint256;
 
-    uint256 private constant _MAX_TOKENS = 8;
+    uint256 private constant _MAX_TOKENS = 20;
 
     uint256 private immutable _totalTokens;
 
@@ -36,6 +36,18 @@
     IERC20 internal immutable _token5;
     IERC20 internal immutable _token6;
     IERC20 internal immutable _token7;
+    IERC20 internal immutable _token8;
+    IERC20 internal immutable _token9;
+    IERC20 internal immutable _token10;
+    IERC20 internal immutable _token11;
+    IERC20 internal immutable _token12;
+    IERC20 internal immutable _token13;
+    IERC20 internal immutable _token14;
+    IERC20 internal immutable _token15;
+    IERC20 internal immutable _token16;
+    IERC20 internal immutable _token17;
+    IERC20 internal immutable _token18;
+    IERC20 internal immutable _token19;
 
     // All token balances are normalized to behave as if the token had 18 decimals. We assume a token's decimals will
     // not change throughout its lifetime, and store the corresponding scaling factor for each at construction time.
@@ -49,6 +61,18 @@
     uint256 internal immutable _scalingFactor5;
     uint256 internal immutable _scalingFactor6;
     uint256 internal immutable _scalingFactor7;
+    uint256 internal immutable _scalingFactor8;
+    uint256 internal immutable _scalingFactor9;
+    uint256 internal immutable _scalingFactor10;
+    uint256 internal immutable _scalingFactor11;
+    uint256 internal immutable _scalingFactor12;
+    uint256 internal immutable _scalingFactor13;
+    uint256 internal immutable _scalingFactor14;
+    uint256 internal immutable _scalingFactor15;
+    uint256 internal immutable _scalingFactor16;
+    uint256 internal immutable _scalingFactor17;
+    uint256 internal immutable _scalingFactor18;
+    uint256 internal immutable _scalingFactor19;
 
     uint256 internal immutable _normalizedWeight0;
     uint256 internal immutable _normalizedWeight1;
@@ -58,49 +82,53 @@
     uint256 internal immutable _normalizedWeight5;
     uint256 internal immutable _normalizedWeight6;
     uint256 internal immutable _normalizedWeight7;
-
-    struct NewPoolParams {
-        string name;
-        string symbol;
-        IERC20[] tokens;
-        uint256[] normalizedWeights;
-        IRateProvider[] rateProviders;
-        address[] assetManagers;
-        uint256 swapFeePercentage;
-    }
+    uint256 internal immutable _normalizedWeight8;
+    uint256 internal immutable _normalizedWeight9;
+    uint256 internal immutable _normalizedWeight10;
+    uint256 internal immutable _normalizedWeight11;
+    uint256 internal immutable _normalizedWeight12;
+    uint256 internal immutable _normalizedWeight13;
+    uint256 internal immutable _normalizedWeight14;
+    uint256 internal immutable _normalizedWeight15;
+    uint256 internal immutable _normalizedWeight16;
+    uint256 internal immutable _normalizedWeight17;
+    uint256 internal immutable _normalizedWeight18;
+    uint256 internal immutable _normalizedWeight19;
 
     constructor(
-        NewPoolParams memory params,
         IVault vault,
-        IProtocolFeePercentagesProvider protocolFeeProvider,
+        string memory name,
+        string memory symbol,
+        IERC20[] memory tokens,
+        uint256[] memory normalizedWeights,
+        address[] memory assetManagers,
+        uint256 swapFeePercentage,
         uint256 pauseWindowDuration,
         uint256 bufferPeriodDuration,
         address owner
     )
         BaseWeightedPool(
             vault,
-            params.name,
-            params.symbol,
-            params.tokens,
-            params.assetManagers,
-            params.swapFeePercentage,
+            name,
+            symbol,
+            tokens,
+            assetManagers,
+            swapFeePercentage,
             pauseWindowDuration,
             bufferPeriodDuration,
             owner,
             false
         )
-        ProtocolFeeCache(protocolFeeProvider, ProtocolFeeCache.DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL)
-        WeightedPoolProtocolFees(params.tokens.length, params.rateProviders)
     {
-        uint256 numTokens = params.tokens.length;
-        InputHelpers.ensureInputLengthMatch(numTokens, params.normalizedWeights.length);
+        uint256 numTokens = tokens.length;
+        InputHelpers.ensureInputLengthMatch(numTokens, normalizedWeights.length);
 
         _totalTokens = numTokens;
 
         // Ensure each normalized weight is above the minimum
         uint256 normalizedSum = 0;
         for (uint8 i = 0; i < numTokens; i++) {
-            uint256 normalizedWeight = params.normalizedWeights[i];
+            uint256 normalizedWeight = normalizedWeights[i];
 
             _require(normalizedWeight >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);
             normalizedSum = normalizedSum.add(normalizedWeight);
@@ -108,33 +136,69 @@
         // Ensure that the normalized weights sum to ONE
         _require(normalizedSum == FixedPoint.ONE, Errors.NORMALIZED_WEIGHT_INVARIANT);
 
+        _normalizedWeight0 = normalizedWeights[0];
+        _normalizedWeight1 = normalizedWeights[1];
+        _normalizedWeight2 = numTokens > 2 ? normalizedWeights[2] : 0;
+        _normalizedWeight3 = numTokens > 3 ? normalizedWeights[3] : 0;
+        _normalizedWeight4 = numTokens > 4 ? normalizedWeights[4] : 0;
+        _normalizedWeight5 = numTokens > 5 ? normalizedWeights[5] : 0;
+        _normalizedWeight6 = numTokens > 6 ? normalizedWeights[6] : 0;
+        _normalizedWeight7 = numTokens > 7 ? normalizedWeights[7] : 0;
+        _normalizedWeight8 = numTokens > 8 ? normalizedWeights[8] : 0;
+        _normalizedWeight9 = numTokens > 9 ? normalizedWeights[9] : 0;
+        _normalizedWeight10 = numTokens > 10 ? normalizedWeights[10] : 0;
+        _normalizedWeight11 = numTokens > 11 ? normalizedWeights[11] : 0;
+        _normalizedWeight12 = numTokens > 12 ? normalizedWeights[12] : 0;
+        _normalizedWeight13 = numTokens > 13 ? normalizedWeights[13] : 0;
+        _normalizedWeight14 = numTokens > 14 ? normalizedWeights[14] : 0;
+        _normalizedWeight15 = numTokens > 15 ? normalizedWeights[15] : 0;
+        _normalizedWeight16 = numTokens > 16 ? normalizedWeights[16] : 0;
+        _normalizedWeight17 = numTokens > 17 ? normalizedWeights[17] : 0;
+        _normalizedWeight18 = numTokens > 18 ? normalizedWeights[18] : 0;
+        _normalizedWeight19 = numTokens > 19 ? normalizedWeights[19] : 0;
+
         // Immutable variables cannot be initialized inside an if statement, so we must do conditional assignments
-        _token0 = params.tokens[0];
-        _token1 = params.tokens[1];
-        _token2 = numTokens > 2 ? params.tokens[2] : IERC20(0);
-        _token3 = numTokens > 3 ? params.tokens[3] : IERC20(0);
-        _token4 = numTokens > 4 ? params.tokens[4] : IERC20(0);
-        _token5 = numTokens > 5 ? params.tokens[5] : IERC20(0);
-        _token6 = numTokens > 6 ? params.tokens[6] : IERC20(0);
-        _token7 = numTokens > 7 ? params.tokens[7] : IERC20(0);
-
-        _scalingFactor0 = _computeScalingFactor(params.tokens[0]);
-        _scalingFactor1 = _computeScalingFactor(params.tokens[1]);
-        _scalingFactor2 = numTokens > 2 ? _computeScalingFactor(params.tokens[2]) : 0;
-        _scalingFactor3 = numTokens > 3 ? _computeScalingFactor(params.tokens[3]) : 0;
-        _scalingFactor4 = numTokens > 4 ? _computeScalingFactor(params.tokens[4]) : 0;
-        _scalingFactor5 = numTokens > 5 ? _computeScalingFactor(params.tokens[5]) : 0;
-        _scalingFactor6 = numTokens > 6 ? _computeScalingFactor(params.tokens[6]) : 0;
-        _scalingFactor7 = numTokens > 7 ? _computeScalingFactor(params.tokens[7]) : 0;
-
-        _normalizedWeight0 = params.normalizedWeights[0];
-        _normalizedWeight1 = params.normalizedWeights[1];
-        _normalizedWeight2 = numTokens > 2 ? params.normalizedWeights[2] : 0;
-        _normalizedWeight3 = numTokens > 3 ? params.normalizedWeights[3] : 0;
-        _normalizedWeight4 = numTokens > 4 ? params.normalizedWeights[4] : 0;
-        _normalizedWeight5 = numTokens > 5 ? params.normalizedWeights[5] : 0;
-        _normalizedWeight6 = numTokens > 6 ? params.normalizedWeights[6] : 0;
-        _normalizedWeight7 = numTokens > 7 ? params.normalizedWeights[7] : 0;
+        _token0 = tokens[0];
+        _token1 = tokens[1];
+        _token2 = numTokens > 2 ? tokens[2] : IERC20(0);
+        _token3 = numTokens > 3 ? tokens[3] : IERC20(0);
+        _token4 = numTokens > 4 ? tokens[4] : IERC20(0);
+        _token5 = numTokens > 5 ? tokens[5] : IERC20(0);
+        _token6 = numTokens > 6 ? tokens[6] : IERC20(0);
+        _token7 = numTokens > 7 ? tokens[7] : IERC20(0);
+        _token8 = numTokens > 8 ? tokens[8] : IERC20(0);
+        _token9 = numTokens > 9 ? tokens[9] : IERC20(0);
+        _token10 = numTokens > 10 ? tokens[10] : IERC20(0);
+        _token11 = numTokens > 11 ? tokens[11] : IERC20(0);
+        _token12 = numTokens > 12 ? tokens[12] : IERC20(0);
+        _token13 = numTokens > 13 ? tokens[13] : IERC20(0);
+        _token14 = numTokens > 14 ? tokens[14] : IERC20(0);
+        _token15 = numTokens > 15 ? tokens[15] : IERC20(0);
+        _token16 = numTokens > 16 ? tokens[16] : IERC20(0);
+        _token17 = numTokens > 17 ? tokens[17] : IERC20(0);
+        _token18 = numTokens > 18 ? tokens[18] : IERC20(0);
+        _token19 = numTokens > 19 ? tokens[19] : IERC20(0);
+
+        _scalingFactor0 = _computeScalingFactor(tokens[0]);
+        _scalingFactor1 = _computeScalingFactor(tokens[1]);
+        _scalingFactor2 = numTokens > 2 ? _computeScalingFactor(tokens[2]) : 0;
+        _scalingFactor3 = numTokens > 3 ? _computeScalingFactor(tokens[3]) : 0;
+        _scalingFactor4 = numTokens > 4 ? _computeScalingFactor(tokens[4]) : 0;
+        _scalingFactor5 = numTokens > 5 ? _computeScalingFactor(tokens[5]) : 0;
+        _scalingFactor6 = numTokens > 6 ? _computeScalingFactor(tokens[6]) : 0;
+        _scalingFactor7 = numTokens > 7 ? _computeScalingFactor(tokens[7]) : 0;
+        _scalingFactor8 = numTokens > 8 ? _computeScalingFactor(tokens[8]) : 0;
+        _scalingFactor9 = numTokens > 9 ? _computeScalingFactor(tokens[9]) : 0;
+        _scalingFactor10 = numTokens > 10 ? _computeScalingFactor(tokens[10]) : 0;
+        _scalingFactor11 = numTokens > 11 ? _computeScalingFactor(tokens[11]) : 0;
+        _scalingFactor12 = numTokens > 12 ? _computeScalingFactor(tokens[12]) : 0;
+        _scalingFactor13 = numTokens > 13 ? _computeScalingFactor(tokens[13]) : 0;
+        _scalingFactor14 = numTokens > 14 ? _computeScalingFactor(tokens[14]) : 0;
+        _scalingFactor15 = numTokens > 15 ? _computeScalingFactor(tokens[15]) : 0;
+        _scalingFactor16 = numTokens > 16 ? _computeScalingFactor(tokens[16]) : 0;
+        _scalingFactor17 = numTokens > 17 ? _computeScalingFactor(tokens[17]) : 0;
+        _scalingFactor18 = numTokens > 18 ? _computeScalingFactor(tokens[18]) : 0;
+        _scalingFactor19 = numTokens > 19 ? _computeScalingFactor(tokens[19]) : 0;
     }
 
     function _getNormalizedWeight(IERC20 token) internal view virtual override returns (uint256) {
@@ -147,6 +211,18 @@
         else if (token == _token5) { return _normalizedWeight5; }
         else if (token == _token6) { return _normalizedWeight6; }
         else if (token == _token7) { return _normalizedWeight7; }
+        else if (token == _token8) { return _normalizedWeight8; }
+        else if (token == _token9) { return _normalizedWeight9; }
+        else if (token == _token10) { return _normalizedWeight10; }
+        else if (token == _token11) { return _normalizedWeight11; }
+        else if (token == _token12) { return _normalizedWeight12; }
+        else if (token == _token13) { return _normalizedWeight13; }
+        else if (token == _token14) { return _normalizedWeight14; }
+        else if (token == _token15) { return _normalizedWeight15; }
+        else if (token == _token16) { return _normalizedWeight16; }
+        else if (token == _token17) { return _normalizedWeight17; }
+        else if (token == _token18) { return _normalizedWeight18; }
+        else if (token == _token19) { return _normalizedWeight19; }
         else {
             _revert(Errors.INVALID_TOKEN);
         }
@@ -166,6 +242,18 @@
             if (totalTokens > 5) { normalizedWeights[5] = _normalizedWeight5; } else { return normalizedWeights; }
             if (totalTokens > 6) { normalizedWeights[6] = _normalizedWeight6; } else { return normalizedWeights; }
             if (totalTokens > 7) { normalizedWeights[7] = _normalizedWeight7; } else { return normalizedWeights; }
+            if (totalTokens > 8) { normalizedWeights[8] = _normalizedWeight8; } else { return normalizedWeights; }
+            if (totalTokens > 9) { normalizedWeights[9] = _normalizedWeight9; } else { return normalizedWeights; }
+            if (totalTokens > 10) { normalizedWeights[10] = _normalizedWeight10; } else { return normalizedWeights; }
+            if (totalTokens > 11) { normalizedWeights[11] = _normalizedWeight11; } else { return normalizedWeights; }
+            if (totalTokens > 12) { normalizedWeights[12] = _normalizedWeight12; } else { return normalizedWeights; }
+            if (totalTokens > 13) { normalizedWeights[13] = _normalizedWeight13; } else { return normalizedWeights; }
+            if (totalTokens > 14) { normalizedWeights[14] = _normalizedWeight14; } else { return normalizedWeights; }
+            if (totalTokens > 15) { normalizedWeights[15] = _normalizedWeight15; } else { return normalizedWeights; }
+            if (totalTokens > 16) { normalizedWeights[16] = _normalizedWeight16; } else { return normalizedWeights; }
+            if (totalTokens > 17) { normalizedWeights[17] = _normalizedWeight17; } else { return normalizedWeights; }
+            if (totalTokens > 18) { normalizedWeights[18] = _normalizedWeight18; } else { return normalizedWeights; }
+            if (totalTokens > 19) { normalizedWeights[19] = _normalizedWeight19; } else { return normalizedWeights; }
         }
 
         return normalizedWeights;
@@ -185,14 +273,26 @@
      */
     function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {
         // prettier-ignore
-        if (token == _token0) { return _getScalingFactor0(); }
-        else if (token == _token1) { return _getScalingFactor1(); }
-        else if (token == _token2) { return _getScalingFactor2(); }
-        else if (token == _token3) { return _getScalingFactor3(); }
-        else if (token == _token4) { return _getScalingFactor4(); }
-        else if (token == _token5) { return _getScalingFactor5(); }
-        else if (token == _token6) { return _getScalingFactor6(); }
-        else if (token == _token7) { return _getScalingFactor7(); }
+        if (token == _token0) { return _scalingFactor0; }
+        else if (token == _token1) { return _scalingFactor1; }
+        else if (token == _token2) { return _scalingFactor2; }
+        else if (token == _token3) { return _scalingFactor3; }
+        else if (token == _token4) { return _scalingFactor4; }
+        else if (token == _token5) { return _scalingFactor5; }
+        else if (token == _token6) { return _scalingFactor6; }
+        else if (token == _token7) { return _scalingFactor7; }
+        else if (token == _token8) { return _scalingFactor8; }
+        else if (token == _token9) { return _scalingFactor9; }
+        else if (token == _token10) { return _scalingFactor10; }
+        else if (token == _token11) { return _scalingFactor11; }
+        else if (token == _token12) { return _scalingFactor12; }
+        else if (token == _token13) { return _scalingFactor13; }
+        else if (token == _token14) { return _scalingFactor14; }
+        else if (token == _token15) { return _scalingFactor15; }
+        else if (token == _token16) { return _scalingFactor16; }
+        else if (token == _token17) { return _scalingFactor17; }
+        else if (token == _token18) { return _scalingFactor18; }
+        else if (token == _token19) { return _scalingFactor19; }
         else {
             _revert(Errors.INVALID_TOKEN);
         }
@@ -204,201 +304,47 @@
 
         // prettier-ignore
         {
-            scalingFactors[0] = _getScalingFactor0();
-            scalingFactors[1] = _getScalingFactor1();
-            if (totalTokens > 2) { scalingFactors[2] = _getScalingFactor2(); } else { return scalingFactors; }
-            if (totalTokens > 3) { scalingFactors[3] = _getScalingFactor3(); } else { return scalingFactors; }
-            if (totalTokens > 4) { scalingFactors[4] = _getScalingFactor4(); } else { return scalingFactors; }
-            if (totalTokens > 5) { scalingFactors[5] = _getScalingFactor5(); } else { return scalingFactors; }
-            if (totalTokens > 6) { scalingFactors[6] = _getScalingFactor6(); } else { return scalingFactors; }
-            if (totalTokens > 7) { scalingFactors[7] = _getScalingFactor7(); } else { return scalingFactors; }
+            scalingFactors[0] = _scalingFactor0;
+            scalingFactors[1] = _scalingFactor1;
+            if (totalTokens > 2) { scalingFactors[2] = _scalingFactor2; } else { return scalingFactors; }
+            if (totalTokens > 3) { scalingFactors[3] = _scalingFactor3; } else { return scalingFactors; }
+            if (totalTokens > 4) { scalingFactors[4] = _scalingFactor4; } else { return scalingFactors; }
+            if (totalTokens > 5) { scalingFactors[5] = _scalingFactor5; } else { return scalingFactors; }
+            if (totalTokens > 6) { scalingFactors[6] = _scalingFactor6; } else { return scalingFactors; }
+            if (totalTokens > 7) { scalingFactors[7] = _scalingFactor7; } else { return scalingFactors; }
+            if (totalTokens > 8) { scalingFactors[8] = _scalingFactor8; } else { return scalingFactors; }
+            if (totalTokens > 9) { scalingFactors[9] = _scalingFactor9; } else { return scalingFactors; }
+            if (totalTokens > 10) { scalingFactors[10] = _scalingFactor10; } else { return scalingFactors; }
+            if (totalTokens > 11) { scalingFactors[11] = _scalingFactor11; } else { return scalingFactors; }
+            if (totalTokens > 12) { scalingFactors[12] = _scalingFactor12; } else { return scalingFactors; }
+            if (totalTokens > 13) { scalingFactors[13] = _scalingFactor13; } else { return scalingFactors; }
+            if (totalTokens > 14) { scalingFactors[14] = _scalingFactor14; } else { return scalingFactors; }
+            if (totalTokens > 15) { scalingFactors[15] = _scalingFactor15; } else { return scalingFactors; }
+            if (totalTokens > 16) { scalingFactors[16] = _scalingFactor16; } else { return scalingFactors; }
+            if (totalTokens > 17) { scalingFactors[17] = _scalingFactor17; } else { return scalingFactors; }
+            if (totalTokens > 18) { scalingFactors[18] = _scalingFactor18; } else { return scalingFactors; }
+            if (totalTokens > 19) { scalingFactors[19] = _scalingFactor19; } else { return scalingFactors; }
         }
 
         return scalingFactors;
     }
 
-    // Initialize
-
-    function _onInitializePool(
-        bytes32 poolId,
-        address sender,
-        address recipient,
-        uint256[] memory scalingFactors,
-        bytes memory userData
-    ) internal virtual override returns (uint256, uint256[] memory) {
-        // Initialize `_athRateProduct` if the Pool will pay protocol fees on yield.
-        // Not initializing this here properly will cause all joins/exits to revert.
-        if (!_isExemptFromYieldProtocolFees()) _updateATHRateProduct(_getRateProduct(_getNormalizedWeights()));
-
-        return super._onInitializePool(poolId, sender, recipient, scalingFactors, userData);
-    }
-
-    // WeightedPoolProtocolFees functions
-
-    function _beforeJoinExit(uint256[] memory preBalances, uint256[] memory normalizedWeights)
-        internal
-        virtual
-        override
-        returns (uint256)
-    {
-        uint256 supplyBeforeFeeCollection = totalSupply();
-        uint256 invariant = WeightedMath._calculateInvariant(normalizedWeights, preBalances);
-        (uint256 protocolFeesToBeMinted, uint256 athRateProduct) = _getPreJoinExitProtocolFees(
-            invariant,
-            normalizedWeights,
-            supplyBeforeFeeCollection
-        );
-
-        // We then update the recorded value of `athRateProduct` to ensure we only collect fees on yield once.
-        // A zero value for `athRateProduct` represents that it is unchanged so we can skip updating it.
-        if (athRateProduct > 0) {
-            _updateATHRateProduct(athRateProduct);
-        }
+    // InvariantGrowthProtocolFees
 
-        if (protocolFeesToBeMinted > 0) {
-            _payProtocolFees(protocolFeesToBeMinted);
-        }
-        return supplyBeforeFeeCollection.add(protocolFeesToBeMinted);
+    function _beforeJoinExit(
+        uint256[] memory preBalances,
+        uint256[] memory normalizedWeights,
+        uint256 protocolSwapFeePercentage
+    ) internal virtual override(BaseWeightedPool, InvariantGrowthProtocolFees) {
+        InvariantGrowthProtocolFees._beforeJoinExit(preBalances, normalizedWeights, protocolSwapFeePercentage);
     }
 
     function _afterJoinExit(
+        bool isJoin,
         uint256[] memory preBalances,
         uint256[] memory balanceDeltas,
-        uint256[] memory normalizedWeights,
-        uint256 preJoinExitSupply,
-        uint256 postJoinExitSupply
-    ) internal virtual override {
-        uint256 protocolFeesToBeMinted = _getPostJoinExitProtocolFees(
-            preBalances,
-            balanceDeltas,
-            normalizedWeights,
-            preJoinExitSupply,
-            postJoinExitSupply
-        );
-
-        if (protocolFeesToBeMinted > 0) {
-            _payProtocolFees(protocolFeesToBeMinted);
-        }
-    }
-
-    function _updatePostJoinExit(uint256 postJoinExitInvariant)
-        internal
-        virtual
-        override(BaseWeightedPool, WeightedPoolProtocolFees)
-    {
-        WeightedPoolProtocolFees._updatePostJoinExit(postJoinExitInvariant);
-    }
-
-    function _beforeProtocolFeeCacheUpdate() internal override {
-        // The `getRate()` function depends on the actual supply, which in turn depends on the cached protocol fee
-        // percentages. Changing these would therefore result in the rate changing, which is not acceptable as this is a
-        // sensitive value.
-        // Because of this, we pay any due protocol fees *before* updating the cache, making it so that the new
-        // percentages only affect future operation of the Pool, and not past fees. As a result, `getRate()` is
-        // unaffected by the cached protocol fee percentages changing.
-
-        // Given that this operation is state-changing and relatively complex, we only allow it as long as the Pool is
-        // not paused.
-        _ensureNotPaused();
-
-        uint256 invariant = getInvariant();
-
-        (uint256 protocolFeesToBeMinted, uint256 athRateProduct) = _getPreJoinExitProtocolFees(
-            invariant,
-            _getNormalizedWeights(),
-            totalSupply()
-        );
-
-        if (protocolFeesToBeMinted > 0) {
-            _payProtocolFees(protocolFeesToBeMinted);
-        }
-
-        // With the fees paid, we now store the current invariant and update the ATH rate product (if necessary),
-        // marking the Pool as free of protocol debt.
-
-        _updatePostJoinExit(invariant);
-        if (athRateProduct > 0) {
-            _updateATHRateProduct(athRateProduct);
-        }
-    }
-
-    /**
-     * @notice Returns the effective BPT supply.
-     *
-     * @dev This would be the same as `totalSupply` however the Pool owes debt to the Protocol in the form of unminted
-     * BPT, which will be minted immediately before the next join or exit. We need to take these into account since,
-     * even if they don't yet exist, they will effectively be included in any Pool operation that involves BPT.
-     *
-     * In the vast majority of cases, this function should be used instead of `totalSupply()`.
-     */
-    function getActualSupply() public view returns (uint256) {
-        uint256 supply = totalSupply();
-
-        (uint256 protocolFeesToBeMinted, ) = _getPreJoinExitProtocolFees(
-            getInvariant(),
-            _getNormalizedWeights(),
-            supply
-        );
-
-        return supply.add(protocolFeesToBeMinted);
-    }
-
-    function _onDisableRecoveryMode() internal override {
-        // Update the postJoinExitInvariant to the value of the currentInvariant, zeroing out any protocol swap fees.
-        _updatePostJoinExit(getInvariant());
-
-        // If the Pool has any protocol yield fees accrued then we update the athRateProduct to zero these out.
-        // If the current rate product is less than the athRateProduct then we do not perform this update.
-        // This prevents the Pool from paying protocol fees on the same yield twice if the rate product were to drop.
-        if (!_isExemptFromYieldProtocolFees()) {
-            uint256 athRateProduct = getATHRateProduct();
-            uint256 rateProduct = _getRateProduct(_getNormalizedWeights());
-
-            if (rateProduct > athRateProduct) {
-                _updateATHRateProduct(rateProduct);
-            }
-        }
-    }
-
-    function _getScalingFactor0() internal view returns (uint256) {
-        return _scalingFactor0;
-    }
-
-    function _getScalingFactor1() internal view returns (uint256) {
-        return _scalingFactor1;
-    }
-
-    function _getScalingFactor2() internal view returns (uint256) {
-        return _scalingFactor2;
-    }
-
-    function _getScalingFactor3() internal view returns (uint256) {
-        return _scalingFactor3;
-    }
-
-    function _getScalingFactor4() internal view returns (uint256) {
-        return _scalingFactor4;
-    }
-
-    function _getScalingFactor5() internal view returns (uint256) {
-        return _scalingFactor5;
-    }
-
-    function _getScalingFactor6() internal view returns (uint256) {
-        return _scalingFactor6;
-    }
-
-    function _getScalingFactor7() internal view returns (uint256) {
-        return _scalingFactor7;
-    }
-
-    function _isOwnerOnlyAction(bytes32 actionId)
-        internal
-        view
-        virtual
-        override(BasePool, WeightedPoolProtocolFees)
-        returns (bool)
-    {
-        return super._isOwnerOnlyAction(actionId);
+        uint256[] memory normalizedWeights
+    ) internal virtual override(BaseWeightedPool, InvariantGrowthProtocolFees) {
+        InvariantGrowthProtocolFees._afterJoinExit(isJoin, preBalances, balanceDeltas, normalizedWeights);
     }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/WeightedPoolFactory.sol pool-weighted/contracts/WeightedPoolFactory.sol
--- pool-weighted/contracts/WeightedPoolFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/WeightedPoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,17 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
-import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
 
 import "./WeightedPool.sol";
 
-contract WeightedPoolFactory is BasePoolFactory, FactoryWidePauseWindow {
-    constructor(IVault vault, IProtocolFeePercentagesProvider protocolFeeProvider)
-        BasePoolFactory(vault, protocolFeeProvider, type(WeightedPool).creationCode)
-    {
+contract WeightedPoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {
+    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(WeightedPool).creationCode) {
         // solhint-disable-previous-line no-empty-blocks
     }
 
@@ -37,7 +35,7 @@
         string memory symbol,
         IERC20[] memory tokens,
         uint256[] memory normalizedWeights,
-        IRateProvider[] memory rateProviders,
+        address[] memory assetManagers,
         uint256 swapFeePercentage,
         address owner
     ) external returns (address) {
@@ -51,8 +49,7 @@
                         symbol: symbol,
                         tokens: tokens,
                         normalizedWeights: normalizedWeights,
-                        rateProviders: rateProviders,
-                        assetManagers: new address[](tokens.length), // Don't allow asset managers,
+                        assetManagers: assetManagers,
                         swapFeePercentage: swapFeePercentage
                     }),
                     getVault(),
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/WeightedPoolNoAMFactory.sol pool-weighted/contracts/WeightedPoolNoAMFactory.sol
--- pool-weighted/contracts/WeightedPoolNoAMFactory.sol	1969-12-31 16:00:00.000000000 -0800
+++ pool-weighted/contracts/WeightedPoolNoAMFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-3.0-or-later
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+pragma solidity ^0.7.0;
+pragma experimental ABIEncoderV2;
+
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+
+import "./WeightedPool.sol";
+
+contract WeightedPoolNoAMFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {
+    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(WeightedPool).creationCode) {
+        // solhint-disable-previous-line no-empty-blocks
+    }
+
+    /**
+     * @dev Deploys a new `WeightedPool` without asset managers.
+     */
+    function create(
+        string memory name,
+        string memory symbol,
+        IERC20[] memory tokens,
+        uint256[] memory normalizedWeights,
+        uint256 swapFeePercentage,
+        address owner
+    ) external returns (address) {
+        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();
+
+        return
+            _create(
+                abi.encode(
+                    WeightedPool.NewPoolParams({
+                        name: name,
+                        symbol: symbol,
+                        tokens: tokens,
+                        normalizedWeights: normalizedWeights,
+                        assetManagers: new address[](tokens.length), // Don't allow asset managers,
+                        swapFeePercentage: swapFeePercentage
+                    }),
+                    getVault(),
+                    getProtocolFeePercentagesProvider(),
+                    pauseWindowDuration,
+                    bufferPeriodDuration,
+                    owner
+                )
+            );
+    }
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/WeightedPoolProtocolFees.sol pool-weighted/contracts/WeightedPoolProtocolFees.sol
--- pool-weighted/contracts/WeightedPoolProtocolFees.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/WeightedPoolProtocolFees.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,359 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-pragma experimental ABIEncoderV2;
-
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IRateProvider.sol";
-import "@balancer-labs/v2-pool-utils/contracts/protocol-fees/ProtocolFeeCache.sol";
-import "@balancer-labs/v2-pool-utils/contracts/protocol-fees/InvariantGrowthProtocolSwapFees.sol";
-
-import "./BaseWeightedPool.sol";
-
-abstract contract WeightedPoolProtocolFees is BaseWeightedPool, ProtocolFeeCache {
-    using FixedPoint for uint256;
-    using WordCodec for bytes32;
-
-    // Rate providers are used only for computing yield fees; they do not inform swap/join/exit.
-    IRateProvider internal immutable _rateProvider0;
-    IRateProvider internal immutable _rateProvider1;
-    IRateProvider internal immutable _rateProvider2;
-    IRateProvider internal immutable _rateProvider3;
-    IRateProvider internal immutable _rateProvider4;
-    IRateProvider internal immutable _rateProvider5;
-    IRateProvider internal immutable _rateProvider6;
-    IRateProvider internal immutable _rateProvider7;
-
-    bool internal immutable _exemptFromYieldFees;
-
-    // All-time high value of the weighted product of the pool's token rates. Comparing such weighted products across
-    // time provides a measure of the pool's growth resulting from rate changes. The pool also grows due to swap fees,
-    // but that growth is captured in the invariant; rate growth is not.
-    uint256 private _athRateProduct;
-
-    // This Pool pays protocol fees by measuring the growth of the invariant between joins and exits. Since weights are
-    // immutable, the invariant only changes due to accumulated swap fees, which saves gas by freeing the Pool
-    // from performing any computation or accounting associated with protocol fees during swaps.
-    // This mechanism requires keeping track of the invariant after the last join or exit.
-    //
-    // The maximum value of the invariant is the maximum allowable balance in the Vault (2**112) multiplied by the
-    // largest possible scaling factor (10**18 for a zero decimals token). The largest invariant is then
-    // 2**112 * 10**18 ~= 2**172, which means that to save gas we can place this in BasePool's `_miscData`.
-    uint256 private constant _LAST_POST_JOINEXIT_INVARIANT_OFFSET = 0;
-    uint256 private constant _LAST_POST_JOINEXIT_INVARIANT_BIT_LENGTH = 192;
-
-    constructor(uint256 numTokens, IRateProvider[] memory rateProviders) {
-        _require(numTokens <= 8, Errors.MAX_TOKENS);
-        InputHelpers.ensureInputLengthMatch(numTokens, rateProviders.length);
-
-        _exemptFromYieldFees = _getYieldFeeExemption(rateProviders);
-
-        _rateProvider0 = rateProviders[0];
-        _rateProvider1 = rateProviders[1];
-        _rateProvider2 = numTokens > 2 ? rateProviders[2] : IRateProvider(0);
-        _rateProvider3 = numTokens > 3 ? rateProviders[3] : IRateProvider(0);
-        _rateProvider4 = numTokens > 4 ? rateProviders[4] : IRateProvider(0);
-        _rateProvider5 = numTokens > 5 ? rateProviders[5] : IRateProvider(0);
-        _rateProvider6 = numTokens > 6 ? rateProviders[6] : IRateProvider(0);
-        _rateProvider7 = numTokens > 7 ? rateProviders[7] : IRateProvider(0);
-    }
-
-    function _getYieldFeeExemption(IRateProvider[] memory rateProviders) internal pure returns (bool) {
-        // If we know that no rate providers are set then we can skip yield fees logic.
-        // If any tokens have rate providers, then set `_exemptFromYieldFees` to false, otherwise leave it true.
-        for (uint256 i = 0; i < rateProviders.length; i++) {
-            if (rateProviders[i] != IRateProvider(0)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * @dev Returns whether the pool is exempt from protocol fees on yield.
-     */
-    function _isExemptFromYieldProtocolFees() internal view returns (bool) {
-        return _exemptFromYieldFees;
-    }
-
-    /**
-     * @notice Returns the value of the invariant after the last join or exit operation.
-     */
-    function getLastPostJoinExitInvariant() public view returns (uint256) {
-        return
-            _getMiscData().decodeUint(_LAST_POST_JOINEXIT_INVARIANT_OFFSET, _LAST_POST_JOINEXIT_INVARIANT_BIT_LENGTH);
-    }
-
-    /**
-     * @notice Returns the all time high value for the weighted product of the Pool's tokens' rates.
-     * @dev Yield protocol fees are only charged when this value is exceeded.
-     */
-    function getATHRateProduct() public view returns (uint256) {
-        return _athRateProduct;
-    }
-
-    /**
-     * @dev Returns the rate providers configured for each token (in the same order as registered).
-     */
-    function getRateProviders() external view returns (IRateProvider[] memory) {
-        uint256 totalTokens = _getTotalTokens();
-        IRateProvider[] memory providers = new IRateProvider[](totalTokens);
-
-        // prettier-ignore
-        {
-            providers[0] = _rateProvider0;
-            providers[1] = _rateProvider1;
-            if (totalTokens > 2) { providers[2] = _rateProvider2; } else { return providers; }
-            if (totalTokens > 3) { providers[3] = _rateProvider3; } else { return providers; }
-            if (totalTokens > 4) { providers[4] = _rateProvider4; } else { return providers; }
-            if (totalTokens > 5) { providers[5] = _rateProvider5; } else { return providers; }
-            if (totalTokens > 6) { providers[6] = _rateProvider6; } else { return providers; }
-            if (totalTokens > 7) { providers[7] = _rateProvider7; } else { return providers; }
-        }
-
-        return providers;
-    }
-
-    // Protocol Fees
-
-    /**
-     * @dev Returns the percentage of the Pool's supply which corresponds to protocol fees on swaps accrued by the Pool.
-     * @param preJoinExitInvariant - The Pool's invariant prior to the join/exit *before* minting protocol fees.
-     * @param protocolSwapFeePercentage - The percentage of swap fees which are paid to the protocol.
-     * @return swapProtocolFeesPercentage - The percentage of the Pool which corresponds to protocol fees on swaps.
-     */
-    function _getSwapProtocolFeesPoolPercentage(uint256 preJoinExitInvariant, uint256 protocolSwapFeePercentage)
-        internal
-        view
-        returns (uint256)
-    {
-        // Before joins and exits, we measure the growth of the invariant compared to the invariant after the last join
-        // or exit, which will have been caused by swap fees, and use it to mint BPT as protocol fees. This dilutes all
-        // LPs, which means that new LPs will join the pool debt-free, and exiting LPs will pay any amounts due
-        // before leaving.
-
-        return
-            InvariantGrowthProtocolSwapFees.getProtocolOwnershipPercentage(
-                preJoinExitInvariant.divDown(getLastPostJoinExitInvariant()),
-                FixedPoint.ONE, // Supply has not changed so supplyGrowthRatio = 1
-                protocolSwapFeePercentage
-            );
-    }
-
-    /**
-     * @dev Returns the percentage of the Pool's supply which corresponds to protocol fees on yield accrued by the Pool.
-     * @param normalizedWeights - The Pool's normalized token weights.
-     * @return yieldProtocolFeesPercentage - The percentage of the Pool which corresponds to protocol fees on yield.
-     * @return athRateProduct - The new all-time-high rate product if it has increased, otherwise zero.
-     */
-    function _getYieldProtocolFeesPoolPercentage(uint256[] memory normalizedWeights)
-        internal
-        view
-        returns (uint256, uint256)
-    {
-        if (_isExemptFromYieldProtocolFees()) return (0, 0);
-
-        // Yield manifests in the Pool by individual tokens becoming more valuable, we convert this into comparable
-        // units by applying a rate to get the equivalent balance of non-yield-bearing tokens
-        //
-        // non-yield-bearing balance = rate * yield-bearing balance
-        //                       x'i = ri * xi
-        //
-        // To measure the amount of fees to pay due to yield, we take advantage of the fact that scaling the
-        // Pool's balances results in a scaling factor being applied to the original invariant.
-        //
-        // I(r1 * x1, r2 * x2) = (r1 * x1)^w1 * (r2 * x2)^w2
-        //                     = (r1)^w1 * (r2)^w2 * (x1)^w1 * (x2)^w2
-        //                     = I(r1, r2) * I(x1, x2)
-        //
-        // We then only need to measure the growth of this scaling factor to measure how the value of the BPT token
-        // increases due to yield; we can ignore the invariant calculated from the Pool's balances as these cancel.
-        // We then have the result:
-        //
-        // invariantGrowthRatio = I(r1_new, r2_new) / I(r1_old, r2_old) = rateProduct / athRateProduct
-
-        uint256 athRateProduct = _athRateProduct;
-        uint256 rateProduct = _getRateProduct(normalizedWeights);
-
-        // Only charge yield fees if we've exceeded the all time high of Pool value generated through yield.
-        // i.e. if the Pool makes a loss through the yield strategies then it shouldn't charge fees until it's
-        // been recovered.
-        if (rateProduct <= athRateProduct) return (0, 0);
-
-        return (
-            InvariantGrowthProtocolSwapFees.getProtocolOwnershipPercentage(
-                rateProduct.divDown(athRateProduct),
-                FixedPoint.ONE, // Supply has not changed so supplyGrowthRatio = 1
-                getProtocolFeePercentageCache(ProtocolFeeType.YIELD)
-            ),
-            rateProduct
-        );
-    }
-
-    function _updateATHRateProduct(uint256 rateProduct) internal {
-        _athRateProduct = rateProduct;
-    }
-
-    /**
-     * @dev Returns the amount of BPT to be minted as protocol fees prior to processing a join/exit.
-     * Note that this isn't a view function. This function automatically updates `_athRateProduct`  to ensure that
-     * proper accounting is performed to prevent charging duplicate protocol fees.
-     * @param preJoinExitInvariant - The Pool's invariant prior to the join/exit.
-     * @param normalizedWeights - The Pool's normalized token weights.
-     * @param preJoinExitSupply - The Pool's total supply prior to the join/exit *before* minting protocol fees.
-     * @return protocolFeesToBeMinted -  The amount of BPT to be minted as protocol fees.
-     * @return athRateProduct - The new all-time-high rate product if it has increased, otherwise zero.
-     */
-    function _getPreJoinExitProtocolFees(
-        uint256 preJoinExitInvariant,
-        uint256[] memory normalizedWeights,
-        uint256 preJoinExitSupply
-    ) internal view returns (uint256, uint256) {
-        uint256 protocolSwapFeesPoolPercentage = _getSwapProtocolFeesPoolPercentage(
-            preJoinExitInvariant,
-            getProtocolFeePercentageCache(ProtocolFeeType.SWAP)
-        );
-        (uint256 protocolYieldFeesPoolPercentage, uint256 athRateProduct) = _getYieldProtocolFeesPoolPercentage(
-            normalizedWeights
-        );
-
-        return (
-            ProtocolFees.bptForPoolOwnershipPercentage(
-                preJoinExitSupply,
-                protocolSwapFeesPoolPercentage + protocolYieldFeesPoolPercentage
-            ),
-            athRateProduct
-        );
-    }
-
-    /**
-     * @dev Returns the amount of BPT to be minted to pay protocol fees on swap fees accrued during a join/exit.
-     * Note that this isn't a view function. This function automatically updates `_lastPostJoinExitInvariant` to
-     * ensure that proper accounting is performed to prevent charging duplicate protocol fees.
-     * @param preBalances - The Pool's balances prior to the join/exit.
-     * @param balanceDeltas - The changes to the Pool's balances due to the join/exit.
-     * @param normalizedWeights - The Pool's normalized token weights.
-     * @param preJoinExitSupply - The Pool's total supply prior to the join/exit *after* minting protocol fees.
-     * @param postJoinExitSupply - The Pool's total supply after the join/exit.
-     */
-    function _getPostJoinExitProtocolFees(
-        uint256[] memory preBalances,
-        uint256[] memory balanceDeltas,
-        uint256[] memory normalizedWeights,
-        uint256 preJoinExitSupply,
-        uint256 postJoinExitSupply
-    ) internal returns (uint256) {
-        // We calculate `preJoinExitInvariant` now before we mutate `preBalances` into the post joinExit balances.
-        uint256 preJoinExitInvariant = WeightedMath._calculateInvariant(normalizedWeights, preBalances);
-        bool isJoin = postJoinExitSupply >= preJoinExitSupply;
-
-        // Compute the post balances by adding or removing the deltas.
-        for (uint256 i = 0; i < preBalances.length; ++i) {
-            preBalances[i] = isJoin
-                ? SafeMath.add(preBalances[i], balanceDeltas[i])
-                : SafeMath.sub(preBalances[i], balanceDeltas[i]);
-        }
-
-        // preBalances have now been mutated to reflect the postJoinExit balances.
-        uint256 postJoinExitInvariant = WeightedMath._calculateInvariant(normalizedWeights, preBalances);
-        uint256 protocolSwapFeePercentage = getProtocolFeePercentageCache(ProtocolFeeType.SWAP);
-
-        _updatePostJoinExit(postJoinExitInvariant);
-        // We return immediately if the fee percentage is zero to avoid unnecessary computation.
-        if (protocolSwapFeePercentage == 0) return 0;
-
-        uint256 protocolFeeAmount = InvariantGrowthProtocolSwapFees.calcDueProtocolFees(
-            postJoinExitInvariant.divDown(preJoinExitInvariant),
-            preJoinExitSupply,
-            postJoinExitSupply,
-            protocolSwapFeePercentage
-        );
-
-        return protocolFeeAmount;
-    }
-
-    function _updatePostJoinExit(uint256 postJoinExitInvariant) internal virtual override {
-        // After all joins and exits we store the post join/exit invariant in order to compute growth due to swap fees
-        // in the next one.
-        _setMiscData(
-            _getMiscData().insertUint(
-                postJoinExitInvariant,
-                _LAST_POST_JOINEXIT_INVARIANT_OFFSET,
-                _LAST_POST_JOINEXIT_INVARIANT_BIT_LENGTH
-            )
-        );
-    }
-
-    // Helper functions
-
-    /**
-     * @notice Returns the contribution to the total rate product from a token with the given weight and rate provider.
-     */
-    function _getRateFactor(uint256 normalizedWeight, IRateProvider provider) internal view returns (uint256) {
-        return provider == IRateProvider(0) ? FixedPoint.ONE : provider.getRate().powDown(normalizedWeight);
-    }
-
-    /**
-     * @dev Returns the weighted product of all the token rates.
-     */
-    function _getRateProduct(uint256[] memory normalizedWeights) internal view returns (uint256) {
-        uint256 totalTokens = normalizedWeights.length;
-
-        uint256 rateProduct = FixedPoint.mulDown(
-            _getRateFactor(normalizedWeights[0], _rateProvider0),
-            _getRateFactor(normalizedWeights[1], _rateProvider1)
-        );
-
-        if (totalTokens > 2) {
-            rateProduct = rateProduct.mulDown(_getRateFactor(normalizedWeights[2], _rateProvider2));
-        } else {
-            return rateProduct;
-        }
-        if (totalTokens > 3) {
-            rateProduct = rateProduct.mulDown(_getRateFactor(normalizedWeights[3], _rateProvider3));
-        } else {
-            return rateProduct;
-        }
-        if (totalTokens > 4) {
-            rateProduct = rateProduct.mulDown(_getRateFactor(normalizedWeights[4], _rateProvider4));
-        } else {
-            return rateProduct;
-        }
-        if (totalTokens > 5) {
-            rateProduct = rateProduct.mulDown(_getRateFactor(normalizedWeights[5], _rateProvider5));
-        } else {
-            return rateProduct;
-        }
-        if (totalTokens > 6) {
-            rateProduct = rateProduct.mulDown(_getRateFactor(normalizedWeights[6], _rateProvider6));
-        } else {
-            return rateProduct;
-        }
-        if (totalTokens > 7) {
-            rateProduct = rateProduct.mulDown(_getRateFactor(normalizedWeights[7], _rateProvider7));
-        }
-
-        return rateProduct;
-    }
-
-    function _isOwnerOnlyAction(bytes32 actionId)
-        internal
-        view
-        virtual
-        override(BasePool, BasePoolAuthorization)
-        returns (bool)
-    {
-        return super._isOwnerOnlyAction(actionId);
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/lib/GradualValueChange.sol pool-weighted/contracts/lib/GradualValueChange.sol
--- pool-weighted/contracts/lib/GradualValueChange.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-weighted/contracts/lib/GradualValueChange.sol	2022-09-16 02:18:01.000000000 -0700
@@ -12,8 +12,8 @@
 // You should have received a copy of the GNU General Public License
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 pragma solidity ^0.7.0;
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/lib/WeightCompression.sol pool-weighted/contracts/lib/WeightCompression.sol
--- pool-weighted/contracts/lib/WeightCompression.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-weighted/contracts/lib/WeightCompression.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 /**
  * @dev Library for compressing and decompressing numbers by using smaller types.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/smart/BaseManagedPoolFactory.sol pool-weighted/contracts/smart/BaseManagedPoolFactory.sol
--- pool-weighted/contracts/smart/BaseManagedPoolFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/smart/BaseManagedPoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
-import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
+
+import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
 
 import "./ManagedPool.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/smart/LiquidityBootstrappingPool.sol pool-weighted/contracts/smart/LiquidityBootstrappingPool.sol
--- pool-weighted/contracts/smart/LiquidityBootstrappingPool.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-weighted/contracts/smart/LiquidityBootstrappingPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "../lib/GradualValueChange.sol";
 import "../lib/WeightCompression.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/smart/LiquidityBootstrappingPoolFactory.sol pool-weighted/contracts/smart/LiquidityBootstrappingPoolFactory.sol
--- pool-weighted/contracts/smart/LiquidityBootstrappingPoolFactory.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/smart/LiquidityBootstrappingPoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,17 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/factories/BasePoolFactory.sol";
-import "@balancer-labs/v2-pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
+import "../../pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol";
+import "../../pool-utils/contracts/factories/FactoryWidePauseWindow.sol";
 
 import "./LiquidityBootstrappingPool.sol";
 
-contract LiquidityBootstrappingPoolFactory is BasePoolFactory, FactoryWidePauseWindow {
-    constructor(IVault vault, IProtocolFeePercentagesProvider protocolFeeProvider)
-        BasePoolFactory(vault, protocolFeeProvider, type(LiquidityBootstrappingPool).creationCode)
-    {
+contract LiquidityBootstrappingPoolFactory is BasePoolSplitCodeFactory, FactoryWidePauseWindow {
+    constructor(IVault vault) BasePoolSplitCodeFactory(vault, type(LiquidityBootstrappingPool).creationCode) {
         // solhint-disable-previous-line no-empty-blocks
     }
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/smart/ManagedPool.sol pool-weighted/contracts/smart/ManagedPool.sol
--- pool-weighted/contracts/smart/ManagedPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/smart/ManagedPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,18 +15,16 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-utils/IControlledManagedPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ArrayHelpers.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/protocol-fees/InvariantGrowthProtocolSwapFees.sol";
-import "@balancer-labs/v2-pool-utils/contracts/protocol-fees/ProtocolFeeCache.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/helpers/WordCodec.sol";
+import "../../solidity-utils/contracts/helpers/ArrayHelpers.sol";
+
+import "../../pool-utils/contracts/ProtocolFeeCache.sol";
 
 import "../lib/GradualValueChange.sol";
 import "../lib/WeightCompression.sol";
@@ -56,7 +54,7 @@
  * token counts, rebalancing through token changes, gradual weight or fee updates, fine-grained control of
  * protocol and management fees, allowlisting of LPs, and more.
  */
-contract ManagedPool is BaseWeightedPool, ProtocolFeeCache, ReentrancyGuard, IControlledManagedPool {
+contract ManagedPool is BaseWeightedPool, ProtocolFeeCache, ReentrancyGuard {
     // ManagedPool weights and swap fees can change over time: these periods are expected to be long enough (e.g. days)
     // that any timestamp manipulation would achieve very little.
     // solhint-disable not-rely-on-time
@@ -264,13 +262,6 @@
     }
 
     /**
-     * @notice Returns the timestamp of the last collection of AUM fees.
-     */
-    function getLastAumFeeCollectionTimestamp() external view returns (uint256) {
-        return _lastAumFeeCollectionTimestamp;
-    }
-
-    /**
      * @notice Returns the current value of the swap fee percentage.
      * @dev Computes the current swap fee percentage, which can change every block if a gradual swap fee
      * update is in progress.
@@ -431,7 +422,7 @@
         uint256 startTime,
         uint256 endTime,
         uint256[] memory endWeights
-    ) external override authenticate whenNotPaused nonReentrant {
+    ) external authenticate whenNotPaused nonReentrant {
         (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());
 
         InputHelpers.ensureInputLengthMatch(tokens.length, endWeights.length);
@@ -483,7 +474,7 @@
      * Emits the AllowlistAddressAdded event. This is a permissioned function.
      * @param member - The address to be added to the allowlist.
      */
-    function addAllowedAddress(address member) external override authenticate whenNotPaused {
+    function addAllowedAddress(address member) external authenticate whenNotPaused {
         _require(getMustAllowlistLPs(), Errors.FEATURE_DISABLED);
         _require(!_allowedAddresses[member], Errors.ADDRESS_ALREADY_ALLOWLISTED);
 
@@ -498,7 +489,7 @@
      * is disabled. This is a permissioned function.
      * @param member - The address to be removed from the allowlist.
      */
-    function removeAllowedAddress(address member) external override authenticate whenNotPaused {
+    function removeAllowedAddress(address member) external authenticate whenNotPaused {
         _require(getMustAllowlistLPs(), Errors.FEATURE_DISABLED);
         _require(_allowedAddresses[member], Errors.ADDRESS_NOT_ALLOWLISTED);
 
@@ -513,7 +504,7 @@
      * Emits the MustAllowlistLPsSet event. This is a permissioned function.
      * @param mustAllowlistLPs - The new value of the mustAllowlistLPs flag.
      */
-    function setMustAllowlistLPs(bool mustAllowlistLPs) external override authenticate whenNotPaused {
+    function setMustAllowlistLPs(bool mustAllowlistLPs) external authenticate whenNotPaused {
         _setMustAllowlistLPs(mustAllowlistLPs);
     }
 
@@ -528,7 +519,7 @@
      * @dev Emits the SwapEnabledSet event. This is a permissioned function.
      * @param swapEnabled - The new value of the swap enabled flag.
      */
-    function setSwapEnabled(bool swapEnabled) external override authenticate whenNotPaused {
+    function setSwapEnabled(bool swapEnabled) external authenticate whenNotPaused {
         _setSwapEnabled(swapEnabled);
     }
 
@@ -573,11 +564,6 @@
         uint256 mintAmount,
         address recipient
     ) external authenticate whenNotPaused {
-        // To reduce the complexity of weight interactions, tokens cannot be removed during or before a weight change.
-        // Otherwise we'd have to reason about how changes in the weights of other tokens could affect the pricing
-        // between them and the newly added token, etc.
-        _ensureNoWeightChange();
-
         (IERC20[] memory currentTokens, , ) = getVault().getPoolTokens(getPoolId());
 
         uint256 weightSumAfterAdd = _validateAddToken(currentTokens, normalizedWeight);
@@ -638,6 +624,11 @@
         // Make sure the new token is above the minimum weight.
         _require(normalizedWeight >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);
 
+        // To reduce the complexity of weight interactions, tokens cannot be removed during or before a weight change.
+        // Otherwise we'd have to reason about how changes in the weights of other tokens could affect the pricing
+        // between them and the newly added token, etc.
+        _ensureNoWeightChange();
+
         uint256 numTokens = tokens.length;
         _require(numTokens + 1 <= _getMaxTokens(), Errors.MAX_TOKENS);
 
@@ -648,7 +639,7 @@
         // As we're working with normalized weights, `totalWeight` is equal to 1.
         //
         // We can then easily calculate the new denormalized weight sum by applying this ratio to the old sum.
-        uint256 weightSumAfterAdd = _denormWeightSum.divDown(FixedPoint.ONE - normalizedWeight);
+        uint256 weightSumAfterAdd = _denormWeightSum.mulUp(FixedPoint.ONE.divDown(FixedPoint.ONE - normalizedWeight));
 
         // We want to check if adding this new token results in any tokens falling below the minimum weight limit.
         // Adding a new token could cause one of the other tokens to be pushed below the minimum weight.
@@ -719,15 +710,15 @@
         // This prevents the AUM fee calculation being triggered before the pool contains any assets.
         _require(totalSupply() > 0, Errors.UNINITIALIZED);
 
-        // To reduce the complexity of weight interactions, tokens cannot be removed during or before a weight change.
-        _ensureNoWeightChange();
-
         // Exit the pool, returning the full balance of the token to the recipient
         (IERC20[] memory tokens, uint256[] memory unscaledBalances, ) = getVault().getPoolTokens(getPoolId());
         _require(tokens.length > 2, Errors.MIN_TOKENS);
 
+        // To reduce the complexity of weight interactions, tokens cannot be removed during or before a weight change.
+        _ensureNoWeightChange();
+
         // Reverts if the token does not exist in the pool.
-        uint256 tokenIndex = _findTokenIndex(tokens, token);
+        uint256 tokenIndex = _tokenAddressToIndex(tokens, token);
         uint256 tokenBalance = unscaledBalances[tokenIndex];
         uint256 tokenNormalizedWeight = _getNormalizedWeight(token);
 
@@ -797,12 +788,7 @@
      * Emits the ManagementSwapFeePercentageChanged event. This is a permissioned function.
      * @param managementSwapFeePercentage - The new management swap fee percentage.
      */
-    function setManagementSwapFeePercentage(uint256 managementSwapFeePercentage)
-        external
-        override
-        authenticate
-        whenNotPaused
-    {
+    function setManagementSwapFeePercentage(uint256 managementSwapFeePercentage) external authenticate whenNotPaused {
         _setManagementSwapFeePercentage(managementSwapFeePercentage);
     }
 
@@ -826,7 +812,6 @@
      */
     function setManagementAumFeePercentage(uint256 managementAumFeePercentage)
         external
-        override
         authenticate
         whenNotPaused
         returns (uint256 amount)
@@ -834,9 +819,8 @@
         // We want to prevent the pool manager from retroactively increasing the amount of AUM fees payable.
         // To prevent this, we perform a collection before updating the fee percentage.
         // This is only necessary if the pool has been initialized (which is indicated by a nonzero total supply).
-        uint256 supplyBeforeFeeCollection = totalSupply();
-        if (supplyBeforeFeeCollection > 0) {
-            (, amount) = _collectAumManagementFees(supplyBeforeFeeCollection);
+        if (totalSupply() > 0) {
+            amount = _collectAumManagementFees();
         }
 
         _setManagementAumFeePercentage(managementAumFeePercentage);
@@ -858,15 +842,13 @@
      * joins and exits.
      * @return The amount of BPT minted to the manager.
      */
-    function collectAumManagementFees() external override whenNotPaused returns (uint256) {
+    function collectAumManagementFees() external whenNotPaused returns (uint256) {
         // It only makes sense to collect AUM fees after the pool is initialized (as before then the AUM is zero).
         // We can query if the pool is initialized by checking for a nonzero total supply.
         // Reverting here prevents zero value AUM fee collections causing bogus events.
-        uint256 supplyBeforeFeeCollection = totalSupply();
-        if (supplyBeforeFeeCollection == 0) _revert(Errors.UNINITIALIZED);
+        if (totalSupply() == 0) _revert(Errors.UNINITIALIZED);
 
-        (, uint256 managerAUMFees) = _collectAumManagementFees(supplyBeforeFeeCollection);
-        return managerAUMFees;
+        return _collectAumManagementFees();
     }
 
     function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {
@@ -937,26 +919,21 @@
     ) internal virtual override returns (uint256) {
         _require(getSwapEnabled(), Errors.SWAPS_DISABLED);
 
+        (uint256[] memory normalizedWeights, uint256[] memory preSwapBalances) = _getWeightsAndPreSwapBalances(
+            swapRequest,
+            currentBalanceTokenIn,
+            currentBalanceTokenOut
+        );
+
         // balances (and swapRequest.amount) are already upscaled by BaseMinimalSwapInfoPool.onSwap
         uint256 amountOut = super._onSwapGivenIn(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);
 
-        // We can calculate the invariant growth ratio more easily using the ratios of the Pool's balances before and
-        // after the trade.
-        //
-        // invariantGrowthRatio = invariant after trade / invariant before trade
-        //                      = (x + a_in)^w1 * (y - a_out)^w2 / (x^w1 * y^w2)
-        //                      = (1 + a_in/x)^w1 * (1 - a_out/y)^w2
-        uint256[] memory normalizedWeights = ArrayHelpers.arrayFill(
-            _getNormalizedWeight(swapRequest.tokenIn),
-            _getNormalizedWeight(swapRequest.tokenOut)
-        );
-        uint256[] memory balanceRatios = ArrayHelpers.arrayFill(
-            FixedPoint.ONE.add(_addSwapFeeAmount(swapRequest.amount).divDown(currentBalanceTokenIn)),
-            FixedPoint.ONE.sub(amountOut.divDown(currentBalanceTokenOut))
+        uint256[] memory postSwapBalances = ArrayHelpers.arrayFill(
+            currentBalanceTokenIn.add(_addSwapFeeAmount(swapRequest.amount)),
+            currentBalanceTokenOut.sub(amountOut)
         );
 
-        uint256 invariantGrowthRatio = WeightedMath._calculateInvariant(normalizedWeights, balanceRatios);
-        _payProtocolAndManagementFees(invariantGrowthRatio);
+        _payProtocolAndManagementFees(normalizedWeights, preSwapBalances, postSwapBalances);
 
         return amountOut;
     }
@@ -968,31 +945,45 @@
     ) internal virtual override returns (uint256) {
         _require(getSwapEnabled(), Errors.SWAPS_DISABLED);
 
+        (uint256[] memory normalizedWeights, uint256[] memory preSwapBalances) = _getWeightsAndPreSwapBalances(
+            swapRequest,
+            currentBalanceTokenIn,
+            currentBalanceTokenOut
+        );
+
         // balances (and swapRequest.amount) are already upscaled by BaseMinimalSwapInfoPool.onSwap
         uint256 amountIn = super._onSwapGivenOut(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);
 
-        // We can calculate the invariant growth ratio more easily using the ratios of the Pool's balances before and
-        // after the trade.
-        //
-        // invariantGrowthRatio = invariant after trade / invariant before trade
-        //                      = (x + a_in)^w1 * (y - a_out)^w2 / (x^w1 * y^w2)
-        //                      = (1 + a_in/x)^w1 * (1 - a_out/y)^w2
-        uint256[] memory balanceRatios = ArrayHelpers.arrayFill(
-            FixedPoint.ONE.add(_addSwapFeeAmount(amountIn).divDown(currentBalanceTokenIn)),
-            FixedPoint.ONE.sub(swapRequest.amount.divDown(currentBalanceTokenOut))
+        uint256[] memory postSwapBalances = ArrayHelpers.arrayFill(
+            currentBalanceTokenIn.add(_addSwapFeeAmount(amountIn)),
+            currentBalanceTokenOut.sub(swapRequest.amount)
         );
+
+        _payProtocolAndManagementFees(normalizedWeights, preSwapBalances, postSwapBalances);
+
+        return amountIn;
+    }
+
+    function _getWeightsAndPreSwapBalances(
+        SwapRequest memory swapRequest,
+        uint256 currentBalanceTokenIn,
+        uint256 currentBalanceTokenOut
+    ) private view returns (uint256[] memory, uint256[] memory) {
         uint256[] memory normalizedWeights = ArrayHelpers.arrayFill(
             _getNormalizedWeight(swapRequest.tokenIn),
             _getNormalizedWeight(swapRequest.tokenOut)
         );
 
-        uint256 invariantGrowthRatio = WeightedMath._calculateInvariant(normalizedWeights, balanceRatios);
-        _payProtocolAndManagementFees(invariantGrowthRatio);
+        uint256[] memory preSwapBalances = ArrayHelpers.arrayFill(currentBalanceTokenIn, currentBalanceTokenOut);
 
-        return amountIn;
+        return (normalizedWeights, preSwapBalances);
     }
 
-    function _payProtocolAndManagementFees(uint256 invariantGrowthRatio) private {
+    function _payProtocolAndManagementFees(
+        uint256[] memory normalizedWeights,
+        uint256[] memory preSwapBalances,
+        uint256[] memory postSwapBalances
+    ) private {
         // Calculate total BPT for the protocol and management fee
         // The management fee percentage applies to the remainder,
         // after the protocol fee has been collected.
@@ -1009,14 +1000,11 @@
             (FixedPoint.ONE - protocolSwapFeePercentage).mulDown(managementSwapFeePercentage);
 
         // No other balances are changing, so the other terms in the invariant will cancel out
-        // when computing the ratio. So this partial invariant calculation is sufficient.
-        // We pass the same value for total supply twice as we're measuring over a period in which the total supply
-        // has not changed.
-        uint256 supply = totalSupply();
-        uint256 totalBptAmount = InvariantGrowthProtocolSwapFees.calcDueProtocolFees(
-            invariantGrowthRatio,
-            supply,
-            supply,
+        // when computing the ratio. So this partial invariant calculation is sufficient
+        uint256 totalBptAmount = WeightedMath._calcDueProtocolSwapFeeBptAmount(
+            totalSupply(),
+            WeightedMath._calculateInvariant(normalizedWeights, preSwapBalances),
+            WeightedMath._calculateInvariant(normalizedWeights, postSwapBalances),
             totalFeePercentage
         );
 
@@ -1045,7 +1033,6 @@
         uint256[] memory balances,
         uint256[] memory normalizedWeights,
         uint256[] memory scalingFactors,
-        uint256 totalSupply,
         bytes memory userData
     ) internal view override returns (uint256, uint256[] memory) {
         // If swaps are disabled, only proportional joins are allowed. All others involve implicit swaps, and alter
@@ -1066,7 +1053,7 @@
             // Check allowlist for LPs, if applicable
             _require(isAllowedAddress(sender), Errors.ADDRESS_NOT_ALLOWLISTED);
 
-            return super._doJoin(sender, balances, normalizedWeights, scalingFactors, totalSupply, userData);
+            return super._doJoin(sender, balances, normalizedWeights, scalingFactors, userData);
         }
     }
 
@@ -1098,7 +1085,6 @@
         uint256[] memory balances,
         uint256[] memory normalizedWeights,
         uint256[] memory scalingFactors,
-        uint256 totalSupply,
         bytes memory userData
     ) internal view override returns (uint256, uint256[] memory) {
         // If swaps are disabled, only proportional exits are allowed. All others involve implicit swaps, and alter
@@ -1116,7 +1102,7 @@
         return
             kind == WeightedPoolUserData.ExitKind.REMOVE_TOKEN
                 ? _doExitRemoveToken(sender, balances, userData)
-                : super._doExit(sender, balances, normalizedWeights, scalingFactors, totalSupply, userData);
+                : super._doExit(sender, balances, normalizedWeights, scalingFactors, userData);
     }
 
     function _doExitRemoveToken(
@@ -1142,21 +1128,15 @@
         return (bptAmountIn, amountsOut);
     }
 
-    /**
-     * @dev We cannot use the default RecoveryMode implementation here, since we need to prevent AUM fee collection.
-     */
-    function _doRecoveryModeExit(
-        uint256[] memory balances,
-        uint256 totalSupply,
-        bytes memory userData
-    ) internal virtual override returns (uint256, uint256[] memory) {
-        // Recovery mode exits bypass the AUM fee calculation which means that in the case where the Pool is paused and
-        // in Recovery mode for a period of time and then later returns to normal operation then AUM fees will be
-        // charged to the remaining LPs for the full period. We then update the collection timestamp on Recovery mode
-        // exits so that no AUM fees are accrued over this period.
-        _lastAumFeeCollectionTimestamp = block.timestamp;
+    function _tokenAddressToIndex(IERC20[] memory tokens, IERC20 token) internal pure returns (uint256) {
+        uint256 tokensLength = tokens.length;
+        for (uint256 i = 0; i < tokensLength; i++) {
+            if (tokens[i] == token) {
+                return i;
+            }
+        }
 
-        return super._doRecoveryModeExit(balances, totalSupply, userData);
+        _revert(Errors.INVALID_TOKEN);
     }
 
     /**
@@ -1295,72 +1275,88 @@
 
     // Join/exit callbacks
 
-    function _beforeJoinExit(uint256[] memory, uint256[] memory) internal virtual override returns (uint256) {
+    function _beforeJoinExit(uint256[] memory, uint256[] memory) internal virtual override {
         // The AUM fee calculation is based on inflating the Pool's BPT supply by a target rate.
         // We then must collect AUM fees whenever joining or exiting the pool to ensure that LPs only pay AUM fees
         // for the period during which they are an LP within the pool: otherwise an LP could shift their share of the
         // AUM fees onto the remaining LPs in the pool by exiting before they were paid.
-        uint256 supplyBeforeFeeCollection = totalSupply();
-        (uint256 protocolAUMFees, uint256 managerAUMFees) = _collectAumManagementFees(supplyBeforeFeeCollection);
-        return supplyBeforeFeeCollection.add(protocolAUMFees + managerAUMFees);
+        _collectAumManagementFees();
     }
 
     /**
      * @dev Calculates the AUM fees accrued since the last collection and pays it to the pool manager.
      * This function is called automatically on joins and exits.
      */
-    function _collectAumManagementFees(uint256 totalSupply) internal returns (uint256, uint256) {
+    function _collectAumManagementFees() internal returns (uint256 bptAmount) {
         uint256 lastCollection = _lastAumFeeCollectionTimestamp;
         uint256 currentTime = block.timestamp;
 
-        // If no time has passed since the last join/exit we've already collected fees so we can return early.
-        if (currentTime <= lastCollection) return (0, 0);
-
-        // Reset the collection timer to the current block
-        _lastAumFeeCollectionTimestamp = currentTime;
-
-        uint256 managementAumFeePercentage = getManagementAumFeePercentage();
-
-        // If `lastCollection` has not been set then we don't know what period over which to collect fees.
-        // We then perform an early return after initializing it so that we can collect fees next time. This
-        // means that AUM fees are not collected for any tokens the Pool is initialized with until the first
-        // non-initialization join or exit.
-        // We also perform an early return if the AUM fee is zero, to save gas.
-        if (managementAumFeePercentage == 0 || lastCollection == 0) {
-            return (0, 0);
-        }
-
-        // We want to collect fees so that the manager will receive `managementAumFeePercentage` percent of the Pool's
-        // AUM after a year. We compute the amount of BPT to mint for the manager that would allow it to proportionally
-        // exit the Pool and receive this fraction of the Pool's assets.
-        uint256 annualizedFee = ProtocolFees.bptForPoolOwnershipPercentage(totalSupply, managementAumFeePercentage);
-
-        // This value is annualized: in normal operation we will collect fees regularly over the course of the year.
-        // We then multiply this value by the fraction of the year which has elapsed since we last collected fees.
-        uint256 elapsedTime = currentTime - lastCollection;
-        uint256 bptAmount = Math.divDown(Math.mul(annualizedFee, elapsedTime), 365 days);
+        // Collect fees based on the time elapsed
+        if (currentTime > lastCollection) {
+            // Reset the collection timer to the current block
+            _lastAumFeeCollectionTimestamp = currentTime;
+
+            uint256 managementAumFeePercentage = getManagementAumFeePercentage();
+
+            // If `lastCollection` has not been set then we don't know what period over which to collect fees.
+            // We then perform an early return after initializing it so that we can collect fees next time. This
+            // means that AUM fees are not collected for any tokens the Pool is initialized with until the first
+            // non-initialization join or exit.
+            // We also perform an early return if the AUM fee is zero, to save gas.
+            if (managementAumFeePercentage == 0 || lastCollection == 0) {
+                return 0;
+            }
 
-        // Compute the protocol's share of the AUM fee
-        uint256 protocolBptAmount = bptAmount.mulUp(getProtocolFeePercentageCache(ProtocolFeeType.AUM));
-        uint256 managerBPTAmount = bptAmount.sub(protocolBptAmount);
+            // We want to collect fees so that the manager will receive `f` percent of the Pool's AUM after a year.
+            // We compute the amount of BPT to mint for the manager that would allow it to proportionally exit the Pool
+            // and receive this fraction of the Pool's assets.
+            // Note that the total BPT supply will increase when minting, so we need to account for this
+            // in order to compute the percentage of Pool ownership the manager will have.
+
+            // The formula can be derived from:
+            //
+            // f = toMint / (supply + toMint)
+            //
+            // which can be rearranged into:
+            //
+            // toMint = supply * f / (1 - f)
+            uint256 annualizedFee = totalSupply().mulDown(managementAumFeePercentage).divDown(
+                managementAumFeePercentage.complement()
+            );
 
-        _payProtocolFees(protocolBptAmount);
+            // This value is annualized: in normal operation we will collect fees regularly over the course of the year.
+            // We then multiply this value by the fraction of the year which has elapsed since we last collected fees.
+            uint256 elapsedTime = currentTime - lastCollection;
+            uint256 fractionalTimePeriod = elapsedTime.divDown(365 days);
+            bptAmount = annualizedFee.mulDown(fractionalTimePeriod);
+
+            // Compute the protocol's share of the AUM fee
+            uint256 protocolBptAmount = bptAmount.mulUp(getProtocolFeePercentageCache(ProtocolFeeType.AUM));
+            uint256 managerBPTAmount = bptAmount.sub(protocolBptAmount);
 
-        emit ManagementAumFeeCollected(managerBPTAmount);
+            _payProtocolFees(protocolBptAmount);
 
-        _mintPoolTokens(getOwner(), managerBPTAmount);
+            emit ManagementAumFeeCollected(managerBPTAmount);
 
-        return (protocolBptAmount, managerBPTAmount);
+            _mintPoolTokens(getOwner(), managerBPTAmount);
+        }
     }
 
-    // Recovery Mode
-
-    function _onDisableRecoveryMode() internal override {
+    /**
+     * @dev We cannot use the default RecoveryMode implementation here, since we need to prevent AUM fee collection.
+     */
+    function _doRecoveryModeExit(
+        uint256[] memory balances,
+        uint256 totalSupply,
+        bytes memory userData
+    ) internal virtual override returns (uint256, uint256[] memory) {
         // Recovery mode exits bypass the AUM fee calculation which means that in the case where the Pool is paused and
         // in Recovery mode for a period of time and then later returns to normal operation then AUM fees will be
-        // charged to the remaining LPs for the full period. We then update the collection timestamp so that no AUM fees
-        // are accrued over this period.
+        // charged to the remaining LPs for the full period. We then update the collection timestamp on Recovery mode
+        // exits so that no AUM fees are accrued over this period.
         _lastAumFeeCollectionTimestamp = block.timestamp;
+
+        return super._doRecoveryModeExit(balances, totalSupply, userData);
     }
 
     // Functions that convert weights between internal (denormalized) and external (normalized) representations
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/smart/ManagedPoolFactory.sol pool-weighted/contracts/smart/ManagedPoolFactory.sol
--- pool-weighted/contracts/smart/ManagedPoolFactory.sol	2022-06-22 10:15:28.000000000 -0700
+++ pool-weighted/contracts/smart/ManagedPoolFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-pool-utils/contracts/controllers/ManagedPoolController.sol";
+import "../../pool-utils/contracts/controllers/ManagedPoolController.sol";
 
 import "./BaseManagedPoolFactory.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/test/MockWeightedMath.sol pool-weighted/contracts/test/MockWeightedMath.sol
--- pool-weighted/contracts/test/MockWeightedMath.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/test/MockWeightedMath.sol	2022-09-16 02:18:01.000000000 -0700
@@ -118,4 +118,19 @@
                 swapFee
             );
     }
+
+    function calculateDueProtocolSwapFeeBPTAmount(
+        uint256 totalSupply,
+        uint256 previousInvariant,
+        uint256 currentInvariant,
+        uint256 protocolSwapFeePercentage
+    ) external pure returns (uint256) {
+        return
+            WeightedMath._calcDueProtocolSwapFeeBptAmount(
+                totalSupply,
+                previousInvariant,
+                currentInvariant,
+                protocolSwapFeePercentage
+            );
+    }
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/test/MockWeightedPool.sol pool-weighted/contracts/test/MockWeightedPool.sol
--- pool-weighted/contracts/test/MockWeightedPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/test/MockWeightedPool.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,35 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-pragma experimental ABIEncoderV2;
-
-import "../WeightedPool.sol";
-
-contract MockWeightedPool is WeightedPool {
-    constructor(
-        NewPoolParams memory params,
-        IVault vault,
-        IProtocolFeePercentagesProvider protocolFeeProvider,
-        uint256 pauseWindowDuration,
-        uint256 bufferPeriodDuration,
-        address owner
-    ) WeightedPool(params, vault, protocolFeeProvider, pauseWindowDuration, bufferPeriodDuration, owner) {
-        // solhint-disable-previous-line no-empty-blocks
-    }
-
-    function isOwnerOnlyAction(bytes32 actionId) external view returns (bool) {
-        return _isOwnerOnlyAction(actionId);
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/contracts/test/MockWeightedPoolProtocolFees.sol pool-weighted/contracts/test/MockWeightedPoolProtocolFees.sol
--- pool-weighted/contracts/test/MockWeightedPoolProtocolFees.sol	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/contracts/test/MockWeightedPoolProtocolFees.sol	1969-12-31 16:00:00.000000000 -0800
@@ -1,154 +0,0 @@
-// SPDX-License-Identifier: GPL-3.0-or-later
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-pragma solidity ^0.7.0;
-pragma experimental ABIEncoderV2;
-
-import "../WeightedPoolProtocolFees.sol";
-
-contract MockWeightedPoolProtocolFees is WeightedPoolProtocolFees {
-    uint256 private immutable _totalTokens;
-
-    constructor(
-        IVault vault,
-        IProtocolFeePercentagesProvider protocolFeeProvider,
-        string memory name,
-        string memory symbol,
-        IERC20[] memory tokens,
-        IRateProvider[] memory rateProviders,
-        address[] memory assetManagers,
-        uint256 swapFeePercentage,
-        uint256 pauseWindowDuration,
-        uint256 bufferPeriodDuration,
-        address owner
-    )
-        BaseWeightedPool(
-            vault,
-            name,
-            symbol,
-            tokens,
-            assetManagers,
-            swapFeePercentage,
-            pauseWindowDuration,
-            bufferPeriodDuration,
-            owner,
-            false
-        )
-        ProtocolFeeCache(protocolFeeProvider, ProtocolFeeCache.DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL)
-        WeightedPoolProtocolFees(tokens.length, rateProviders)
-    {
-        _totalTokens = tokens.length;
-    }
-
-    function getYieldFeeExemption(IRateProvider[] memory rateProviders) external pure returns (bool) {
-        return _getYieldFeeExemption(rateProviders);
-    }
-
-    function getRateProduct(uint256[] memory normalizedWeights) external view returns (uint256) {
-        return _getRateProduct(normalizedWeights);
-    }
-
-    function updateATHRateProduct(uint256 rateProduct) external {
-        _updateATHRateProduct(rateProduct);
-    }
-
-    function getYieldProtocolFee(uint256[] memory normalizedWeights, uint256 supply)
-        external
-        view
-        returns (uint256 yieldProtocolFees, uint256 athRateProduct)
-    {
-        uint256 protocolYieldFeesPoolPercentage;
-        (protocolYieldFeesPoolPercentage, athRateProduct) = _getYieldProtocolFeesPoolPercentage(normalizedWeights);
-        yieldProtocolFees = ProtocolFees.bptForPoolOwnershipPercentage(supply, protocolYieldFeesPoolPercentage);
-    }
-
-    function getPostJoinExitProtocolFees(
-        uint256[] memory preBalances,
-        uint256[] memory balanceDeltas,
-        uint256[] memory normalizedWeights,
-        uint256 preJoinExitSupply,
-        uint256 postJoinExitSupply
-    ) external returns (uint256) {
-        return
-            _getPostJoinExitProtocolFees(
-                preBalances,
-                balanceDeltas,
-                normalizedWeights,
-                preJoinExitSupply,
-                postJoinExitSupply
-            );
-    }
-
-    // Stubbed functions
-
-    function _getMaxTokens() internal pure override returns (uint256) {
-        return 8;
-    }
-
-    function _getTotalTokens() internal view virtual override returns (uint256) {
-        return _totalTokens;
-    }
-
-    function _getNormalizedWeight(IERC20) internal pure override returns (uint256) {
-        revert("NOT_IMPLEMENTED");
-    }
-
-    function _getNormalizedWeights() internal pure override returns (uint256[] memory) {
-        revert("NOT_IMPLEMENTED");
-    }
-
-    function _scalingFactor(IERC20) internal pure override returns (uint256) {
-        revert("NOT_IMPLEMENTED");
-    }
-
-    function _scalingFactors() internal pure override returns (uint256[] memory) {
-        revert("NOT_IMPLEMENTED");
-    }
-
-    function _onInitializePool(
-        bytes32,
-        address,
-        address,
-        uint256[] memory,
-        bytes memory
-    ) internal pure override returns (uint256, uint256[] memory) {
-        revert("NOT_IMPLEMENTED");
-    }
-
-    function _onJoinPool(
-        bytes32,
-        address,
-        address,
-        uint256[] memory,
-        uint256,
-        uint256,
-        uint256[] memory,
-        bytes memory
-    ) internal pure override returns (uint256, uint256[] memory) {
-        revert("NOT_IMPLEMENTED");
-    }
-
-    function _onExitPool(
-        bytes32,
-        address,
-        address,
-        uint256[] memory,
-        uint256,
-        uint256,
-        uint256[] memory,
-        bytes memory
-    ) internal pure override returns (uint256, uint256[] memory) {
-        revert("NOT_IMPLEMENTED");
-    }
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/BaseWeightedPool.behavior.ts pool-weighted/test/BaseWeightedPool.behavior.ts
--- pool-weighted/test/BaseWeightedPool.behavior.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/test/BaseWeightedPool.behavior.ts	2022-09-16 02:18:01.000000000 -0700
@@ -3,12 +3,11 @@
 import { BigNumber } from 'ethers';
 import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signer-with-address';
 import { ManagedPoolEncoder, PoolSpecialization, SwapKind } from '@balancer-labs/balancer-js';
-import { BigNumberish, bn, fp, fpMul, pct } from '@balancer-labs/v2-helpers/src/numbers';
+import { BigNumberish, bn, fp, pct } from '@balancer-labs/v2-helpers/src/numbers';
 
 import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
 import WeightedPool from '@balancer-labs/v2-helpers/src/models/pools/weighted/WeightedPool';
 import { RawWeightedPoolDeployment, WeightedPoolType } from '@balancer-labs/v2-helpers/src/models/pools/weighted/types';
-import { ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
 
 export function itBehavesAsWeightedPool(
   numberOfTokens: number,
@@ -18,7 +17,7 @@
   const WEIGHTS = [fp(30), fp(70), fp(5), fp(5)];
   const INITIAL_BALANCES = [fp(0.9), fp(1.8), fp(2.7), fp(3.6)];
 
-  let recipient: SignerWithAddress, other: SignerWithAddress, lp: SignerWithAddress;
+  let recipient: SignerWithAddress, other: SignerWithAddress, lp: SignerWithAddress, assetManager: SignerWithAddress;
 
   let pool: WeightedPool, allTokens: TokenList, tokens: TokenList;
 
@@ -27,17 +26,18 @@
   const initialBalances = INITIAL_BALANCES.slice(0, numberOfTokens);
 
   async function deployPool(params: RawWeightedPoolDeployment = {}): Promise<void> {
-    pool = await WeightedPool.create({
-      tokens,
-      weights,
-      swapFeePercentage: POOL_SWAP_FEE_PERCENTAGE,
-      poolType,
-      ...params,
-    });
+    const assetManagers = Array(numberOfTokens).fill(assetManager.address);
+
+    params = Object.assign(
+      {},
+      { tokens, weights, assetManagers, swapFeePercentage: POOL_SWAP_FEE_PERCENTAGE, poolType },
+      params
+    );
+    pool = await WeightedPool.create(params);
   }
 
   before('setup signers', async () => {
-    [, lp, recipient, other] = await ethers.getSigners();
+    [, lp, recipient, other, assetManager] = await ethers.getSigners();
   });
 
   sharedBeforeEach('deploy tokens', async () => {
@@ -79,10 +79,10 @@
         expect(await pool.totalSupply()).to.be.equal(0);
       });
 
-      it('sets the asset managers to zero', async () => {
+      it('sets the asset managers', async () => {
         await tokens.asyncEach(async (token) => {
           const info = await pool.getTokenInfo(token);
-          expect(info.assetManager).to.equal(ZERO_ADDRESS);
+          expect(info.assetManager).to.equal(assetManager.address);
         });
       });
 
@@ -575,7 +575,7 @@
 
       it('calculates amount out', async () => {
         const amount = fp(0.1);
-        const amountWithFees = fpMul(amount, POOL_SWAP_FEE_PERCENTAGE.add(fp(1)));
+        const amountWithFees = amount.mul(POOL_SWAP_FEE_PERCENTAGE.add(fp(1))).div(fp(1));
         const expectedAmountOut = await pool.estimateGivenIn({ in: 1, out: 0, amount: amountWithFees });
 
         const result = await pool.swapGivenIn({ in: 1, out: 0, amount: amountWithFees });
@@ -585,7 +585,7 @@
 
       it('calculates max amount out', async () => {
         const maxAmountIn = await pool.getMaxIn(1);
-        const maxAmountInWithFees = fpMul(maxAmountIn, POOL_SWAP_FEE_PERCENTAGE.add(fp(1)));
+        const maxAmountInWithFees = maxAmountIn.mul(POOL_SWAP_FEE_PERCENTAGE.add(fp(1))).div(fp(1));
         const expectedAmountOut = await pool.estimateGivenIn({ in: 1, out: 0, amount: maxAmountInWithFees });
 
         const result = await pool.swapGivenIn({ in: 1, out: 0, amount: maxAmountInWithFees });
@@ -595,7 +595,7 @@
 
       it('reverts if token in exceeds max in ratio', async () => {
         const maxAmountIn = await pool.getMaxIn(1);
-        const maxAmountInWithFees = fpMul(maxAmountIn, POOL_SWAP_FEE_PERCENTAGE.add(fp(1)));
+        const maxAmountInWithFees = maxAmountIn.mul(POOL_SWAP_FEE_PERCENTAGE.add(fp(1))).div(fp(1));
 
         const amount = maxAmountInWithFees.add(fp(1));
         await expect(pool.swapGivenIn({ in: 1, out: 0, amount })).to.be.revertedWith('MAX_IN_RATIO');
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/InvariantGrowthProtocolFees.behavior.ts pool-weighted/test/InvariantGrowthProtocolFees.behavior.ts
--- pool-weighted/test/InvariantGrowthProtocolFees.behavior.ts	1969-12-31 16:00:00.000000000 -0800
+++ pool-weighted/test/InvariantGrowthProtocolFees.behavior.ts	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,152 @@
+import { WeightedPoolEncoder } from '@balancer-labs/balancer-js';
+import { WeightedPoolType } from '@balancer-labs/v2-helpers/src/models/pools/weighted/types';
+import WeightedPool from '@balancer-labs/v2-helpers/src/models/pools/weighted/WeightedPool';
+import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
+import { bn, fp, FP_SCALING_FACTOR } from '@balancer-labs/v2-helpers/src/numbers';
+import { expectEqualWithError } from '@balancer-labs/v2-helpers/src/test/relativeError';
+import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';
+import { expect } from 'chai';
+import { BigNumber } from 'ethers';
+import { ethers } from 'hardhat';
+import { range } from 'lodash';
+
+export function itPaysProtocolFeesFromInvariantGrowth(): void {
+  const MAX_TOKENS = 8;
+  const WEIGHTS = range(1000, 1000 + MAX_TOKENS); // These will be normalized to weights that are close to each other, but different
+  const POOL_SWAP_FEE_PERCENTAGE = fp(0.01);
+
+  const numTokens = MAX_TOKENS;
+
+  let pool: WeightedPool;
+  let tokens: TokenList;
+  let protocolFeesCollector: string;
+
+  let lp: SignerWithAddress;
+
+  describe('invariant growth protocol fees', () => {
+    before('setup', async () => {
+      [, lp] = await ethers.getSigners();
+    });
+
+    const protocolFeePercentage = fp(0.3); // 30 %
+    const initialBalances = range(1, numTokens + 1).map(fp);
+    const initialBalanceGrowth = bn(3);
+
+    sharedBeforeEach(async () => {
+      tokens = await TokenList.create(numTokens, { sorted: true, varyDecimals: true });
+
+      pool = await WeightedPool.create({
+        poolType: WeightedPoolType.WEIGHTED_POOL,
+        tokens,
+        weights: WEIGHTS.slice(0, numTokens),
+        swapFeePercentage: POOL_SWAP_FEE_PERCENTAGE,
+      });
+
+      ({ address: protocolFeesCollector } = await pool.vault.getFeesCollector());
+
+      // Set the percentage in the Vault and update the cache, since the pool now reads from it
+      await pool.vault.setSwapFeePercentage(protocolFeePercentage);
+      await pool.instance.updateProtocolFeePercentageCache();
+    });
+
+    describe('last post join/exit invariant', () => {
+      it('is set on initialization', async () => {
+        await pool.init({ initialBalances });
+        expectEqualWithError(await pool.getLastInvariant(), await pool.estimateInvariant());
+      });
+
+      context('once initialized and with accumulated fees', () => {
+        sharedBeforeEach('initialize pool', async () => {
+          await pool.init({ initialBalances, recipient: lp });
+        });
+
+        sharedBeforeEach('accumulate fees by increasing balance', async () => {
+          await pool.vault.updateBalances(
+            pool.poolId,
+            initialBalances.map((x) => x.mul(initialBalanceGrowth))
+          );
+        });
+
+        itIsUpdatedByJoins();
+
+        itIsUpdatedByExits();
+
+        function itIsUpdatedByJoins() {
+          it('is updated by joins', async () => {
+            // We only test with a proportional join, since all joins are treated equally
+            await pool.join({
+              data: WeightedPoolEncoder.joinAllTokensInForExactBPTOut((await pool.totalSupply()).div(2)),
+              from: lp,
+            });
+
+            expectEqualWithError(await pool.getLastInvariant(), await pool.estimateInvariant());
+          });
+        }
+
+        function itIsUpdatedByExits() {
+          it('is updated by exits', async () => {
+            // We only test with a proportional exit, since all exits are treated equally and proportional exits remain
+            // enabled while paused
+            await pool.exit({
+              data: WeightedPoolEncoder.exitExactBPTInForTokensOut((await pool.totalSupply()).div(2)),
+              from: lp,
+            });
+
+            expectEqualWithError(await pool.getLastInvariant(), await pool.estimateInvariant());
+          });
+        }
+      });
+    });
+
+    describe('protocol fees', () => {
+      async function protocolFeesPaid(): Promise<BigNumber> {
+        const previousProtocolFeeCollectorBalance = await pool.balanceOf(protocolFeesCollector);
+
+        // We trigger protocol fee payment by executing a proportional exit for 0 BPT
+        await pool.exit({
+          data: WeightedPoolEncoder.exitExactBPTInForTokensOut(fp(0)),
+          protocolFeePercentage,
+        });
+
+        const currentProtocolFeeCollectorBalance = await pool.balanceOf(protocolFeesCollector);
+        return currentProtocolFeeCollectorBalance.sub(previousProtocolFeeCollectorBalance);
+      }
+
+      context('once initialized and with accumulated fees', () => {
+        sharedBeforeEach('initialize pool', async () => {
+          await pool.init({ initialBalances, recipient: lp });
+        });
+
+        sharedBeforeEach('accumulate fees by increasing balance', async () => {
+          await pool.vault.updateBalances(
+            pool.poolId,
+            initialBalances.map((x) => x.mul(initialBalanceGrowth))
+          );
+        });
+
+        context('when not paused', () => {
+          it('pays protocol fees', async () => {
+            const fees = await protocolFeesPaid();
+            const totalBPT = await pool.totalSupply();
+
+            // Balances increased by initialBalanceGrowth, and protocol was due protocolFeePercentage of that. It should
+            // therefore have been paid (initialBalanceGrowth - 1) * protocolFeePercentage / initialBalanceGrowth of the
+            // total BPT.
+
+            const bptOwnership = fees.mul(FP_SCALING_FACTOR).div(totalBPT);
+            const expectedOwnership = initialBalanceGrowth.sub(1).mul(protocolFeePercentage).div(initialBalanceGrowth);
+
+            await expectEqualWithError(bptOwnership, expectedOwnership);
+          });
+
+          it('does not pay fees again until more are accumulated', async () => {
+            await protocolFeesPaid();
+
+            const secondPayment = await protocolFeesPaid();
+            expect(secondPayment).to.equal(0);
+          });
+        });
+      });
+    });
+  });
+}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/ManagedPool.test.ts pool-weighted/test/ManagedPool.test.ts
--- pool-weighted/test/ManagedPool.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/test/ManagedPool.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -11,18 +11,8 @@
   advanceTime,
   advanceToTimestamp,
   currentTimestamp,
-  receiptTimestamp,
 } from '@balancer-labs/v2-helpers/src/time';
-import {
-  BigNumberish,
-  bn,
-  fp,
-  fpDiv,
-  fpMul,
-  FP_SCALING_FACTOR,
-  fromFp,
-  pct,
-} from '@balancer-labs/v2-helpers/src/numbers';
+import { BigNumberish, bn, fp, FP_SCALING_FACTOR, fromFp, pct } from '@balancer-labs/v2-helpers/src/numbers';
 import * as expectEvent from '@balancer-labs/v2-helpers/src/test/expectEvent';
 import { deploy } from '@balancer-labs/v2-helpers/src/contract';
 import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
@@ -1063,11 +1053,10 @@
                             const someTokenBeforeIndex = beforeTokens.indexOf(someToken.token);
                             const otherTokenBeforeIndex = beforeTokens.indexOf(otherToken.token);
 
-                            const afterWeightRatio = fpDiv(someToken.weight, otherToken.weight);
-                            const beforeWeightRatio = fpDiv(
-                              beforeTokenWeights[someTokenBeforeIndex].weight,
-                              beforeTokenWeights[otherTokenBeforeIndex].weight
-                            );
+                            const afterWeightRatio = someToken.weight.mul(FP_SCALING_FACTOR).div(otherToken.weight);
+                            const beforeWeightRatio = beforeTokenWeights[someTokenBeforeIndex].weight
+                              .mul(FP_SCALING_FACTOR)
+                              .div(beforeTokenWeights[otherTokenBeforeIndex].weight);
 
                             expect(afterWeightRatio).to.equalWithError(beforeWeightRatio, 0.000001);
                           });
@@ -1080,7 +1069,7 @@
 
                       const expectedDenormWeightSum = beforeWeights
                         .filter((_, i) => i !== tokenIndex)
-                        .reduce((sum, weight) => sum.add(fpMul(weight, beforeSum)), bn(0));
+                        .reduce((sum, weight) => sum.add(weight.mul(beforeSum).div(FP_SCALING_FACTOR)), bn(0));
 
                       await pool.removeToken(sender, poolTokens.addresses[tokenIndex], other.address);
 
@@ -1467,11 +1456,10 @@
                           const someTokenAfterIndex = afterTokens.indexOf(someToken.token);
                           const otherTokenAfterIndex = afterTokens.indexOf(otherToken.token);
 
-                          const beforeWeightRatio = fpDiv(someToken.weight, otherToken.weight);
-                          const afterWeightRatio = fpDiv(
-                            afterTokenWeights[someTokenAfterIndex].weight,
-                            afterTokenWeights[otherTokenAfterIndex].weight
-                          );
+                          const beforeWeightRatio = someToken.weight.mul(FP_SCALING_FACTOR).div(otherToken.weight);
+                          const afterWeightRatio = afterTokenWeights[someTokenAfterIndex].weight
+                            .mul(FP_SCALING_FACTOR)
+                            .div(afterTokenWeights[otherTokenAfterIndex].weight);
 
                           expect(afterWeightRatio).to.equalWithError(beforeWeightRatio, 0.000001);
                         });
@@ -1483,7 +1471,7 @@
 
                     const normalizedWeight = fp(0.5);
                     const weightSumRatio = fp(FP_SCALING_FACTOR).div(fp(1).sub(normalizedWeight));
-                    const expectedDenormWeightSum = fpMul(beforeSum, weightSumRatio);
+                    const expectedDenormWeightSum = beforeSum.mul(weightSumRatio).div(FP_SCALING_FACTOR);
 
                     await pool.addToken(sender, newToken, fp(0.5), fp(100), 0, other.address);
 
@@ -1536,7 +1524,6 @@
     const poolWeights = [fp(0.8), fp(0.2)];
     let bptFeeBalance: BigNumber;
     let mockMath: Contract;
-    let mockFees: Contract;
 
     let twoTokens: TokenList;
     let localBalances: Array<BigNumber>;
@@ -1569,7 +1556,6 @@
       };
       pool = await WeightedPool.create(params);
       mockMath = await deploy('MockWeightedMath');
-      mockFees = await deploy('v2-pool-utils/MockInvariantGrowthProtocolSwapFees');
     });
 
     sharedBeforeEach('initialize pool', async () => {
@@ -1621,7 +1607,7 @@
 
           const prevInvariant = await mockMath.invariant(poolWeights, upscaledBalances);
 
-          const adjustedAmountIn = fpMul(upscaledSwapAmount, fp(1).sub(swapFeePercentage));
+          const adjustedAmountIn = upscaledSwapAmount.mul(fp(1).sub(swapFeePercentage)).div(fp(1));
           const amountOut = await mockMath.outGivenIn(
             upscaledBalances[0],
             poolWeights[0],
@@ -1634,10 +1620,10 @@
           const postInvariant = await mockMath.invariant(poolWeights, postBalances);
           const totalSupply = await pool.totalSupply();
 
-          const expectedProtocolFees = await mockFees.calculateDueProtocolFees(
-            fpDiv(postInvariant, prevInvariant),
-            totalSupply,
+          const expectedProtocolFees = await mockMath.calculateDueProtocolSwapFeeBPTAmount(
             totalSupply,
+            prevInvariant,
+            postInvariant,
             protocolFeePercentage
           );
 
@@ -1686,10 +1672,10 @@
           const postInvariant = await mockMath.invariant(poolWeights, postBalances);
           const totalSupply = await pool.totalSupply();
 
-          const expectedProtocolFees = await mockFees.calculateDueProtocolFees(
-            fpDiv(postInvariant, prevInvariant),
-            totalSupply,
+          const expectedProtocolFees = await mockMath.calculateDueProtocolSwapFeeBPTAmount(
             totalSupply,
+            prevInvariant,
+            postInvariant,
             protocolFeePercentage
           );
 
@@ -1765,42 +1751,6 @@
     });
   });
 
-  describe('recovery mode', () => {
-    sharedBeforeEach('deploy pool', async () => {
-      const params = {
-        tokens: poolTokens,
-        weights: poolWeights,
-        owner: owner.address,
-        poolType: WeightedPoolType.MANAGED_POOL,
-        swapEnabledOnStart: true,
-        vault,
-      };
-      pool = await WeightedPool.create(params);
-      await pool.init({ from: other, initialBalances });
-
-      await pool.collectAumManagementFees(owner);
-    });
-
-    context('when leaving recovery mode', () => {
-      it('sets the lastAumFeeCollectionTimestamp to the current timestamp', async () => {
-        const lastAUMCollectionTimestamp = await pool.instance.getLastAumFeeCollectionTimestamp();
-        // Set recovery mode to stop AUM fee calculations.
-        await pool.enableRecoveryMode();
-
-        // Advance time so that AUM fees would otherwise be accrued.
-        await advanceTime(365 * DAY);
-
-        expect(await pool.instance.getLastAumFeeCollectionTimestamp()).to.be.eq(lastAUMCollectionTimestamp);
-
-        // On disabling recovery mode we expect the `_lastAumFeeCollectionTimestamp` to be be equal to the current time.
-        const tx = await pool.disableRecoveryMode();
-        const expectedLastAUMCollectionTimestamp = await receiptTimestamp(tx.wait());
-        const updatedLastAUMCollectionTimestamp = await pool.instance.getLastAumFeeCollectionTimestamp();
-        expect(updatedLastAUMCollectionTimestamp).to.be.eq(expectedLastAUMCollectionTimestamp);
-      });
-    });
-  });
-
   describe('management fees', () => {
     const swapFeePercentage = fp(0.02);
     const managementSwapFeePercentage = fp(0.8);
@@ -1883,10 +1833,7 @@
         });
       }
 
-      function itCollectsAUMFeesForExpectedDuration(
-        collectAUMFees: () => Promise<ContractReceipt>,
-        timeElapsed: BigNumberish
-      ) {
+      function itCollectsAUMFeesCorrectly(collectAUMFees: () => Promise<ContractReceipt>, timeElapsed: BigNumberish) {
         it('collects the expected amount of fees', async () => {
           const balanceBefore = await pool.balanceOf(owner);
 
@@ -1905,40 +1852,6 @@
         });
       }
 
-      function itCollectsAUMFeesCorrectly(collectAUMFees: () => Promise<ContractReceipt>) {
-        const timeElapsed = 10 * DAY;
-
-        sharedBeforeEach('advance time', async () => {
-          await advanceTime(timeElapsed);
-        });
-
-        itCollectsAUMFeesForExpectedDuration(collectAUMFees, timeElapsed);
-
-        context('when the pool is paused and enters into recovery mode', () => {
-          sharedBeforeEach('pause pool and enter recovery mode', async () => {
-            await pool.pause();
-            await pool.enableRecoveryMode();
-          });
-
-          itReverts(collectAUMFees);
-
-          context('when the pool is then unpaused and removed from recovery mode', () => {
-            sharedBeforeEach('unpause pool and exit recovery mode', async () => {
-              // Exiting recovery mode will update the timestamp of the last collection.
-              // This avoids the pool overcharging AUM fees after the unpause.
-              await pool.unpause();
-              await pool.disableRecoveryMode();
-
-              // We now advance time so that we can test that the collected fees correspond to `timeElapsed`,
-              // rather than `2 * timeElapsed` as we'd expect if the pool didn't correctly update while paused.
-              await advanceTime(timeElapsed);
-            });
-
-            itCollectsAUMFeesForExpectedDuration(collectAUMFees, timeElapsed);
-          });
-        });
-      }
-
       sharedBeforeEach('mint tokens', async () => {
         await poolTokens.mint({ to: other, amount: fp(10000) });
         await poolTokens.approve({ from: other, to: await pool.getVault() });
@@ -1952,8 +1865,12 @@
         });
 
         context('when the pool is initialized', () => {
-          sharedBeforeEach('initialize pool', async () => {
+          const timeElapsed = 10 * DAY;
+
+          sharedBeforeEach('initialize pool and advance time', async () => {
             await pool.init({ from: other, initialBalances });
+
+            await advanceTime(timeElapsed);
           });
 
           context('on the first attempt to collect fees', () => {
@@ -1964,14 +1881,54 @@
           });
 
           context('on subsequent attempts to collect fees', () => {
-            sharedBeforeEach('perform first fee collection', async () => {
-              // AUM fees only accrue after the first collection attempt so we attempt to collect fees here.
+            sharedBeforeEach('advance time', async () => {
+              // AUM fees only accrue after the first collection so we have to wait for more time to elapse.
               await pool.collectAumManagementFees(owner);
+              await advanceTime(timeElapsed);
             });
 
             itCollectsAUMFeesCorrectly(async () => {
               const tx = await pool.collectAumManagementFees(owner);
               return tx.wait();
+            }, timeElapsed);
+
+            context('when the pool is paused', () => {
+              sharedBeforeEach('pause pool', async () => {
+                await pool.pause();
+              });
+
+              itReverts(async () => {
+                const tx = await pool.collectAumManagementFees(owner);
+                return tx.wait();
+              });
+
+              context('when the pool is then unpaused', () => {
+                sharedBeforeEach('collect fees and unpause pool', async () => {
+                  if (!vault.admin) throw Error('No Vault admin account');
+                  await pool.enableRecoveryMode(vault.admin);
+
+                  // Perform a Recovery mode exit. This will collect no fees but will update the timestamp of the
+                  // last collection. This avoids the pool overcharging AUM fees after the unpause.
+                  // Note that if nobody interacts with the pool before it is unpaused then AUM fees will be charged
+                  // as if the pool were never paused, however this is unlikely to occur.
+                  await pool.recoveryModeExit({
+                    from: other,
+                    bptIn: (await pool.balanceOf(other)).div(10),
+                  });
+
+                  await pool.unpause();
+                  await pool.disableRecoveryMode(vault.admin);
+
+                  // We now advance time so that we can test that the collected fees correspond to `timeElapsed`,
+                  // rather than `2 * timeElapsed` as we'd expect if the pool didn't correctly update while paused.
+                  await advanceTime(timeElapsed);
+                });
+
+                itCollectsAUMFeesCorrectly(async () => {
+                  const tx = await pool.collectAumManagementFees(owner);
+                  return tx.wait();
+                }, timeElapsed);
+              });
             });
           });
         });
@@ -1986,45 +1943,161 @@
         });
 
         context('after pool initialization', () => {
-          sharedBeforeEach('initialize pool', async () => {
+          const timeElapsed = 10 * DAY;
+
+          sharedBeforeEach('initialize pool and advance time', async () => {
             await pool.init({ from: other, initialBalances });
             // AUM fees only accrue after the first collection attempt so we attempt to collect fees here.
             await pool.collectAumManagementFees(owner);
+
+            await advanceTime(timeElapsed);
+          });
+
+          sharedBeforeEach('mint tokens', async () => {
+            await poolTokens.mint({ to: other, amount: fp(10000) });
+            await poolTokens.approve({ from: other, to: await pool.getVault() });
           });
 
           itCollectsAUMFeesCorrectly(async () => {
             const amountsIn = initialBalances.map((x) => x.div(2));
             const { receipt } = await pool.joinGivenIn({ from: other, amountsIn });
             return receipt;
+          }, timeElapsed);
+
+          context('when the pool is paused and then then unpaused', () => {
+            sharedBeforeEach('pause pool, collect fees and unpause pool', async () => {
+              if (!vault.admin) throw Error('No Vault admin account');
+              await pool.pause();
+              await pool.enableRecoveryMode(vault.admin);
+
+              // Perform a Recovery mode exit. This will collect no fees but will update the timestamp of the
+              // last collection. This avoids the pool overcharging AUM fees after the unpause.
+              // Note that if nobody interacts with the pool before it is unpaused then AUM fees will be charged
+              // as if the pool were never paused, however this is unlikely to occur.
+              await pool.recoveryModeExit({
+                from: other,
+                bptIn: (await pool.balanceOf(other)).div(10),
+              });
+
+              await pool.unpause();
+              await pool.disableRecoveryMode(vault.admin);
+
+              // We now advance time so that we can test that the collected fees correspond to `timeElapsed`,
+              // rather than `2 * timeElapsed` as we'd expect if the pool didn't correctly update while paused.
+              await advanceTime(timeElapsed);
+            });
+
+            itCollectsAUMFeesCorrectly(async () => {
+              const amountsIn = initialBalances.map((x) => x.div(2));
+              const { receipt } = await pool.joinGivenIn({ from: other, amountsIn });
+              return receipt;
+            }, timeElapsed);
           });
         });
       });
 
       context('on pool exits', () => {
-        sharedBeforeEach('initialize pool', async () => {
+        const timeElapsed = 10 * DAY;
+
+        sharedBeforeEach('initialize pool and advance time', async () => {
           await pool.init({ from: other, initialBalances });
           // AUM fees only accrue after the first collection attempt so we attempt to collect fees here.
           await pool.collectAumManagementFees(owner);
+
+          await advanceTime(timeElapsed);
         });
 
         itCollectsAUMFeesCorrectly(async () => {
           const { receipt } = await pool.multiExitGivenIn({ from: other, bptIn: await pool.balanceOf(other) });
           return receipt;
+        }, timeElapsed);
+
+        context('when the pool is paused', () => {
+          sharedBeforeEach('pause pool', async () => {
+            await pool.pause();
+          });
+
+          itReverts(async () => {
+            const { receipt } = await pool.multiExitGivenIn({ from: other, bptIn: await pool.balanceOf(other) });
+            return receipt;
+          });
+
+          context('when the pool is then unpaused', () => {
+            sharedBeforeEach('collect fees and unpause pool', async () => {
+              if (!vault.admin) throw Error('No Vault admin account');
+              await pool.enableRecoveryMode(vault.admin);
+
+              // Perform a Recovery mode exit. This will collect no fees but will update the timestamp of the
+              // last collection. This avoids the pool overcharging AUM fees after the unpause.
+              // Note that if nobody interacts with the pool before it is unpaused then AUM fees will be charged
+              // as if the pool were never paused, however this is unlikely to occur.
+              await pool.recoveryModeExit({
+                from: other,
+                bptIn: (await pool.balanceOf(other)).div(10),
+              });
+
+              await pool.unpause();
+              await pool.disableRecoveryMode(vault.admin);
+
+              // We now advance time so that we can test that the collected fees correspond to `timeElapsed`,
+              // rather than `2 * timeElapsed` as we'd expect if the pool didn't correctly update while paused.
+              await advanceTime(timeElapsed);
+            });
+
+            itCollectsAUMFeesCorrectly(async () => {
+              const { receipt } = await pool.multiExitGivenIn({ from: other, bptIn: await pool.balanceOf(other) });
+              return receipt;
+            }, timeElapsed);
+          });
         });
       });
 
       context('on token removal', () => {
         context('after pool initialization', () => {
-          sharedBeforeEach('initialize pool', async () => {
+          const timeElapsed = 10 * DAY;
+
+          sharedBeforeEach('initialize pool and advance time', async () => {
             await pool.init({ from: other, initialBalances });
             // AUM fees only accrue after the first collection attempt so we attempt to collect fees here.
             await pool.collectAumManagementFees(owner);
+
+            await advanceTime(timeElapsed);
           });
 
           itCollectsAUMFeesCorrectly(async () => {
             const { tokens } = await pool.getTokens();
             const tx = await pool.removeToken(owner, tokens[tokens.length - 1], other.address);
             return tx.wait();
+          }, timeElapsed);
+
+          context('when the pool is paused and then then unpaused', () => {
+            sharedBeforeEach('pause pool, collect fees and unpause pool', async () => {
+              if (!vault.admin) throw Error('No Vault admin account');
+              await pool.pause();
+              await pool.enableRecoveryMode(vault.admin);
+
+              // Perform a Recovery mode exit. This will collect no fees but will update the timestamp of the
+              // last collection. This avoids the pool overcharging AUM fees after the unpause.
+              // Note that if nobody interacts with the pool before it is unpaused then AUM fees will be charged
+              // as if the pool were never paused, however this is unlikely to occur.
+              await pool.recoveryModeExit({
+                from: other,
+                bptIn: (await pool.balanceOf(other)).div(10),
+              });
+
+              await pool.unpause();
+              await pool.disableRecoveryMode(vault.admin);
+
+              // We now advance time so that we can test that the collected fees correspond to `timeElapsed`,
+              // rather than `2 * timeElapsed` as we'd expect if the pool didn't correctly update while paused.
+              await advanceTime(timeElapsed);
+            });
+
+            itCollectsAUMFeesCorrectly(async () => {
+              const { tokens } = await pool.getTokens();
+              const tx = await pool.removeToken(owner, tokens[tokens.length - 1], other.address);
+              return tx.wait();
+            }, timeElapsed);
           });
         });
       });
@@ -2095,7 +2168,7 @@
 
       const balanceBefore = await pool.balanceOf(owner);
 
-      const protocolPortion = fpMul(expectedBpt, AUM_PROTOCOL_FEE_PERCENTAGE);
+      const protocolPortion = expectedBpt.mul(AUM_PROTOCOL_FEE_PERCENTAGE).div(fp(1));
       const ownerPortion = expectedBpt.sub(protocolPortion);
 
       await advanceTime(180 * DAY);
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/PostJoinExitProtocolFees.test.ts pool-weighted/test/PostJoinExitProtocolFees.test.ts
--- pool-weighted/test/PostJoinExitProtocolFees.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/test/PostJoinExitProtocolFees.test.ts	1969-12-31 16:00:00.000000000 -0800
@@ -1,297 +0,0 @@
-import { expect } from 'chai';
-import { ethers } from 'hardhat';
-import { BigNumber, Contract } from 'ethers';
-
-import { deploy } from '@balancer-labs/v2-helpers/src/contract';
-import { sharedBeforeEach } from '@balancer-labs/v2-common/sharedBeforeEach';
-import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signer-with-address';
-import { toNormalizedWeights } from '@balancer-labs/balancer-js';
-import { arrayAdd, BigNumberish, bn, fp, arraySub, fpMul, fpDiv } from '@balancer-labs/v2-helpers/src/numbers';
-
-import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
-import Vault from '@balancer-labs/v2-helpers/src/models/vault/Vault';
-import { MONTH } from '@balancer-labs/v2-helpers/src/time';
-import { actionId } from '@balancer-labs/v2-helpers/src/models/misc/actions';
-
-import { random, range } from 'lodash';
-import { ProtocolFee } from '@balancer-labs/v2-helpers/src/models/vault/types';
-import { ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
-import { calculateBPTSwapFeeAmount } from '@balancer-labs/v2-helpers/src/models/pools/weighted/math';
-
-describe('PostJoinExitProtocolFees', () => {
-  let admin: SignerWithAddress;
-  let owner: SignerWithAddress;
-  let vault: Vault, feesCollector: Contract, feesProvider: Contract;
-  let poolWeights: BigNumber[];
-  let math: Contract;
-
-  const POOL_SWAP_FEE_PERCENTAGE = fp(0.1);
-  const FEE_RELATIVE_ERROR = 0.02;
-  const MAX_TOKENS = 8;
-
-  const WEIGHTS = range(10000, 10000 + MAX_TOKENS);
-
-  sharedBeforeEach('setup signers', async () => {
-    [, admin, owner] = await ethers.getSigners();
-  });
-
-  sharedBeforeEach('deploy vault', async () => {
-    vault = await Vault.create({ admin });
-    feesCollector = await vault.getFeesCollector();
-    feesProvider = vault.getFeesProvider();
-  });
-
-  sharedBeforeEach('deploy math', async () => {
-    math = await deploy('MockWeightedMath');
-  });
-
-  sharedBeforeEach('grant permissions to admin', async () => {
-    await vault.authorizer
-      .connect(admin)
-      .grantPermissions([actionId(feesProvider, 'setFeeTypePercentage')], admin.address, [feesProvider.address]);
-
-    await vault.authorizer
-      .connect(admin)
-      .grantPermissions(
-        [actionId(feesCollector, 'setSwapFeePercentage'), actionId(feesCollector, 'setFlashLoanFeePercentage')],
-        feesProvider.address,
-        [feesCollector.address, feesCollector.address]
-      );
-  });
-
-  for (let numTokens = 2; numTokens <= MAX_TOKENS; numTokens++) {
-    context(`for a ${numTokens} token pool`, () => {
-      itBehavesAsWeightedPoolProtocolFees(numTokens);
-    });
-  }
-
-  function itBehavesAsWeightedPoolProtocolFees(numberOfTokens: number): void {
-    describe('protocol fees on join/exit', () => {
-      // We want relatively large values to make the fees much larger than rounding error
-      const SWAP_PROTOCOL_FEE_PERCENTAGE = fp(0.5);
-
-      const MIN_POOL_TOKEN_BALANCE = 150e6;
-      const MAX_POOL_TOKEN_BALANCE = 200e6;
-
-      let pool: Contract, tokens: TokenList;
-      let preBalances: BigNumber[];
-      let balanceDeltas: BigNumber[];
-      let preInvariant: BigNumber;
-      let postInvariant: BigNumber;
-      let preSupply: BigNumber;
-      let currentSupply: BigNumber;
-
-      sharedBeforeEach('deploy tokens', async () => {
-        tokens = await TokenList.create(numberOfTokens, { sorted: true });
-      });
-
-      sharedBeforeEach('deploy pool', async () => {
-        pool = await deploy('MockWeightedPoolProtocolFees', {
-          args: [
-            vault.address,
-            feesProvider.address,
-            'Test WP',
-            'TWP',
-            tokens.addresses,
-            tokens.map(() => ZERO_ADDRESS), // rate providers
-            tokens.map(() => ZERO_ADDRESS), // asset managers
-            POOL_SWAP_FEE_PERCENTAGE,
-            MONTH * 3, // pause window
-            MONTH, // buffer period
-            owner.address,
-          ],
-        });
-
-        // Set weights
-        poolWeights = toNormalizedWeights(WEIGHTS.slice(0, numberOfTokens).map((w) => bn(w)));
-      });
-
-      function setProtocolFees(swapFee: BigNumberish) {
-        sharedBeforeEach('set protocol fees', async () => {
-          await feesProvider.connect(admin).setFeeTypePercentage(ProtocolFee.SWAP, swapFee);
-
-          await pool.updateProtocolFeePercentageCache();
-        });
-      }
-
-      sharedBeforeEach('setup previous pool state', async () => {
-        // Since we're passing the balances directly to the contract, we don't need to worry about scaling factors, and
-        // can work with 18 decimal balances directly.
-        preBalances = tokens.map(() => fp(random(MIN_POOL_TOKEN_BALANCE, MAX_POOL_TOKEN_BALANCE)));
-        balanceDeltas = tokens.map(() => fp(random(0, MIN_POOL_TOKEN_BALANCE / 100)));
-
-        preInvariant = await math.invariant(poolWeights, preBalances);
-
-        // The supply is some factor of the invariant
-        preSupply = fpMul(preInvariant, fp(random(1.5, 10)));
-      });
-
-      describe('getPostJoinExitProtocolFees', () => {
-        context('when the protocol swap fee percentage is zero', () => {
-          itPaysProtocolFeesOnJoinExitSwaps(bn(0));
-        });
-
-        context('when the protocol swap fee percentage is non-zero', () => {
-          itPaysProtocolFeesOnJoinExitSwaps(SWAP_PROTOCOL_FEE_PERCENTAGE);
-        });
-
-        function itPaysProtocolFeesOnJoinExitSwaps(swapFee: BigNumber) {
-          enum Operation {
-            JOIN,
-            EXIT,
-          }
-
-          setProtocolFees(swapFee);
-
-          context('on proportional join', () => {
-            prepareProportionalJoinOrExit(Operation.JOIN);
-
-            itReturnsZeroProtocolFees();
-
-            itUpdatesThePostJoinInvariant();
-          });
-
-          context('on proportional exit', () => {
-            prepareProportionalJoinOrExit(Operation.EXIT);
-
-            itReturnsZeroProtocolFees();
-
-            itUpdatesThePostJoinInvariant();
-          });
-
-          context('on non-proportional join', () => {
-            prepareMultiTokenNonProportionalJoinOrExit(Operation.JOIN);
-
-            if (swapFee.eq(0)) {
-              itReturnsZeroProtocolFees();
-            } else {
-              itReturnsTheExpectedProtocolFees();
-            }
-
-            itUpdatesThePostJoinInvariant();
-          });
-
-          context('on non-proportional exit', () => {
-            prepareMultiTokenNonProportionalJoinOrExit(Operation.EXIT);
-
-            if (swapFee.eq(0)) {
-              itReturnsZeroProtocolFees();
-            } else {
-              itReturnsTheExpectedProtocolFees();
-            }
-
-            itUpdatesThePostJoinInvariant();
-          });
-
-          // This is an exact tokens in/out that happens to be proportional
-          function prepareProportionalJoinOrExit(op: Operation) {
-            sharedBeforeEach(async () => {
-              const ratio = fp(random(0.1, 0.9));
-
-              // Generate amounts for a proportional join/exit
-              balanceDeltas = preBalances.map((balance) => fpMul(balance, ratio));
-
-              // increase/decrease the virtual proportionally
-              if (op == Operation.JOIN) {
-                currentSupply = fpMul(preSupply, fp(1).add(ratio));
-              } else {
-                currentSupply = fpMul(preSupply, fp(1).sub(ratio));
-              }
-
-              const currentBalances =
-                op == Operation.JOIN ? arrayAdd(preBalances, balanceDeltas) : arraySub(preBalances, balanceDeltas);
-
-              postInvariant = await math.invariant(poolWeights, currentBalances);
-            });
-          }
-
-          function prepareMultiTokenNonProportionalJoinOrExit(op: Operation) {
-            sharedBeforeEach(async () => {
-              const ratio = fp(random(0.1, 0.9));
-
-              // Generate amounts for a proportional join/exit
-              const proportionalAmounts = preBalances.map((balance) => fpMul(balance, ratio));
-
-              // Compute deltas that are going to modify the proportional amounts. These will be swap fees.
-              const deltas = proportionalAmounts.map((amount) => fpMul(amount, fp(random(0.05, 0.1))));
-              let currentBalances: BigNumber[];
-
-              // Compute the balances with the added deltas, and the supply without taking them into account
-              // (because they are fees).
-              if (op == Operation.JOIN) {
-                const proportionalBalances = arrayAdd(preBalances, proportionalAmounts);
-                currentSupply = fpMul(preSupply, fp(1).add(ratio));
-
-                currentBalances = arrayAdd(proportionalBalances, deltas);
-                balanceDeltas = arraySub(currentBalances, preBalances);
-              } else {
-                const proportionalBalances = arraySub(preBalances, proportionalAmounts);
-                currentSupply = fpMul(preSupply, fp(1).sub(ratio));
-
-                currentBalances = arrayAdd(proportionalBalances, deltas);
-                balanceDeltas = arraySub(preBalances, currentBalances);
-              }
-
-              postInvariant = await math.invariant(poolWeights, currentBalances);
-            });
-          }
-
-          function itReturnsZeroProtocolFees() {
-            it('returns no (or negligible) BPT', async () => {
-              const protocolFeeAmount = await pool.callStatic.getPostJoinExitProtocolFees(
-                preBalances,
-                balanceDeltas,
-                poolWeights,
-                preSupply,
-                currentSupply
-              );
-
-              // If the protocol swap fee percentage is non-zero, we can't quite guarantee that there'll be zero
-              // protocol fees since there's some rounding error in the computation of the currentInvariant the Pool
-              // will make, which might result in negligible fees.
-
-              // The BPT amount to mint is computed as a percentage of the current supply. This is done with precision
-              // of up to 18 decimal places, so any error below that is always considered negligible. We test for
-              // precision of up to 17 decimal places to give some leeway and account for e.g. different rounding
-              // directions, etc.
-              expect(protocolFeeAmount).to.be.lte(currentSupply.div(bn(1e17)));
-            });
-          }
-
-          function itReturnsTheExpectedProtocolFees() {
-            it('returns the expected protocol fees', async () => {
-              const protocolFeeAmount = await pool.callStatic.getPostJoinExitProtocolFees(
-                preBalances,
-                balanceDeltas,
-                poolWeights,
-                preSupply,
-                currentSupply
-              );
-
-              const invariantGrowthRatio = fpDiv(postInvariant, preInvariant);
-              const expectedBptAmount = calculateBPTSwapFeeAmount(
-                invariantGrowthRatio,
-                preSupply,
-                currentSupply,
-                SWAP_PROTOCOL_FEE_PERCENTAGE
-              );
-
-              expect(protocolFeeAmount).to.be.almostEqual(expectedBptAmount, FEE_RELATIVE_ERROR);
-            });
-          }
-
-          function itUpdatesThePostJoinInvariant() {
-            it('updates the postJoin invariant', async () => {
-              // _lastPostJoinExitInvariant is expected to be uninitialised.
-              expect(await pool.getLastPostJoinExitInvariant()).to.be.eq(0);
-
-              await pool.getPostJoinExitProtocolFees(preBalances, balanceDeltas, poolWeights, preSupply, currentSupply);
-
-              expect(await pool.getLastPostJoinExitInvariant()).to.almostEqual(postInvariant);
-            });
-          }
-        }
-      });
-    });
-  }
-});
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/WeightedMath.test.ts pool-weighted/test/WeightedMath.test.ts
--- pool-weighted/test/WeightedMath.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/test/WeightedMath.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -1,12 +1,13 @@
 import { Contract } from 'ethers';
 
-import { bn } from '@balancer-labs/v2-helpers/src/numbers';
+import { bn, fp, FP_SCALING_FACTOR } from '@balancer-labs/v2-helpers/src/numbers';
 import { deploy } from '@balancer-labs/v2-helpers/src/contract';
 import { expectEqualWithError } from '@balancer-labs/v2-helpers/src/test/relativeError';
 import {
   calculateInvariant,
   calcInGivenOut,
   calcOutGivenIn,
+  calculateBPTSwapFeeFeeAmount,
 } from '@balancer-labs/v2-helpers/src/models/pools/weighted/math';
 import { expect } from 'chai';
 
@@ -205,4 +206,69 @@
       expectEqualWithError(outAmountPool, bn(outAmountMath.toFixed(0)), MAX_RELATIVE_ERROR);
     });
   });
+
+  context('protocol swap fees', () => {
+    context('with invariant growth', () => {
+      it('returns protocol swap fees', async () => {
+        const normalizedWeights = [bn(0.3e18), bn(0.7e18)];
+        const lastBalances = [bn(25e18), bn(500e18)];
+
+        // Both balances increase by 40%
+        const currentBalances = [bn(35e18), bn(700e18)];
+
+        const protocolSwapFeePercentage = fp(0.3);
+        // The protocol is due 30% of the 10 extra tokens in token A (3 tokens), and 30% of the 200 extra tokens in token B
+        // (60 tokens).
+
+        const totalSupply = fp(100);
+
+        const lastInvariant = calculateInvariant(lastBalances, normalizedWeights);
+        const currentInvariant = calculateInvariant(currentBalances, normalizedWeights);
+
+        const toMint = await mock.calculateDueProtocolSwapFeeBPTAmount(
+          totalSupply,
+          lastInvariant,
+          currentInvariant,
+          protocolSwapFeePercentage
+        );
+
+        // The BPT to mint should be such that it'd let the protocol claim the tokens it is due if exiting proportionally
+        const protocolPoolOwnership = toMint.mul(FP_SCALING_FACTOR).div(totalSupply.add(toMint)); // The BPT supply grows
+
+        const tokenAFeeAmount = currentBalances[0].mul(protocolPoolOwnership).div(FP_SCALING_FACTOR);
+        const tokenBFeeAmount = currentBalances[1].mul(protocolPoolOwnership).div(FP_SCALING_FACTOR);
+
+        expectEqualWithError(tokenAFeeAmount, bn(3e18), MAX_RELATIVE_ERROR);
+        expectEqualWithError(tokenBFeeAmount, bn(60e18), MAX_RELATIVE_ERROR);
+
+        // The TS helper outputs the same value
+
+        const expectedToMint = calculateBPTSwapFeeFeeAmount(
+          totalSupply,
+          lastInvariant,
+          currentInvariant,
+          protocolSwapFeePercentage
+        );
+
+        expectEqualWithError(toMint, fp(expectedToMint), MAX_RELATIVE_ERROR);
+      });
+    });
+
+    context('with smaller invariant', async () => {
+      const protocolSwapFeePercentage = fp(0.3);
+      const totalSupply = fp(100);
+
+      const lastInvariant = fp(300);
+      const currentInvariant = fp(299);
+
+      const toMint = await mock.calculateDueProtocolSwapFeeBPTAmount(
+        totalSupply,
+        lastInvariant,
+        currentInvariant,
+        protocolSwapFeePercentage
+      );
+
+      expect(toMint).to.equal(0);
+    });
+  });
 });
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/WeightedPool.test.ts pool-weighted/test/WeightedPool.test.ts
--- pool-weighted/test/WeightedPool.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/test/WeightedPool.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -1,81 +1,27 @@
-import { ethers } from 'hardhat';
-import { BigNumber, Contract } from 'ethers';
-import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';
 import { expect } from 'chai';
+import { fp } from '@balancer-labs/v2-helpers/src/numbers';
 
 import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
 import WeightedPool from '@balancer-labs/v2-helpers/src/models/pools/weighted/WeightedPool';
-import Vault from '@balancer-labs/v2-helpers/src/models/vault/Vault';
-import { FundManagement, SwapKind } from '@balancer-labs/balancer-js';
 import { WeightedPoolType } from '@balancer-labs/v2-helpers/src/models/pools/weighted/types';
-import { fp, fpDiv, fpMul, FP_SCALING_FACTOR } from '@balancer-labs/v2-helpers/src/numbers';
+
 import { range } from 'lodash';
-import { itPaysProtocolFeesFromInvariantGrowth } from './WeightedPoolProtocolFees.behavior';
-import { actionId } from '@balancer-labs/v2-helpers/src/models/misc/actions';
-import { deploy, getArtifact } from '@balancer-labs/v2-helpers/src/contract';
-import { MAX_UINT256, ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
-import * as expectEvent from '@balancer-labs/v2-helpers/src/test/expectEvent';
-import { ProtocolFee } from '@balancer-labs/v2-helpers/src/models/vault/types';
+import { itPaysProtocolFeesFromInvariantGrowth } from './InvariantGrowthProtocolFees.behavior';
 
 describe('WeightedPool', function () {
   let allTokens: TokenList;
-  let lp: SignerWithAddress;
 
   const MAX_TOKENS = 8;
 
   const POOL_SWAP_FEE_PERCENTAGE = fp(0.01);
   const WEIGHTS = range(1000, 1000 + MAX_TOKENS); // These will be normalized to weights that are close to each other, but different
 
-  before('setup signers', async () => {
-    [, lp] = await ethers.getSigners();
-  });
-
   sharedBeforeEach('deploy tokens', async () => {
     allTokens = await TokenList.create(MAX_TOKENS, { sorted: true, varyDecimals: true });
   });
 
   itPaysProtocolFeesFromInvariantGrowth();
 
-  describe('recovery mode', () => {
-    let pool: WeightedPool;
-    let tokens: TokenList;
-
-    const initialBalances = range(1, 3).map(fp);
-
-    sharedBeforeEach('deploy pool', async () => {
-      tokens = allTokens.subset(2);
-
-      pool = await WeightedPool.create({
-        poolType: WeightedPoolType.WEIGHTED_POOL,
-        tokens,
-        weights: WEIGHTS.slice(0, 2),
-        swapFeePercentage: POOL_SWAP_FEE_PERCENTAGE,
-      });
-
-      await pool.init({ initialBalances, recipient: lp });
-    });
-
-    context('when leaving recovery mode', () => {
-      it('sets the lastPostJoinInvariant to the current invariant', async () => {
-        // Set recovery mode to stop protocol fee calculations.
-        await pool.enableRecoveryMode();
-
-        // Perform a recovery mode exit. This will reduce the invariant but this isn't tracked due to recovery mode.
-        const preExitInvariant = await pool.getLastPostJoinExitInvariant();
-        await pool.recoveryModeExit({ from: lp, bptIn: fp(100) });
-        const realPostExitInvariant = await pool.estimateInvariant();
-
-        // Check that the real invariant is has dropped as a result of the exit.
-        expect(realPostExitInvariant).to.be.lt(preExitInvariant);
-
-        // On disabling recovery mode we expect the `lastPostJoinExitInvariant` to be be equal to the current value.
-        await pool.disableRecoveryMode();
-        const updatedLastPostJoinExitInvariant = await pool.getLastPostJoinExitInvariant();
-        expect(updatedLastPostJoinExitInvariant).to.be.almostEqual(realPostExitInvariant);
-      });
-    });
-  });
-
   describe('weights and scaling factors', () => {
     for (const numTokens of range(2, MAX_TOKENS + 1)) {
       context(`with ${numTokens} tokens`, () => {
@@ -108,199 +54,4 @@
       });
     }
   });
-
-  describe('permissioned actions', () => {
-    let pool: Contract;
-
-    sharedBeforeEach('deploy pool', async () => {
-      const vault = await Vault.create();
-
-      pool = await deploy('MockWeightedPool', {
-        args: [
-          {
-            name: '',
-            symbol: '',
-            tokens: allTokens.subset(2).addresses,
-            normalizedWeights: [fp(0.5), fp(0.5)],
-            rateProviders: new Array(2).fill(ZERO_ADDRESS),
-            assetManagers: new Array(2).fill(ZERO_ADDRESS),
-            swapFeePercentage: POOL_SWAP_FEE_PERCENTAGE,
-          },
-
-          vault.address,
-          vault.getFeesProvider().address,
-          0,
-          0,
-          ZERO_ADDRESS,
-        ],
-      });
-    });
-
-    function itIsOwnerOnly(method: string) {
-      it(`${method} can only be called by non-delegated owners`, async () => {
-        expect(await pool.isOwnerOnlyAction(await actionId(pool, method))).to.be.true;
-      });
-    }
-
-    function itIsNotOwnerOnly(method: string) {
-      it(`${method} can never be called by the owner`, async () => {
-        expect(await pool.isOwnerOnlyAction(await actionId(pool, method))).to.be.false;
-      });
-    }
-
-    const poolArtifact = getArtifact('v2-pool-weighted/WeightedPool');
-    const nonViewFunctions = poolArtifact.abi
-      .filter(
-        (elem) =>
-          elem.type === 'function' && (elem.stateMutability === 'payable' || elem.stateMutability === 'nonpayable')
-      )
-      .map((fn) => fn.name);
-
-    const expectedOwnerOnlyFunctions = ['setSwapFeePercentage', 'setAssetManagerPoolConfig'];
-
-    const expectedNotOwnerOnlyFunctions = nonViewFunctions.filter((fn) => !expectedOwnerOnlyFunctions.includes(fn));
-
-    describe('owner only actions', () => {
-      for (const expectedOwnerOnlyFunction of expectedOwnerOnlyFunctions) {
-        itIsOwnerOnly(expectedOwnerOnlyFunction);
-      }
-    });
-
-    describe('non owner only actions', () => {
-      for (const expectedNotOwnerOnlyFunction of expectedNotOwnerOnlyFunctions) {
-        itIsNotOwnerOnly(expectedNotOwnerOnlyFunction);
-      }
-    });
-  });
-
-  describe('protocol fees', () => {
-    const swapFeePercentage = fp(0.1); // 10 %
-    const protocolFeePercentage = fp(0.5); // 50 %
-    const numTokens = 2;
-
-    let tokens: TokenList;
-    let pool: WeightedPool;
-    let vaultContract: Contract;
-
-    sharedBeforeEach('deploy pool', async () => {
-      tokens = allTokens.subset(numTokens);
-      const vault = await Vault.create();
-      vaultContract = vault.instance;
-
-      await vault.setSwapFeePercentage(protocolFeePercentage);
-
-      pool = await WeightedPool.create({
-        poolType: WeightedPoolType.WEIGHTED_POOL,
-        tokens,
-        weights: WEIGHTS.slice(0, numTokens),
-        swapFeePercentage: swapFeePercentage,
-        vault,
-      });
-    });
-
-    context('once initialized', () => {
-      sharedBeforeEach('initialize pool', async () => {
-        // Init pool with equal balances so that each BPT accounts for approximately one underlying token.
-        const equalBalances = Array(numTokens).fill(fp(100));
-
-        await allTokens.mint({ to: lp.address, amount: fp(1000) });
-        await allTokens.approve({ from: lp, to: pool.vault.address });
-
-        await pool.init({ from: lp, recipient: lp.address, initialBalances: equalBalances });
-      });
-
-      context('with protocol fees', () => {
-        let unmintedBPT: BigNumber;
-
-        sharedBeforeEach('swap bpt in', async () => {
-          const amount = fp(20);
-          const tokenIn = tokens.first;
-          const tokenOut = tokens.second;
-
-          const originalInvariant = await pool.instance.getInvariant();
-
-          const singleSwap = {
-            poolId: await pool.getPoolId(),
-            kind: SwapKind.GivenIn,
-            assetIn: tokenIn.address,
-            assetOut: tokenOut.address,
-            amount: amount,
-            userData: '0x',
-          };
-
-          const funds: FundManagement = {
-            sender: lp.address,
-            recipient: lp.address,
-            fromInternalBalance: false,
-            toInternalBalance: false,
-          };
-
-          await vaultContract.connect(lp).swap(singleSwap, funds, 0, MAX_UINT256);
-
-          const postInvariant = await pool.instance.getInvariant();
-          const swapFeesPercentage = FP_SCALING_FACTOR.sub(fpDiv(originalInvariant, postInvariant));
-          const protocolOwnershipPercentage = fpMul(swapFeesPercentage, protocolFeePercentage);
-
-          unmintedBPT = fpMul(
-            await pool.totalSupply(),
-            fpDiv(protocolOwnershipPercentage, FP_SCALING_FACTOR.sub(protocolOwnershipPercentage))
-          );
-        });
-
-        it('the actual supply takes into account unminted protocol fees', async () => {
-          const totalSupply = await pool.totalSupply();
-          const expectedActualSupply = totalSupply.add(unmintedBPT);
-
-          expect(await pool.getActualSupply()).to.almostEqual(expectedActualSupply, 1e-6);
-        });
-
-        function itReactsToProtocolFeePercentageChangesCorrectly(feeType: number) {
-          it('due protocol fees are minted on protocol fee cache update', async () => {
-            await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(2));
-            const receipt = await (await pool.updateProtocolFeePercentageCache()).wait();
-
-            const event = expectEvent.inReceipt(receipt, 'Transfer', {
-              from: ZERO_ADDRESS,
-              to: (await pool.vault.getFeesCollector()).address,
-            });
-
-            expect(event.args.value).to.be.almostEqual(unmintedBPT, 1e-6);
-          });
-
-          it('repeated protocol fee cache updates do not mint any more fees', async () => {
-            await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(2));
-            await pool.updateProtocolFeePercentageCache();
-
-            await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(4));
-            const receipt = await (await pool.updateProtocolFeePercentageCache()).wait();
-
-            expectEvent.notEmitted(receipt, 'Transfer');
-          });
-
-          context('when paused', () => {
-            sharedBeforeEach('pause pool', async () => {
-              await pool.pause();
-            });
-
-            it('reverts on protocol fee cache updated', async () => {
-              await pool.vault.setFeeTypePercentage(feeType, protocolFeePercentage.div(2));
-              await expect(pool.updateProtocolFeePercentageCache()).to.be.revertedWith('PAUSED');
-            });
-          });
-        }
-
-        context('on swap protocol fee change', () => {
-          itReactsToProtocolFeePercentageChangesCorrectly(ProtocolFee.SWAP);
-        });
-
-        context('on yield protocol fee change', () => {
-          itReactsToProtocolFeePercentageChangesCorrectly(ProtocolFee.YIELD);
-        });
-
-        context('on aum protocol fee change', () => {
-          itReactsToProtocolFeePercentageChangesCorrectly(ProtocolFee.AUM);
-        });
-      });
-    });
-  });
 });
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/WeightedPoolFactory.test.ts pool-weighted/test/WeightedPoolFactory.test.ts
--- pool-weighted/test/WeightedPoolFactory.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/test/WeightedPoolFactory.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -17,8 +17,8 @@
   let tokens: TokenList;
   let factory: Contract;
   let vault: Vault;
-  let rateProviders: string[];
-  let owner: SignerWithAddress;
+  let assetManagers: string[];
+  let assetManager: SignerWithAddress, owner: SignerWithAddress;
 
   const NAME = 'Balancer Pool Token';
   const SYMBOL = 'BPT';
@@ -31,7 +31,7 @@
   let createTime: BigNumber;
 
   before('setup signers', async () => {
-    [, owner] = await ethers.getSigners();
+    [, assetManager, owner] = await ethers.getSigners();
   });
 
   sharedBeforeEach('deploy factory & tokens', async () => {
@@ -42,7 +42,8 @@
 
     tokens = await TokenList.create(['MKR', 'DAI', 'SNX', 'BAT'], { sorted: true });
 
-    rateProviders = await tokens.asyncMap(async () => (await deploy('v2-pool-utils/MockRateProvider')).address);
+    assetManagers = Array(tokens.length).fill(ZERO_ADDRESS);
+    assetManagers[0] = assetManager.address;
   });
 
   async function createPool(): Promise<Contract> {
@@ -52,7 +53,7 @@
         SYMBOL,
         tokens.addresses,
         WEIGHTS,
-        rateProviders,
+        assetManagers,
         POOL_SWAP_FEE_PERCENTAGE,
         owner.address
       )
@@ -85,16 +86,11 @@
       expect(await pool.totalSupply()).to.be.equal(0);
     });
 
-    it('sets the rate providers', async () => {
-      const providers = await pool.getRateProviders();
-      expect(providers).to.deep.eq(rateProviders);
-    });
-
-    it('sets the asset managers to zero', async () => {
-      await tokens.asyncEach(async (token) => {
+    it('sets the asset managers', async () => {
+      await tokens.asyncEach(async (token, i) => {
         const poolId = await pool.getPoolId();
         const info = await vault.getPoolTokenInfo(poolId, token);
-        expect(info.assetManager).to.equal(ZERO_ADDRESS);
+        expect(info.assetManager).to.equal(assetManagers[i]);
       });
     });
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/WeightedPoolNoAMFactory.test.ts pool-weighted/test/WeightedPoolNoAMFactory.test.ts
--- pool-weighted/test/WeightedPoolNoAMFactory.test.ts	1969-12-31 16:00:00.000000000 -0800
+++ pool-weighted/test/WeightedPoolNoAMFactory.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -0,0 +1,138 @@
+import { ethers } from 'hardhat';
+import { expect } from 'chai';
+import { BigNumber, Contract } from 'ethers';
+
+import { fp } from '@balancer-labs/v2-helpers/src/numbers';
+import { advanceTime, currentTimestamp, MONTH } from '@balancer-labs/v2-helpers/src/time';
+import * as expectEvent from '@balancer-labs/v2-helpers/src/test/expectEvent';
+import { ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
+import { deploy, deployedAt } from '@balancer-labs/v2-helpers/src/contract';
+
+import Vault from '@balancer-labs/v2-helpers/src/models/vault/Vault';
+import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
+import { toNormalizedWeights } from '@balancer-labs/balancer-js';
+import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';
+
+describe('WeightedPoolNoAMFactory', function () {
+  let tokens: TokenList;
+  let factory: Contract;
+  let vault: Vault;
+  let owner: SignerWithAddress;
+
+  const NAME = 'Balancer Pool Token';
+  const SYMBOL = 'BPT';
+  const POOL_SWAP_FEE_PERCENTAGE = fp(0.01);
+  const WEIGHTS = toNormalizedWeights([fp(30), fp(70), fp(5), fp(5)]);
+
+  const BASE_PAUSE_WINDOW_DURATION = MONTH * 3;
+  const BASE_BUFFER_PERIOD_DURATION = MONTH;
+
+  let createTime: BigNumber;
+
+  before('setup signers', async () => {
+    [, owner] = await ethers.getSigners();
+  });
+
+  sharedBeforeEach('deploy factory & tokens', async () => {
+    vault = await Vault.create();
+
+    factory = await deploy('WeightedPoolNoAMFactory', { args: [vault.address, vault.getFeesProvider().address] });
+    createTime = await currentTimestamp();
+
+    tokens = await TokenList.create(['MKR', 'DAI', 'SNX', 'BAT'], { sorted: true });
+  });
+
+  async function createPool(): Promise<Contract> {
+    const receipt = await (
+      await factory.create(NAME, SYMBOL, tokens.addresses, WEIGHTS, POOL_SWAP_FEE_PERCENTAGE, owner.address)
+    ).wait();
+
+    const event = expectEvent.inReceipt(receipt, 'PoolCreated');
+    return deployedAt('WeightedPool', event.args.pool);
+  }
+
+  describe('constructor arguments', () => {
+    let pool: Contract;
+
+    sharedBeforeEach(async () => {
+      pool = await createPool();
+    });
+
+    it('sets the vault', async () => {
+      expect(await pool.getVault()).to.equal(vault.address);
+    });
+
+    it('registers tokens in the vault', async () => {
+      const poolId = await pool.getPoolId();
+      const poolTokens = await vault.getPoolTokens(poolId);
+
+      expect(poolTokens.tokens).to.have.members(tokens.addresses);
+      expect(poolTokens.balances).to.be.zeros;
+    });
+
+    it('starts with no BPT', async () => {
+      expect(await pool.totalSupply()).to.be.equal(0);
+    });
+
+    it('sets the asset managers to zero', async () => {
+      await tokens.asyncEach(async (token) => {
+        const poolId = await pool.getPoolId();
+        const info = await vault.getPoolTokenInfo(poolId, token);
+        expect(info.assetManager).to.equal(ZERO_ADDRESS);
+      });
+    });
+
+    it('sets swap fee', async () => {
+      expect(await pool.getSwapFeePercentage()).to.equal(POOL_SWAP_FEE_PERCENTAGE);
+    });
+
+    it('sets the owner ', async () => {
+      expect(await pool.getOwner()).to.equal(owner.address);
+    });
+
+    it('sets the name', async () => {
+      expect(await pool.name()).to.equal('Balancer Pool Token');
+    });
+
+    it('sets the symbol', async () => {
+      expect(await pool.symbol()).to.equal('BPT');
+    });
+
+    it('sets the decimals', async () => {
+      expect(await pool.decimals()).to.equal(18);
+    });
+  });
+
+  describe('temporarily pausable', () => {
+    it('pools have the correct window end times', async () => {
+      const pool = await createPool();
+      const { pauseWindowEndTime, bufferPeriodEndTime } = await pool.getPausedState();
+
+      expect(pauseWindowEndTime).to.equal(createTime.add(BASE_PAUSE_WINDOW_DURATION));
+      expect(bufferPeriodEndTime).to.equal(createTime.add(BASE_PAUSE_WINDOW_DURATION + BASE_BUFFER_PERIOD_DURATION));
+    });
+
+    it('multiple pools have the same window end times', async () => {
+      const firstPool = await createPool();
+      await advanceTime(BASE_PAUSE_WINDOW_DURATION / 3);
+      const secondPool = await createPool();
+
+      const { firstPauseWindowEndTime, firstBufferPeriodEndTime } = await firstPool.getPausedState();
+      const { secondPauseWindowEndTime, secondBufferPeriodEndTime } = await secondPool.getPausedState();
+
+      expect(firstPauseWindowEndTime).to.equal(secondPauseWindowEndTime);
+      expect(firstBufferPeriodEndTime).to.equal(secondBufferPeriodEndTime);
+    });
+
+    it('pools created after the pause window end date have no buffer period', async () => {
+      await advanceTime(BASE_PAUSE_WINDOW_DURATION + 1);
+
+      const pool = await createPool();
+      const { pauseWindowEndTime, bufferPeriodEndTime } = await pool.getPausedState();
+      const now = await currentTimestamp();
+
+      expect(pauseWindowEndTime).to.equal(now);
+      expect(bufferPeriodEndTime).to.equal(now);
+    });
+  });
+});
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/WeightedPoolProtocolFees.behavior.ts pool-weighted/test/WeightedPoolProtocolFees.behavior.ts
--- pool-weighted/test/WeightedPoolProtocolFees.behavior.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/test/WeightedPoolProtocolFees.behavior.ts	1969-12-31 16:00:00.000000000 -0800
@@ -1,260 +0,0 @@
-import { WeightedPoolEncoder } from '@balancer-labs/balancer-js';
-import { deploy } from '@balancer-labs/v2-helpers/src/contract';
-import { calculateInvariant } from '@balancer-labs/v2-helpers/src/models/pools/weighted/math';
-import { WeightedPoolType } from '@balancer-labs/v2-helpers/src/models/pools/weighted/types';
-import WeightedPool from '@balancer-labs/v2-helpers/src/models/pools/weighted/WeightedPool';
-import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
-import Vault from '@balancer-labs/v2-helpers/src/models/vault/Vault';
-import { bn, fp, fpDiv } from '@balancer-labs/v2-helpers/src/numbers';
-import { expectEqualWithError } from '@balancer-labs/v2-helpers/src/test/relativeError';
-import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';
-import { expect } from 'chai';
-import { BigNumber, Contract } from 'ethers';
-import { ethers } from 'hardhat';
-import { random, range } from 'lodash';
-
-export function itPaysProtocolFeesFromInvariantGrowth(): void {
-  const MAX_TOKENS = 8;
-  const WEIGHTS = range(1000, 1000 + MAX_TOKENS); // These will be normalized to weights that are close to each other, but different
-  const POOL_SWAP_FEE_PERCENTAGE = fp(0.01);
-
-  const numTokens = MAX_TOKENS;
-
-  let vault: Vault;
-  let pool: WeightedPool;
-  let tokens: TokenList;
-  let rateProviders: Contract[];
-  let protocolFeesCollector: string;
-
-  let lp: SignerWithAddress;
-
-  describe('invariant growth protocol fees', () => {
-    before('setup', async () => {
-      [, lp] = await ethers.getSigners();
-    });
-
-    const protocolFeePercentage = fp(0.3); // 30 %
-    const initialBalances = range(1, numTokens + 1).map(fp);
-    const initialBalanceGrowth = bn(3);
-
-    sharedBeforeEach(async () => {
-      vault = await Vault.create({ mocked: true });
-      tokens = await TokenList.create(numTokens, { sorted: true, varyDecimals: true });
-      rateProviders = await tokens.asyncMap(() => deploy('v2-pool-utils/MockRateProvider'));
-
-      await vault.setSwapFeePercentage(protocolFeePercentage);
-      ({ address: protocolFeesCollector } = await vault.getFeesCollector());
-
-      pool = await WeightedPool.create({
-        vault,
-        poolType: WeightedPoolType.WEIGHTED_POOL,
-        tokens,
-        weights: WEIGHTS.slice(0, numTokens),
-        rateProviders,
-        swapFeePercentage: POOL_SWAP_FEE_PERCENTAGE,
-      });
-    });
-
-    describe('last post join/exit invariant', () => {
-      it('is set on initialization', async () => {
-        await pool.init({ initialBalances });
-        expectEqualWithError(await pool.getLastPostJoinExitInvariant(), await pool.estimateInvariant());
-      });
-
-      context('once initialized and with accumulated fees', () => {
-        sharedBeforeEach('initialize pool', async () => {
-          await pool.init({ initialBalances, recipient: lp });
-        });
-
-        sharedBeforeEach('accumulate fees by increasing balance', async () => {
-          await pool.vault.updateBalances(
-            pool.poolId,
-            initialBalances.map((x) => x.mul(initialBalanceGrowth))
-          );
-        });
-
-        itIsUpdatedByJoins();
-
-        itIsUpdatedByExits();
-
-        function itIsUpdatedByJoins() {
-          it('is updated by joins', async () => {
-            // We only test with a proportional join, since all joins are treated equally
-            await pool.join({
-              data: WeightedPoolEncoder.joinAllTokensInForExactBPTOut((await pool.totalSupply()).div(2)),
-              from: lp,
-            });
-
-            expectEqualWithError(await pool.getLastPostJoinExitInvariant(), await pool.estimateInvariant());
-          });
-        }
-
-        function itIsUpdatedByExits() {
-          it('is updated by exits', async () => {
-            // We only test with a proportional exit, since all exits are treated equally.
-            await pool.exit({
-              data: WeightedPoolEncoder.exitExactBPTInForTokensOut((await pool.totalSupply()).div(2)),
-              from: lp,
-            });
-
-            expectEqualWithError(await pool.getLastPostJoinExitInvariant(), await pool.estimateInvariant());
-          });
-        }
-      });
-    });
-
-    describe('ath rate product', () => {
-      context('when the pool is exempt from yield fees', () => {
-        let yieldFeeExemptPool: WeightedPool;
-
-        sharedBeforeEach(async () => {
-          yieldFeeExemptPool = await WeightedPool.create({
-            poolType: WeightedPoolType.WEIGHTED_POOL,
-            tokens,
-            weights: WEIGHTS.slice(0, numTokens),
-            swapFeePercentage: POOL_SWAP_FEE_PERCENTAGE,
-          });
-        });
-
-        it('is not set on initialization', async () => {
-          await yieldFeeExemptPool.init({ initialBalances });
-
-          expect(await yieldFeeExemptPool.instance.getATHRateProduct()).to.be.eq(0);
-        });
-      });
-
-      context('when the pool pays yield fees', () => {
-        it('is set on initialization', async () => {
-          await pool.init({ initialBalances });
-
-          const rates = pool.weights.map(() => fp(1));
-          const expectedRateProduct = calculateInvariant(rates, pool.weights);
-          expect(await pool.instance.getATHRateProduct()).to.be.almostEqual(expectedRateProduct, 0.0000001);
-        });
-
-        context('once initialized', () => {
-          sharedBeforeEach('initialize pool', async () => {
-            await pool.init({ initialBalances, recipient: lp });
-          });
-
-          context('when rates increase', () => {
-            let expectedRateProduct: BigNumber;
-            sharedBeforeEach('accumulate fees by increasing balance', async () => {
-              const rates = rateProviders.map(() => fp(random(1.0, 5.0)));
-
-              for (const [index, provider] of rateProviders.entries()) {
-                if (typeof provider !== 'string') await provider.mockRate(rates[index]);
-              }
-
-              expectedRateProduct = calculateInvariant(rates, pool.weights);
-            });
-
-            it('is updated by joins', async () => {
-              // We only test with a proportional join, since all joins are treated equally
-              await pool.join({
-                data: WeightedPoolEncoder.joinAllTokensInForExactBPTOut((await pool.totalSupply()).div(2)),
-                from: lp,
-              });
-
-              expectEqualWithError(await pool.instance.getATHRateProduct(), expectedRateProduct);
-            });
-
-            it('is updated by exits', async () => {
-              // We only test with a proportional exit, since all exits are treated equally.
-              await pool.exit({
-                data: WeightedPoolEncoder.exitExactBPTInForTokensOut((await pool.totalSupply()).div(2)),
-                from: lp,
-              });
-
-              expectEqualWithError(await pool.instance.getATHRateProduct(), expectedRateProduct);
-            });
-          });
-
-          context('when rates decrease', () => {
-            let expectedRateProduct: BigNumber;
-            sharedBeforeEach('accumulate fees by increasing balance', async () => {
-              const rates = rateProviders.map(() => fp(random(0.5, 1.0)));
-
-              for (const [index, provider] of rateProviders.entries()) {
-                if (typeof provider !== 'string') await provider.mockRate(rates[index]);
-              }
-
-              expectedRateProduct = await pool.instance.getATHRateProduct();
-            });
-
-            it('is unaffected by joins', async () => {
-              // We only test with a proportional join, since all joins are treated equally
-              await pool.join({
-                data: WeightedPoolEncoder.joinAllTokensInForExactBPTOut((await pool.totalSupply()).div(2)),
-                from: lp,
-              });
-
-              expectEqualWithError(await pool.instance.getATHRateProduct(), expectedRateProduct);
-            });
-
-            it('is unaffected by exits', async () => {
-              // We only test with a proportional exit, since all exits are treated equally.
-              await pool.exit({
-                data: WeightedPoolEncoder.exitExactBPTInForTokensOut((await pool.totalSupply()).div(2)),
-                from: lp,
-              });
-
-              expectEqualWithError(await pool.instance.getATHRateProduct(), expectedRateProduct);
-            });
-          });
-        });
-      });
-    });
-
-    describe('protocol fees', () => {
-      async function protocolFeesPaid(): Promise<BigNumber> {
-        const previousProtocolFeeCollectorBalance = await pool.balanceOf(protocolFeesCollector);
-
-        // We trigger protocol fee payment by executing a proportional exit for 0 BPT
-        await pool.exit({
-          data: WeightedPoolEncoder.exitExactBPTInForTokensOut(fp(0)),
-          protocolFeePercentage,
-        });
-
-        const currentProtocolFeeCollectorBalance = await pool.balanceOf(protocolFeesCollector);
-        return currentProtocolFeeCollectorBalance.sub(previousProtocolFeeCollectorBalance);
-      }
-
-      context('once initialized and with accumulated fees', () => {
-        sharedBeforeEach('initialize pool', async () => {
-          await pool.init({ initialBalances, recipient: lp });
-        });
-
-        sharedBeforeEach('accumulate fees by increasing balance', async () => {
-          await pool.vault.updateBalances(
-            pool.poolId,
-            initialBalances.map((x) => x.mul(initialBalanceGrowth))
-          );
-        });
-
-        context('when not paused', () => {
-          it('pays protocol fees', async () => {
-            const fees = await protocolFeesPaid();
-            const totalBPT = await pool.totalSupply();
-
-            // Balances increased by initialBalanceGrowth, and protocol was due protocolFeePercentage of that. It should
-            // therefore have been paid (initialBalanceGrowth - 1) * protocolFeePercentage / initialBalanceGrowth of the
-            // total BPT.
-
-            const bptOwnership = fpDiv(fees, totalBPT);
-            const expectedOwnership = initialBalanceGrowth.sub(1).mul(protocolFeePercentage).div(initialBalanceGrowth);
-
-            await expectEqualWithError(bptOwnership, expectedOwnership);
-          });
-
-          it('does not pay fees again until more are accumulated', async () => {
-            await protocolFeesPaid();
-
-            const secondPayment = await protocolFeesPaid();
-            expect(secondPayment).to.equal(0);
-          });
-        });
-      });
-    });
-  });
-}
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts pool-weighted/test/YieldProtocolFees.test.ts pool-weighted/test/YieldProtocolFees.test.ts
--- pool-weighted/test/YieldProtocolFees.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ pool-weighted/test/YieldProtocolFees.test.ts	1969-12-31 16:00:00.000000000 -0800
@@ -1,213 +0,0 @@
-import { expect } from 'chai';
-import { BigNumber, Contract } from 'ethers';
-import { deploy } from '@balancer-labs/v2-helpers/src/contract';
-import { fp, fpDiv, fpMul } from '@balancer-labs/v2-helpers/src/numbers';
-import Vault from '@balancer-labs/v2-helpers/src/models/vault/Vault';
-import TokenList from '@balancer-labs/v2-helpers/src/models/tokens/TokenList';
-import { ANY_ADDRESS, ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
-import { random, range } from 'lodash';
-import { toNormalizedWeights } from '@balancer-labs/balancer-js';
-import { calculateInvariant } from '@balancer-labs/v2-helpers/src/models/pools/weighted/math';
-import { actionId } from '@balancer-labs/v2-helpers/src/models/misc/actions';
-import { ProtocolFee } from '@balancer-labs/v2-helpers/src/models/vault/types';
-import TypesConverter from '@balancer-labs/v2-helpers/src/models/types/TypesConverter';
-
-const randomFloat = (min: number, max: number) => random(min, max, true);
-
-describe('WeightedPoolProtocolFees (Yield)', () => {
-  let vault: Vault;
-  let pool: Contract;
-  let rateProviders: (Contract | string)[];
-
-  const NAME = 'Balancer Pool Token';
-  const SYMBOL = 'BPT';
-  const POOL_SWAP_FEE_PERCENTAGE = fp(0.01);
-  const PROTOCOL_YIELD_FEE_PERCENTAGE = fp(0.5);
-
-  before('deploy lib', async () => {
-    vault = await Vault.create();
-
-    if (!vault.admin) throw new Error('Vault has no admin');
-    const protocolFeesProvider = vault.protocolFeesProvider;
-    const action = await actionId(protocolFeesProvider, 'setFeeTypePercentage');
-    await vault.grantPermissionsGlobally([action], vault.admin);
-    await protocolFeesProvider
-      .connect(vault.admin)
-      .setFeeTypePercentage(ProtocolFee.YIELD, PROTOCOL_YIELD_FEE_PERCENTAGE);
-  });
-
-  async function deployPool(numTokens: number, { payYieldFees } = { payYieldFees: true }) {
-    const tokens = await TokenList.create(numTokens, { sorted: true });
-    if (payYieldFees) {
-      rateProviders = await tokens.asyncMap(() => deploy('v2-pool-utils/MockRateProvider'));
-    } else {
-      rateProviders = tokens.map(() => ZERO_ADDRESS);
-    }
-
-    pool = await deploy('MockWeightedPoolProtocolFees', {
-      args: [
-        vault.address,
-        vault.protocolFeesProvider.address,
-        NAME,
-        SYMBOL,
-        tokens.addresses,
-        TypesConverter.toAddresses(rateProviders),
-        tokens.map(() => ZERO_ADDRESS),
-        POOL_SWAP_FEE_PERCENTAGE,
-        0,
-        0,
-        ZERO_ADDRESS,
-      ],
-    });
-  }
-
-  for (let numTokens = 2; numTokens <= 8; numTokens++) {
-    describe(`for a ${numTokens} token pool`, () => {
-      sharedBeforeEach('deploy pool', async () => {
-        await deployPool(numTokens);
-      });
-
-      describe('constructor', () => {
-        it('sets the rate providers', async () => {
-          const rateProviderAddresses = TypesConverter.toAddresses(rateProviders);
-          const providers = await pool.getRateProviders();
-
-          expect(providers).to.deep.eq(rateProviderAddresses);
-        });
-      });
-
-      describe('getYieldFeeExemption', () => {
-        it('returns the expected value', async () => {
-          // We force a check of this case as it would otherwise only occur once in every 2**numTokens attempts.
-          const zeroRateProviders = Array.from({ length: numTokens }, () => ZERO_ADDRESS);
-          expect(await pool.getYieldFeeExemption(zeroRateProviders)).to.be.true;
-
-          for (let i = 0; i < 10; i++) {
-            // Randomly create a set of rate providers which are a mix of real or zero addresses.
-            const rateProviders = Array.from({ length: numTokens }, () =>
-              random(0, 1.0) < 0.5 ? ANY_ADDRESS : ZERO_ADDRESS
-            );
-
-            // We expect the pool to be exempt if every rate provider is the zero address
-            const isExempt = rateProviders.every((rateProvider) => rateProvider === ZERO_ADDRESS);
-
-            expect(await pool.getYieldFeeExemption(rateProviders)).to.be.eq(isExempt);
-          }
-        });
-      });
-
-      describe('getRateProduct', () => {
-        let rates: BigNumber[];
-
-        sharedBeforeEach(async () => {
-          rates = rateProviders.map(() => fp(randomFloat(1, 5)));
-
-          for (const [index, provider] of rateProviders.entries()) {
-            if (typeof provider !== 'string') await provider.mockRate(rates[index]);
-          }
-        });
-
-        it("returns the weighted product of the tokens' rates", async () => {
-          const normalizedWeights = toNormalizedWeights(range(numTokens).map(() => fp(random(1, 5))));
-          const expectedRateProduct = calculateInvariant(rates, normalizedWeights);
-
-          const rateProduct = await pool.getRateProduct(normalizedWeights);
-          expect(rateProduct).to.be.almostEqual(expectedRateProduct, 0.0001);
-        });
-      });
-
-      describe('getYieldProtocolFee', () => {
-        let normalizedWeights: BigNumber[];
-        sharedBeforeEach('choose weights', async () => {
-          normalizedWeights = toNormalizedWeights(rateProviders.map(() => fp(random(1, 5))));
-        });
-
-        context('when pool pays fees on yield', () => {
-          sharedBeforeEach('initialize athRateProduct', async () => {
-            const initialRateProduct = await pool.getRateProduct(toNormalizedWeights(rateProviders.map(() => fp(1))));
-            await pool.updateATHRateProduct(initialRateProduct);
-          });
-
-          context('when rate product has increased', () => {
-            let rates: BigNumber[];
-            sharedBeforeEach('set rates', async () => {
-              rates = rateProviders.map(() => fp(randomFloat(1, 2)));
-
-              for (const [index, provider] of rateProviders.entries()) {
-                if (typeof provider !== 'string') await provider.mockRate(rates[index]);
-              }
-            });
-
-            it('it returns the updated athRateProduct', async () => {
-              const { athRateProduct } = await pool.getYieldProtocolFee(normalizedWeights, fp(1));
-
-              const expectedRateProduct = calculateInvariant(rates, normalizedWeights);
-              expect(athRateProduct).to.be.almostEqual(expectedRateProduct, 0.0001);
-            });
-
-            it('it returns the expected amount of protocol fees', async () => {
-              const athRateProduct = await pool.getATHRateProduct();
-
-              const currentSupply = fp(randomFloat(1, 5));
-              const { yieldProtocolFees } = await pool.getYieldProtocolFee(normalizedWeights, currentSupply);
-
-              const rateProductGrowth = fpDiv(calculateInvariant(rates, normalizedWeights), athRateProduct);
-              const yieldPercentage = fp(1).sub(fpDiv(fp(1), rateProductGrowth));
-              const protocolYieldFeesPercentage = fpMul(yieldPercentage, PROTOCOL_YIELD_FEE_PERCENTAGE);
-
-              const expectedProtocolFees = currentSupply
-                .mul(protocolYieldFeesPercentage)
-                .div(fp(1).sub(protocolYieldFeesPercentage));
-              expect(yieldProtocolFees).to.be.almostEqual(expectedProtocolFees, 0.0001);
-            });
-          });
-
-          context('when rate product has decreased', () => {
-            let rates: BigNumber[];
-            sharedBeforeEach('set rates', async () => {
-              rates = rateProviders.map(() => fp(random(0.5, 1)));
-
-              for (const [index, provider] of rateProviders.entries()) {
-                if (typeof provider !== 'string') await provider.mockRate(rates[index]);
-              }
-            });
-
-            it('it returns zero value for athRateProduct', async () => {
-              const { athRateProduct } = await pool.getYieldProtocolFee(normalizedWeights, fp(1));
-
-              expect(athRateProduct).to.be.eq(0);
-            });
-
-            it('it returns zero', async () => {
-              const { yieldProtocolFees } = await pool.getYieldProtocolFee(normalizedWeights, fp(1));
-
-              expect(yieldProtocolFees).to.be.eq(0);
-            });
-          });
-        });
-
-        context('when pool does not pay fees on yield', () => {
-          sharedBeforeEach('deploy fee-exempt pool', async () => {
-            await deployPool(numTokens, { payYieldFees: false });
-          });
-
-          sharedBeforeEach('check athRateProduct is uninitialized', async () => {
-            expect(await pool.getATHRateProduct()).to.be.eq(0);
-          });
-
-          it('returns zero protocol fees', async () => {
-            const { yieldProtocolFees } = await pool.getYieldProtocolFee(normalizedWeights, fp(1));
-
-            expect(yieldProtocolFees).to.be.eq(0);
-          });
-
-          it('returns zero value for athRateProduct', async () => {
-            const { athRateProduct } = await pool.getYieldProtocolFee(normalizedWeights, fp(1));
-
-            expect(athRateProduct).to.be.eq(0);
-          });
-        });
-      });
-    });
-  }
-});
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/Authentication.sol solidity-utils/contracts/helpers/Authentication.sol
--- solidity-utils/contracts/helpers/Authentication.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/helpers/Authentication.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
 
 /**
  * @dev Building block for performing access control on external functions.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/CodeDeployer.sol solidity-utils/contracts/helpers/CodeDeployer.sol
--- solidity-utils/contracts/helpers/CodeDeployer.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/helpers/CodeDeployer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Library used to deploy contracts with specific code. This can be used for long-term storage of immutable data as
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/EOASignaturesValidator.sol solidity-utils/contracts/helpers/EOASignaturesValidator.sol
--- solidity-utils/contracts/helpers/EOASignaturesValidator.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/helpers/EOASignaturesValidator.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/ISignaturesValidator.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/ISignaturesValidator.sol";
 
 import "../openzeppelin/EIP712.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/ERC20Helpers.sol solidity-utils/contracts/helpers/ERC20Helpers.sol
--- solidity-utils/contracts/helpers/ERC20Helpers.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/helpers/ERC20Helpers.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/vault/IAsset.sol";
 
 // solhint-disable
 
@@ -61,19 +60,6 @@
     newTokens[numTokens] = newToken;
 }
 
-function _findTokenIndex(IERC20[] memory tokens, IERC20 token) pure returns (uint256) {
-    // Note that while we know tokens are initially sorted, we cannot assume this will hold throughout
-    // the pool's lifetime, as pools with mutable tokens can append and remove tokens in any order.
-    uint256 tokensLength = tokens.length;
-    for (uint256 i = 0; i < tokensLength; i++) {
-        if (tokens[i] == token) {
-            return i;
-        }
-    }
-
-    _revert(Errors.INVALID_TOKEN);
-}
-
 function _getSortedTokenIndexes(
     IERC20 tokenA,
     IERC20 tokenB,
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol
--- solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "./EOASignaturesValidator.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/InputHelpers.sol solidity-utils/contracts/helpers/InputHelpers.sol
--- solidity-utils/contracts/helpers/InputHelpers.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/helpers/InputHelpers.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 library InputHelpers {
     function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/OptionalOnlyCaller.sol solidity-utils/contracts/helpers/OptionalOnlyCaller.sol
--- solidity-utils/contracts/helpers/OptionalOnlyCaller.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/helpers/OptionalOnlyCaller.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IOptionalOnlyCaller.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/IOptionalOnlyCaller.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "./SignaturesValidator.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/SignaturesValidator.sol solidity-utils/contracts/helpers/SignaturesValidator.sol
--- solidity-utils/contracts/helpers/SignaturesValidator.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/helpers/SignaturesValidator.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC1271.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC1271.sol";
 
 import "./EOASignaturesValidator.sol";
 import "../openzeppelin/Address.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/SingletonAuthentication.sol solidity-utils/contracts/helpers/SingletonAuthentication.sol
--- solidity-utils/contracts/helpers/SingletonAuthentication.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/helpers/SingletonAuthentication.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IAuthorizerAdaptor.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "./Authentication.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/TemporarilyPausable.sol solidity-utils/contracts/helpers/TemporarilyPausable.sol
--- solidity-utils/contracts/helpers/TemporarilyPausable.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/helpers/TemporarilyPausable.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/ITemporarilyPausable.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/ITemporarilyPausable.sol";
 
 /**
  * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/helpers/WordCodec.sol solidity-utils/contracts/helpers/WordCodec.sol
--- solidity-utils/contracts/helpers/WordCodec.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/helpers/WordCodec.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "../math/Math.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/math/FixedPoint.sol solidity-utils/contracts/math/FixedPoint.sol
--- solidity-utils/contracts/math/FixedPoint.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/math/FixedPoint.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 import "./LogExpMath.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/math/LogExpMath.sol solidity-utils/contracts/math/LogExpMath.sol
--- solidity-utils/contracts/math/LogExpMath.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/math/LogExpMath.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /* solhint-disable */
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/math/Math.sol solidity-utils/contracts/math/Math.sol
--- solidity-utils/contracts/math/Math.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/math/Math.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/Address.sol solidity-utils/contracts/openzeppelin/Address.sol
--- solidity-utils/contracts/openzeppelin/Address.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/Address.sol	2022-09-16 02:18:01.000000000 -0700
@@ -5,7 +5,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Collection of functions related to the address type
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/Create2.sol solidity-utils/contracts/openzeppelin/Create2.sol
--- solidity-utils/contracts/openzeppelin/Create2.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/Create2.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/ERC20.sol solidity-utils/contracts/openzeppelin/ERC20.sol
--- solidity-utils/contracts/openzeppelin/ERC20.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/ERC20.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,8 +2,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 import "./SafeMath.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/ERC20Permit.sol solidity-utils/contracts/openzeppelin/ERC20Permit.sol
--- solidity-utils/contracts/openzeppelin/ERC20Permit.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/ERC20Permit.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20Permit.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20Permit.sol";
 
 import "./ERC20.sol";
 import "../helpers/EOASignaturesValidator.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/EnumerableMap.sol solidity-utils/contracts/openzeppelin/EnumerableMap.sol
--- solidity-utils/contracts/openzeppelin/EnumerableMap.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/EnumerableMap.sol	2022-09-16 02:18:01.000000000 -0700
@@ -11,8 +11,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 /**
  * @dev Library for managing an enumerable variant of Solidity's
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/EnumerableSet.sol solidity-utils/contracts/openzeppelin/EnumerableSet.sol
--- solidity-utils/contracts/openzeppelin/EnumerableSet.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/EnumerableSet.sol	2022-09-16 02:18:01.000000000 -0700
@@ -7,7 +7,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Library for managing
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/Ownable.sol solidity-utils/contracts/openzeppelin/Ownable.sol
--- solidity-utils/contracts/openzeppelin/Ownable.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/Ownable.sol	2022-09-16 02:18:01.000000000 -0700
@@ -5,7 +5,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Contract module which provides a basic access control mechanism, where
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol
--- solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol	2022-09-16 02:18:01.000000000 -0700
@@ -6,7 +6,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Contract module that helps prevent reentrant calls to a function.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/SafeCast.sol solidity-utils/contracts/openzeppelin/SafeCast.sol
--- solidity-utils/contracts/openzeppelin/SafeCast.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/SafeCast.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/SafeERC20.sol solidity-utils/contracts/openzeppelin/SafeERC20.sol
--- solidity-utils/contracts/openzeppelin/SafeERC20.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/SafeERC20.sol	2022-09-16 02:18:01.000000000 -0700
@@ -6,8 +6,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 /**
  * @title SafeERC20
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/openzeppelin/SafeMath.sol solidity-utils/contracts/openzeppelin/SafeMath.sol
--- solidity-utils/contracts/openzeppelin/SafeMath.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/openzeppelin/SafeMath.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 /**
  * @dev Wrappers over Solidity's arithmetic operations with added overflow
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/test/BalancerErrorsMock.sol solidity-utils/contracts/test/BalancerErrorsMock.sol
--- solidity-utils/contracts/test/BalancerErrorsMock.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/test/BalancerErrorsMock.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
 contract BalancerErrorsMock {
     function fail(uint256 code) external pure {
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/test/ERC1271Mock.sol solidity-utils/contracts/test/ERC1271Mock.sol
--- solidity-utils/contracts/test/ERC1271Mock.sol	2022-09-16 02:04:26.000000000 -0700
+++ solidity-utils/contracts/test/ERC1271Mock.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC1271.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC1271.sol";
 
 contract ERC1271Mock is IERC1271 {
     mapping(bytes32 => bool) private _approved;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/test/EnumerableMapMock.sol solidity-utils/contracts/test/EnumerableMapMock.sol
--- solidity-utils/contracts/test/EnumerableMapMock.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/test/EnumerableMapMock.sol	2022-09-16 02:18:01.000000000 -0700
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 import "../openzeppelin/EnumerableMap.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts solidity-utils/contracts/test/SingletonAuthenticationMock.sol solidity-utils/contracts/test/SingletonAuthenticationMock.sol
--- solidity-utils/contracts/test/SingletonAuthenticationMock.sol	2022-06-22 10:15:28.000000000 -0700
+++ solidity-utils/contracts/test/SingletonAuthenticationMock.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "../helpers/SingletonAuthentication.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/BALTokenHolder.sol standalone-utils/contracts/BALTokenHolder.sol
--- standalone-utils/contracts/BALTokenHolder.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/BALTokenHolder.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,12 +14,12 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerToken.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBALTokenHolder.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerToken.sol";
+import "../../interfaces/contracts/standalone-utils/IBALTokenHolder.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 /**
  * @dev This contract simply holds the BAL token and delegates to Balancer Governance the permission to withdraw it. It
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/BALTokenHolderFactory.sol standalone-utils/contracts/BALTokenHolderFactory.sol
--- standalone-utils/contracts/BALTokenHolderFactory.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/BALTokenHolderFactory.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerToken.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBALTokenHolderFactory.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerToken.sol";
+import "../../interfaces/contracts/standalone-utils/IBALTokenHolderFactory.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
 
 import "./BALTokenHolder.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/BalancerQueries.sol standalone-utils/contracts/BalancerQueries.sol
--- standalone-utils/contracts/BalancerQueries.sol	2022-09-16 02:04:26.000000000 -0700
+++ standalone-utils/contracts/BalancerQueries.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,16 +15,16 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IBasePool.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol";
+import "../../interfaces/contracts/standalone-utils/IBalancerQueries.sol";
 
-import "@balancer-labs/v2-vault/contracts/AssetHelpers.sol";
+import "../../vault/contracts/AssetHelpers.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
 
 /**
  * @dev This contract simply builds on top of the Balancer V2 architecture to provide useful helpers to users.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/ProtocolFeePercentagesProvider.sol standalone-utils/contracts/ProtocolFeePercentagesProvider.sol
--- standalone-utils/contracts/ProtocolFeePercentagesProvider.sol	2022-09-16 02:04:26.000000000 -0700
+++ standalone-utils/contracts/ProtocolFeePercentagesProvider.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,11 +15,11 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IProtocolFeesCollector.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
+import "../../interfaces/contracts/vault/IProtocolFeesCollector.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeePercentagesProvider.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeCast.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeCast.sol";
 
 contract ProtocolFeePercentagesProvider is IProtocolFeePercentagesProvider, SingletonAuthentication {
     using SafeCast for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/ProtocolFeesWithdrawer.sol standalone-utils/contracts/ProtocolFeesWithdrawer.sol
--- standalone-utils/contracts/ProtocolFeesWithdrawer.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/ProtocolFeesWithdrawer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,11 +14,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IProtocolFeesWithdrawer.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IProtocolFeesWithdrawer.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
 
 /**
  * @author Balancer Labs
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/AaveWrapping.sol standalone-utils/contracts/relayer/AaveWrapping.sol
--- standalone-utils/contracts/relayer/AaveWrapping.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/relayer/AaveWrapping.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IStaticATokenLM.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IStaticATokenLM.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/BalancerRelayer.sol standalone-utils/contracts/relayer/BalancerRelayer.sol
--- standalone-utils/contracts/relayer/BalancerRelayer.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/relayer/BalancerRelayer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
+import "../../interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 /**
  * @title Balancer Relayer
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/BaseRelayerLibrary.sol standalone-utils/contracts/relayer/BaseRelayerLibrary.sol
--- standalone-utils/contracts/relayer/BaseRelayerLibrary.sol	2022-09-16 02:04:26.000000000 -0700
+++ standalone-utils/contracts/relayer/BaseRelayerLibrary.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IBalancerRelayer.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "./IBaseRelayerLibrary.sol";
 import "./BalancerRelayer.sol";
@@ -77,21 +77,10 @@
      * @dev This is needed to avoid having to send intermediate tokens back to the user
      */
     function approveVault(IERC20 token, uint256 amount) public override {
-        if (_isChainedReference(amount)) {
-            amount = _getChainedReferenceValue(amount);
-        }
         // TODO: gas golf this a bit
         token.approve(address(getVault()), amount);
     }
 
-    /**
-     * @notice Returns the amount referenced by chained reference `ref`.
-     * @dev It does not alter the reference (even if it's marked as temporary).
-     */
-    function peekChainedReferenceValue(uint256 ref) public view override returns (uint256 value) {
-        (, value) = _peekChainedReferenceValue(ref);
-    }
-
     function _pullToken(
         address sender,
         IERC20 token,
@@ -129,19 +118,6 @@
      * @dev Returns true if `amount` is not actually an amount, but rather a chained reference.
      */
     function _isChainedReference(uint256 amount) internal pure override returns (bool) {
-        // First 3 nibbles are enough to determine if it's a chained reference.
-        return
-            (amount & 0xfff0000000000000000000000000000000000000000000000000000000000000) ==
-            0xba10000000000000000000000000000000000000000000000000000000000000;
-    }
-
-    /**
-     * @dev Returns true if `ref` is temporary reference, i.e. to be deleted after reading it.
-     */
-    function _isTemporaryChainedReference(uint256 amount) internal pure returns (bool) {
-        // First 3 nibbles determine if it's a chained reference.
-        // If the 4th nibble is 0 it is temporary; otherwise it is considered read-only.
-        // In practice, we shall use '0xba11' for read-only references.
         return
             (amount & 0xffff000000000000000000000000000000000000000000000000000000000000) ==
             0xba10000000000000000000000000000000000000000000000000000000000000;
@@ -151,7 +127,7 @@
      * @dev Stores `value` as the amount referenced by chained reference `ref`.
      */
     function _setChainedReferenceValue(uint256 ref, uint256 value) internal override {
-        bytes32 slot = _getStorageSlot(ref);
+        bytes32 slot = _getTempStorageSlot(ref);
 
         // Since we do manual calculation of storage slots, it is easier (and cheaper) to rely on internal assembly to
         // access it.
@@ -162,42 +138,25 @@
     }
 
     /**
-     * @dev Returns the amount referenced by chained reference `ref`.
-     * If the reference is temporary, it will be cleared after reading it, so they can each only be read once.
-     * If the reference is not temporary (i.e. read-only), it will not be cleared after reading it
-     * (see `_isTemporaryChainedReference` function).
-     */
-    function _getChainedReferenceValue(uint256 ref) internal override returns (uint256) {
-        (bytes32 slot, uint256 value) = _peekChainedReferenceValue(ref);
-
-        if (_isTemporaryChainedReference(ref)) {
-            // solhint-disable-next-line no-inline-assembly
-            assembly {
-                sstore(slot, 0)
-            }
-        }
-        return value;
-    }
-
-    /**
-     * @dev Returns the storage slot for reference `ref` as well as the amount referenced by it.
-     * It does not alter the reference (even if it's marked as temporary).
+     * @dev Returns the amount referenced by chained reference `ref`. Reading an amount clears it, so they can each
+     * only be read once.
      */
-    function _peekChainedReferenceValue(uint256 ref) private view returns (bytes32 slot, uint256 value) {
-        slot = _getStorageSlot(ref);
+    function _getChainedReferenceValue(uint256 ref) internal override returns (uint256 value) {
+        bytes32 slot = _getTempStorageSlot(ref);
 
         // Since we do manual calculation of storage slots, it is easier (and cheaper) to rely on internal assembly to
         // access it.
         // solhint-disable-next-line no-inline-assembly
         assembly {
             value := sload(slot)
+            sstore(slot, 0)
         }
     }
 
     // solhint-disable-next-line var-name-mixedcase
     bytes32 private immutable _TEMP_STORAGE_SUFFIX = keccak256("balancer.base-relayer-library");
 
-    function _getStorageSlot(uint256 ref) private view returns (bytes32) {
+    function _getTempStorageSlot(uint256 ref) private view returns (bytes32) {
         // This replicates the mechanism Solidity uses to allocate storage slots for mappings, but using a hash as the
         // mapping's storage slot, and subtracting 1 at the end. This should be more than enough to prevent collisions
         // with other state variables this or derived contracts might use.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/ERC4626Wrapping.sol standalone-utils/contracts/relayer/ERC4626Wrapping.sol
--- standalone-utils/contracts/relayer/ERC4626Wrapping.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/relayer/ERC4626Wrapping.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IERC4626.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IERC4626.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/GaugeActions.sol standalone-utils/contracts/relayer/GaugeActions.sol
--- standalone-utils/contracts/relayer/GaugeActions.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/relayer/GaugeActions.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,11 +15,11 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
-import "@balancer-labs/v2-interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/liquidity-mining/IBalancerMinter.sol";
+import "../../interfaces/contracts/liquidity-mining/IStakingLiquidityGauge.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/IBaseRelayerLibrary.sol standalone-utils/contracts/relayer/IBaseRelayerLibrary.sol
--- standalone-utils/contracts/relayer/IBaseRelayerLibrary.sol	2022-09-16 02:04:26.000000000 -0700
+++ standalone-utils/contracts/relayer/IBaseRelayerLibrary.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-vault/contracts/AssetHelpers.sol";
+import "../../vault/contracts/AssetHelpers.sol";
 
 /**
  * @title IBaseRelayerLibrary
@@ -31,8 +31,6 @@
 
     function approveVault(IERC20 token, uint256 amount) public virtual;
 
-    function peekChainedReferenceValue(uint256 ref) public view virtual returns (uint256);
-
     function _pullToken(
         address sender,
         IERC20 token,
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/LidoWrapping.sol standalone-utils/contracts/relayer/LidoWrapping.sol
--- standalone-utils/contracts/relayer/LidoWrapping.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/relayer/LidoWrapping.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,11 +15,11 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IstETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IwstETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/standalone-utils/IstETH.sol";
+import "../../interfaces/contracts/standalone-utils/IwstETH.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/UnbuttonWrapping.sol standalone-utils/contracts/relayer/UnbuttonWrapping.sol
--- standalone-utils/contracts/relayer/UnbuttonWrapping.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/relayer/UnbuttonWrapping.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-linear/IUnbuttonToken.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/pool-linear/IUnbuttonToken.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/VaultActions.sol standalone-utils/contracts/relayer/VaultActions.sol
--- standalone-utils/contracts/relayer/VaultActions.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/relayer/VaultActions.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,12 +15,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/VaultHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/VaultHelpers.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/VaultPermit.sol standalone-utils/contracts/relayer/VaultPermit.sol
--- standalone-utils/contracts/relayer/VaultPermit.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/relayer/VaultPermit.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20Permit.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20PermitDAI.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20Permit.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20PermitDAI.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
 import "./IBaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol
--- standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol	2022-09-16 02:04:26.000000000 -0700
+++ standalone-utils/contracts/relayer/special/DoubleEntrypointFixRelayer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,13 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/pool-stable/StablePoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol";
+import "../../interfaces/contracts/pool-stable/StablePoolUserData.sol";
+import "../../interfaces/contracts/pool-weighted/WeightedPoolUserData.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IFlashLoanRecipient.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ERC20Helpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/helpers/ERC20Helpers.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 import "hardhat/console.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/MockBaseRelayerLibrary.sol standalone-utils/contracts/test/MockBaseRelayerLibrary.sol
--- standalone-utils/contracts/test/MockBaseRelayerLibrary.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/test/MockBaseRelayerLibrary.sol	2022-09-16 02:18:01.000000000 -0700
@@ -16,7 +16,7 @@
 
 pragma solidity ^0.7.0;
 
-//import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IBaseRelayerLibrary.sol";
+//import "../../interfaces/contracts/standalone-utils/IBaseRelayerLibrary.sol";
 
 import "../relayer/BaseRelayerLibrary.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/MockStETH.sol standalone-utils/contracts/test/MockStETH.sol
--- standalone-utils/contracts/test/MockStETH.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/test/MockStETH.sol	2022-09-16 02:18:01.000000000 -0700
@@ -16,10 +16,10 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IstETH.sol";
+import "../../interfaces/contracts/standalone-utils/IstETH.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/test/TestToken.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/test/TestToken.sol";
 
 contract MockStETH is TestToken, IstETH {
     constructor(
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/MockWstETH.sol standalone-utils/contracts/test/MockWstETH.sol
--- standalone-utils/contracts/test/MockWstETH.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/test/MockWstETH.sol	2022-09-16 02:18:01.000000000 -0700
@@ -16,11 +16,11 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IstETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/standalone-utils/IwstETH.sol";
+import "../../interfaces/contracts/standalone-utils/IstETH.sol";
+import "../../interfaces/contracts/standalone-utils/IwstETH.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ERC20.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/openzeppelin/ERC20.sol";
 
 contract MockWstETH is ERC20, IwstETH {
     using FixedPoint for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/contracts/test/TestWETH.sol standalone-utils/contracts/test/TestWETH.sol
--- standalone-utils/contracts/test/TestWETH.sol	2022-06-22 10:15:28.000000000 -0700
+++ standalone-utils/contracts/test/TestWETH.sol	2022-09-16 02:18:01.000000000 -0700
@@ -16,7 +16,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
 
 contract TestWETH is IWETH {
     string public name = "Wrapped Ether";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/test/BaseRelayerLibrary.test.ts standalone-utils/test/BaseRelayerLibrary.test.ts
--- standalone-utils/test/BaseRelayerLibrary.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ standalone-utils/test/BaseRelayerLibrary.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -1,5 +1,5 @@
 import { ethers } from 'hardhat';
-import { BigNumber, Contract } from 'ethers';
+import { Contract } from 'ethers';
 import { expect } from 'chai';
 import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signer-with-address';
 
@@ -17,7 +17,6 @@
 describe('BaseRelayerLibrary', function () {
   let vault: Contract;
   let relayer: Contract, relayerLibrary: Contract;
-  let token: Contract;
   let otherRelayer: SignerWithAddress;
 
   let admin: SignerWithAddress, signer: SignerWithAddress;
@@ -34,7 +33,6 @@
     // Deploy Relayer
     relayerLibrary = await deploy('MockBaseRelayerLibrary', { args: [vault.address] });
     relayer = await deployedAt('BalancerRelayer', await relayerLibrary.getEntrypoint());
-    token = await deploy('TestWETH'); // Any ERC-20 will do.
   });
 
   describe('relayer getters', () => {
@@ -58,95 +56,40 @@
 
     describe('read and write', () => {
       const key = 5;
-
-      context('when the reference is temporary', () => {
-        const reference = toChainedReference(key, true);
-
-        itReadsAndWritesData(reference);
-
-        it('clears data after reading', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 5);
-          await expectChainedReferenceContents(reference, 5);
-
-          // The reference is now cleared
-          await expectChainedReferenceContents(reference, 0);
-        });
-      });
-
-      context('when the reference is not temporary', () => {
-        const reference = toChainedReference(key, false);
-
-        itReadsAndWritesData(reference);
-
-        it('preserves data after reading', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 5);
-          await expectChainedReferenceContents(reference, 5);
-
-          // The reference is preserved
-          await expectChainedReferenceContents(reference, 5);
-        });
-      });
+      const reference = toChainedReference(key);
 
       async function expectChainedReferenceContents(key: BigNumberish, expectedValue: BigNumberish): Promise<void> {
         const receipt = await (await relayerLibrary.getChainedReferenceValue(key)).wait();
         expectEvent.inReceipt(receipt, 'ChainedReferenceValueRead', { value: bn(expectedValue) });
       }
 
-      function itReadsAndWritesData(reference: BigNumber) {
-        it('reads uninitialized references as zero', async () => {
-          await expectChainedReferenceContents(reference, 0);
-        });
-
-        it('reads stored references', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 42);
-          await expectChainedReferenceContents(reference, 42);
-        });
-
-        it('writes replace old data', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 42);
-          await relayerLibrary.setChainedReferenceValue(reference, 17);
-          await expectChainedReferenceContents(reference, 17);
-        });
-
-        it('stored data in independent slots', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 5);
-          await expectChainedReferenceContents(reference.add(1), 0);
-        });
-
-        it('peeks uninitialized references as zero', async () => {
-          expect(await relayerLibrary.peekChainedReferenceValue(reference)).to.be.eq(0);
-        });
-
-        it('peeks stored references', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 23);
-          expect(await relayerLibrary.peekChainedReferenceValue(reference)).to.be.eq(23);
-        });
+      it('reads uninitialized references as zero', async () => {
+        await expectChainedReferenceContents(reference, 0);
+      });
 
-        it('peeks overwritten data', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 42);
-          await relayerLibrary.setChainedReferenceValue(reference, 17);
-          expect(await relayerLibrary.peekChainedReferenceValue(reference)).to.be.eq(17);
-        });
+      it('reads stored references', async () => {
+        await relayerLibrary.setChainedReferenceValue(reference, 42);
+        await expectChainedReferenceContents(reference, 42);
+      });
 
-        it('peeks stored data in independent slots', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 5);
-          expect(await relayerLibrary.peekChainedReferenceValue(reference.add(1))).to.be.eq(0);
-        });
+      it('writes replace old data', async () => {
+        await relayerLibrary.setChainedReferenceValue(reference, 42);
+        await relayerLibrary.setChainedReferenceValue(reference, 17);
+        await expectChainedReferenceContents(reference, 17);
+      });
 
-        it('peeks same slot multiple times', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 19);
-          expect(await relayerLibrary.peekChainedReferenceValue(reference)).to.be.eq(19);
-          expect(await relayerLibrary.peekChainedReferenceValue(reference)).to.be.eq(19);
-          expect(await relayerLibrary.peekChainedReferenceValue(reference)).to.be.eq(19);
-        });
+      it('stored data in independent slots', async () => {
+        await relayerLibrary.setChainedReferenceValue(reference, 5);
+        await expectChainedReferenceContents(reference.add(1), 0);
+      });
 
-        it('peeks and reads same slot', async () => {
-          await relayerLibrary.setChainedReferenceValue(reference, 31);
+      it('clears read data', async () => {
+        await relayerLibrary.setChainedReferenceValue(reference, 5);
+        await expectChainedReferenceContents(reference, 5);
 
-          expect(await relayerLibrary.peekChainedReferenceValue(reference)).to.be.eq(31);
-          await expectChainedReferenceContents(reference, 31);
-        });
-      }
+        // The reference is now cleared
+        await expectChainedReferenceContents(reference, 0);
+      });
     });
   });
 
@@ -295,37 +238,4 @@
       });
     });
   });
-
-  describe('approve vault', () => {
-    function itApprovesVault(approveAmount: BigNumberish, allowance: BigNumberish) {
-      it('approves vault to use tokens', async () => {
-        const tx = await relayerLibrary.approveVault(token.address, approveAmount);
-
-        expectEvent.inIndirectReceipt(await tx.wait(), token.interface, 'Approval', {
-          owner: relayerLibrary.address,
-          spender: vault.address,
-          value: allowance,
-        });
-        expect(await token.allowance(relayerLibrary.address, vault.address)).to.equal(allowance);
-      });
-    }
-
-    context('when using values as argument', () => {
-      // Argument sent to approveVault is equal to allowance.
-      itApprovesVault(145, 145);
-    });
-
-    context('when using chained references as argument', () => {
-      const key = 135;
-      const reference = toChainedReference(key);
-      const allowance = 7;
-
-      sharedBeforeEach('set reference', async () => {
-        await relayerLibrary.setChainedReferenceValue(reference, allowance);
-      });
-
-      // approveVault reads value from chained reference.
-      itApprovesVault(reference, allowance);
-    });
-  });
 });
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/test/UnbuttonWrapping.test.ts standalone-utils/test/UnbuttonWrapping.test.ts
--- standalone-utils/test/UnbuttonWrapping.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ standalone-utils/test/UnbuttonWrapping.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -13,12 +13,11 @@
 import { deploy, deployedAt } from '@balancer-labs/v2-helpers/src/contract';
 import { actionId } from '@balancer-labs/v2-helpers/src/models/misc/actions';
 import { ANY_ADDRESS, MAX_INT256, MAX_UINT256, ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
-import { BigNumberish, fp } from '@balancer-labs/v2-helpers/src/numbers';
+import { BigNumberish, bn, fp } from '@balancer-labs/v2-helpers/src/numbers';
 import Vault from '@balancer-labs/v2-helpers/src/models/vault/Vault';
 import { Account } from '@balancer-labs/v2-helpers/src/models/types/types';
 import TypesConverter from '@balancer-labs/v2-helpers/src/models/types/TypesConverter';
 import { Dictionary } from 'lodash';
-import { expectChainedReferenceContents, toChainedReference } from './helpers/chainedReferences';
 
 const amplFP = (n: number) => fp(n / 10 ** 9);
 
@@ -79,6 +78,14 @@
     await vault.instance.connect(senderUser).setRelayerApproval(senderUser.address, relayer.address, true);
   });
 
+  const CHAINED_REFERENCE_PREFIX = 'ba10';
+  function toChainedReference(key: BigNumberish): BigNumber {
+    // The full padded prefix is 66 characters long,
+    // with 64 hex characters and the 0x prefix.
+    const paddedPrefix = `0x${CHAINED_REFERENCE_PREFIX}${'0'.repeat(64 - CHAINED_REFERENCE_PREFIX.length)}`;
+    return BigNumber.from(paddedPrefix).add(key);
+  }
+
   function encodeApprove(token: Token, amount: BigNumberish): string {
     return relayerLibrary.interface.encodeFunctionData('approveVault', [token.address, amount]);
   }
@@ -117,6 +124,16 @@
     await relayer.multicall([relayerLibrary.interface.encodeFunctionData('setChainedReferenceValue', [ref, value])]);
   }
 
+  async function expectChainedReferenceContents(ref: BigNumberish, expectedValue: BigNumberish): Promise<void> {
+    const receipt = await (
+      await relayer.multicall([relayerLibrary.interface.encodeFunctionData('getChainedReferenceValue', [ref])])
+    ).wait();
+
+    expectEvent.inIndirectReceipt(receipt, relayerLibrary.interface, 'ChainedReferenceValueRead', {
+      value: bn(expectedValue),
+    });
+  }
+
   describe('primitives', () => {
     const amount = amplFP(1);
 
@@ -194,7 +211,7 @@
             .connect(senderUser)
             .multicall([encodeWrap(tokenSender, tokenRecipient, amount, toChainedReference(0))]);
 
-          await expectChainedReferenceContents(relayer, toChainedReference(0), expectedWamplAmount);
+          await expectChainedReferenceContents(toChainedReference(0), expectedWamplAmount);
         });
 
         it('wraps with chained references', async () => {
@@ -304,7 +321,7 @@
             .multicall([encodeUnwrap(tokenSender, tokenRecipient, amount, toChainedReference(0))]);
 
           const amplAmount = await wampl.instance.wrapperToUnderlying(amount);
-          await expectChainedReferenceContents(relayer, toChainedReference(0), amplAmount);
+          await expectChainedReferenceContents(toChainedReference(0), amplAmount);
         });
 
         it('unwraps with chained references', async () => {
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts standalone-utils/test/helpers/chainedReferences.ts standalone-utils/test/helpers/chainedReferences.ts
--- standalone-utils/test/helpers/chainedReferences.ts	2022-09-16 02:04:26.000000000 -0700
+++ standalone-utils/test/helpers/chainedReferences.ts	2022-09-16 02:18:01.000000000 -0700
@@ -4,13 +4,11 @@
 import { BigNumberish } from '@balancer-labs/v2-helpers/src/numbers';
 import * as expectEvent from '@balancer-labs/v2-helpers/src/test/expectEvent';
 
-export const CHAINED_REFERENCE_TEMP_PREFIX = 'ba10'; // Temporary reference: it is deleted after a read.
-export const CHAINED_REFERENCE_READONLY_PREFIX = 'ba11'; // Read-only reference: it is not deleted after a read.
+export const CHAINED_REFERENCE_PREFIX = 'ba10';
 
-export function toChainedReference(key: BigNumberish, isTemporary = true): BigNumber {
-  const prefix = isTemporary ? CHAINED_REFERENCE_TEMP_PREFIX : CHAINED_REFERENCE_READONLY_PREFIX;
+export function toChainedReference(key: BigNumberish): BigNumber {
   // The full padded prefix is 66 characters long, with 64 hex characters and the 0x prefix.
-  const paddedPrefix = `0x${prefix}${'0'.repeat(64 - prefix.length)}`;
+  const paddedPrefix = `0x${CHAINED_REFERENCE_PREFIX}${'0'.repeat(64 - CHAINED_REFERENCE_PREFIX.length)}`;
 
   return BigNumber.from(paddedPrefix).add(key);
 }
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/AssetHelpers.sol vault/contracts/AssetHelpers.sol
--- vault/contracts/AssetHelpers.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/AssetHelpers.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,9 +14,9 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/vault/IAsset.sol";
 
 abstract contract AssetHelpers {
     // solhint-disable-next-line var-name-mixedcase
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/AssetManagers.sol vault/contracts/AssetManagers.sol
--- vault/contracts/AssetManagers.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/AssetManagers.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,13 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./UserBalance.sol";
 import "./balances/BalanceAllocation.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/AssetTransfersHandler.sol vault/contracts/AssetTransfersHandler.sol
--- vault/contracts/AssetTransfersHandler.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/AssetTransfersHandler.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,15 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAsset.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/vault/IAsset.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./AssetHelpers.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/Fees.sol vault/contracts/Fees.sol
--- vault/contracts/Fees.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/Fees.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,13 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 import "./ProtocolFeesCollector.sol";
 import "./VaultAuthorization.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/FlashLoans.sol vault/contracts/FlashLoans.sol
--- vault/contracts/FlashLoans.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/FlashLoans.sol	2022-09-16 02:18:01.000000000 -0700
@@ -19,12 +19,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IFlashLoanRecipient.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 import "./Fees.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/PoolBalances.sol vault/contracts/PoolBalances.sol
--- vault/contracts/PoolBalances.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/PoolBalances.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,14 +15,14 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasePool.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IBasePool.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./Fees.sol";
 import "./PoolTokens.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/PoolRegistry.sol vault/contracts/PoolRegistry.sol
--- vault/contracts/PoolRegistry.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/PoolRegistry.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 import "./VaultAuthorization.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/PoolTokens.sol vault/contracts/PoolTokens.sol
--- vault/contracts/PoolTokens.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/PoolTokens.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 import "./AssetManagers.sol";
 import "./PoolRegistry.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/ProtocolFeesCollector.sol vault/contracts/ProtocolFeesCollector.sol
--- vault/contracts/ProtocolFeesCollector.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/ProtocolFeesCollector.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,12 +15,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IProtocolFeesCollector.sol";
+import "../../interfaces/contracts/vault/IProtocolFeesCollector.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
 
 /**
  * @dev This an auxiliary contract to the Vault, deployed by it during construction. It offloads some of the tasks the
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/Swaps.sol vault/contracts/Swaps.sol
--- vault/contracts/Swaps.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/Swaps.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,20 +15,20 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-interfaces/contracts/vault/IPoolSwapStructs.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeCast.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/vault/IPoolSwapStructs.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeCast.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./PoolBalances.sol";
 import "./balances/BalanceAllocation.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/UserBalance.sol vault/contracts/UserBalance.sol
--- vault/contracts/UserBalance.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/UserBalance.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,13 +15,13 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeCast.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeCast.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "./AssetTransfersHandler.sol";
 import "./VaultAuthorization.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/Vault.sol vault/contracts/Vault.sol
--- vault/contracts/Vault.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/Vault.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/misc/IWETH.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
+import "../../interfaces/contracts/solidity-utils/misc/IWETH.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
 
 import "./VaultAuthorization.sol";
 import "./FlashLoans.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/VaultAuthorization.sol vault/contracts/VaultAuthorization.sol
--- vault/contracts/VaultAuthorization.sol	2022-09-16 02:04:26.000000000 -0700
+++ vault/contracts/VaultAuthorization.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,14 +15,14 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/TemporarilyPausable.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
+
+import "../../solidity-utils/contracts/helpers/Authentication.sol";
+import "../../solidity-utils/contracts/helpers/ExtraCalldataEOASignaturesValidator.sol";
+import "../../solidity-utils/contracts/helpers/TemporarilyPausable.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 /**
  * @dev Manages access control of Vault permissioned functions by relying on the Authorizer and signature validation.
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/authorizer/TimelockAuthorizer.sol vault/contracts/authorizer/TimelockAuthorizer.sol
--- vault/contracts/authorizer/TimelockAuthorizer.sol	2022-09-16 02:04:26.000000000 -0700
+++ vault/contracts/authorizer/TimelockAuthorizer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,15 +15,15 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IAuthorizer.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/IAuthentication.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IAuthorizer.sol";
+
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 import "./TimelockExecutor.sol";
 
 /**
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/authorizer/TimelockExecutor.sol vault/contracts/authorizer/TimelockExecutor.sol
--- vault/contracts/authorizer/TimelockExecutor.sol	2022-09-16 02:04:26.000000000 -0700
+++ vault/contracts/authorizer/TimelockExecutor.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,8 +14,8 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/Address.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
+import "../../solidity-utils/contracts/openzeppelin/Address.sol";
+import "../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol";
 
 import "./TimelockAuthorizer.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/balances/BalanceAllocation.sol vault/contracts/balances/BalanceAllocation.sol
--- vault/contracts/balances/BalanceAllocation.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/balances/BalanceAllocation.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,7 +14,7 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../../solidity-utils/contracts/math/Math.sol";
 
 // This library is used to create a data structure that represents a token's balance for a Pool. 'cash' is how many
 // tokens the Pool has sitting inside of the Vault. 'managed' is how many tokens were withdrawn from the Vault by the
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/balances/GeneralPoolsBalance.sol vault/contracts/balances/GeneralPoolsBalance.sol
--- vault/contracts/balances/GeneralPoolsBalance.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/balances/GeneralPoolsBalance.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,10 +14,10 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
+import "../../../solidity-utils/contracts/openzeppelin/EnumerableMap.sol";
 
 import "./BalanceAllocation.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/balances/MinimalSwapInfoPoolsBalance.sol vault/contracts/balances/MinimalSwapInfoPoolsBalance.sol
--- vault/contracts/balances/MinimalSwapInfoPoolsBalance.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/balances/MinimalSwapInfoPoolsBalance.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
 
 import "./BalanceAllocation.sol";
 import "../PoolRegistry.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/balances/TwoTokenPoolsBalance.sol vault/contracts/balances/TwoTokenPoolsBalance.sol
--- vault/contracts/balances/TwoTokenPoolsBalance.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/balances/TwoTokenPoolsBalance.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,8 +15,8 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
 
 import "./BalanceAllocation.sol";
 import "../PoolRegistry.sol";
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockAssetTransfersHandler.sol vault/contracts/test/MockAssetTransfersHandler.sol
--- vault/contracts/test/MockAssetTransfersHandler.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/test/MockAssetTransfersHandler.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,9 +15,9 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 import "../AssetTransfersHandler.sol";
 
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockAuthenticatedContract.sol vault/contracts/test/MockAuthenticatedContract.sol
--- vault/contracts/test/MockAuthenticatedContract.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/test/MockAuthenticatedContract.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,7 +15,7 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/SingletonAuthentication.sol";
+import "../../solidity-utils/contracts/helpers/SingletonAuthentication.sol";
 
 /*
  * @author Balancer Labs
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockBasicAuthorizer.sol vault/contracts/test/MockBasicAuthorizer.sol
--- vault/contracts/test/MockBasicAuthorizer.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/test/MockBasicAuthorizer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,11 +15,11 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IBasicAuthorizer.sol";
+import "../../interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol";
+import "../../interfaces/contracts/vault/IBasicAuthorizer.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/openzeppelin/EnumerableSet.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
 
 contract MockBasicAuthorizer is IBasicAuthorizer {
     using EnumerableSet for EnumerableSet.AddressSet;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockFlashLoanRecipient.sol vault/contracts/test/MockFlashLoanRecipient.sol
--- vault/contracts/test/MockFlashLoanRecipient.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/test/MockFlashLoanRecipient.sol	2022-09-16 02:18:01.000000000 -0700
@@ -14,13 +14,13 @@
 
 pragma solidity ^0.7.0;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-
-import "@balancer-labs/v2-solidity-utils/contracts/openzeppelin/SafeERC20.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/test/TestToken.sol";
-import "@balancer-labs/v2-solidity-utils/contracts/math/Math.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IFlashLoanRecipient.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+
+import "../../solidity-utils/contracts/openzeppelin/SafeERC20.sol";
+import "../../solidity-utils/contracts/test/TestToken.sol";
+import "../../solidity-utils/contracts/math/Math.sol";
 
 contract MockFlashLoanRecipient is IFlashLoanRecipient {
     using Math for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockInternalBalanceRelayer.sol vault/contracts/test/MockInternalBalanceRelayer.sol
--- vault/contracts/test/MockInternalBalanceRelayer.sol	2022-06-22 10:15:28.000000000 -0700
+++ vault/contracts/test/MockInternalBalanceRelayer.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,10 +15,10 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
+import "../../solidity-utils/contracts/helpers/InputHelpers.sol";
 
 contract MockInternalBalanceRelayer {
     IVault public vault;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/contracts/test/MockPool.sol vault/contracts/test/MockPool.sol
--- vault/contracts/test/MockPool.sol	2022-09-16 02:04:26.000000000 -0700
+++ vault/contracts/test/MockPool.sol	2022-09-16 02:18:01.000000000 -0700
@@ -15,12 +15,12 @@
 pragma solidity ^0.7.0;
 pragma experimental ABIEncoderV2;
 
-import "@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IVault.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IGeneralPool.sol";
-import "@balancer-labs/v2-interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
+import "../../interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
+import "../../interfaces/contracts/vault/IVault.sol";
+import "../../interfaces/contracts/vault/IGeneralPool.sol";
+import "../../interfaces/contracts/vault/IMinimalSwapInfoPool.sol";
 
-import "@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol";
+import "../../solidity-utils/contracts/math/FixedPoint.sol";
 
 contract MockPool is IGeneralPool, IMinimalSwapInfoPool {
     using FixedPoint for uint256;
diff -ruN --exclude=node_modules --exclude=deployments --exclude=governance-scripts vault/test/FlashLoan.test.ts vault/test/FlashLoan.test.ts
--- vault/test/FlashLoan.test.ts	2022-09-16 02:04:26.000000000 -0700
+++ vault/test/FlashLoan.test.ts	2022-09-16 02:18:01.000000000 -0700
@@ -10,7 +10,7 @@
 import { deploy, deployedAt } from '@balancer-labs/v2-helpers/src/contract';
 import { actionId } from '@balancer-labs/v2-helpers/src/models/misc/actions';
 import { expectBalanceChange } from '@balancer-labs/v2-helpers/src/test/tokenBalance';
-import { bn, divCeil, fp, fpMul, FP_SCALING_FACTOR } from '@balancer-labs/v2-helpers/src/numbers';
+import { bn, divCeil, fp, FP_SCALING_FACTOR } from '@balancer-labs/v2-helpers/src/numbers';
 import TokensDeployer from '@balancer-labs/v2-helpers/src/models/tokens/TokensDeployer';
 import { ANY_ADDRESS, ZERO_ADDRESS } from '@balancer-labs/v2-helpers/src/constants';
 
@@ -141,7 +141,7 @@
       await recipient.setRepayInExcess(true);
 
       // The recipient pays one extra token
-      const feeAmount = fpMul(bn(1e18), feePercentage).add(1);
+      const feeAmount = bn(1e18).mul(feePercentage).div(FP_SCALING_FACTOR).add(1);
 
       const tx: ContractTransaction = await expectBalanceChange(
         () => vault.connect(other).flashLoan(recipient.address, [tokens.DAI.address], [bn(1e18)], '0x10'),
@@ -182,7 +182,7 @@
     describe('multi asset loan', () => {
       it('the Vault receives protocol fees proportional to each loan', async () => {
         const amounts = [1e18, 2e18].map(bn);
-        const feeAmounts = amounts.map((amount) => fpMul(amount, feePercentage));
+        const feeAmounts = amounts.map((amount) => amount.mul(feePercentage).div(FP_SCALING_FACTOR));
 
         await expectBalanceChange(
           () =>
