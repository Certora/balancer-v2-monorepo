diff -ruN .gitignore .gitignore
--- .gitignore	1969-12-31 16:00:00.000000000 -0800
+++ .gitignore	2022-08-08 14:57:52.000000000 -0700
@@ -0,0 +1,2 @@
+*
+!.gitignore
\ No newline at end of file
diff -ruN pool-stable/contracts/StablePool.sol pool-stable/contracts/StablePool.sol
--- pool-stable/contracts/StablePool.sol	2022-06-20 21:05:13.000000000 -0700
+++ pool-stable/contracts/StablePool.sol	2022-08-10 10:09:07.000000000 -0700
@@ -22,8 +22,8 @@
 import "@balancer-labs/v2-solidity-utils/contracts/helpers/InputHelpers.sol";
 import "@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol";
 
-import "@balancer-labs/v2-pool-utils/contracts/BaseGeneralPool.sol";
-import "@balancer-labs/v2-pool-utils/contracts/LegacyBaseMinimalSwapInfoPool.sol";
+import "../../pool-utils/contracts/BaseGeneralPool.sol"; // MUNGED changed to path to be relative
+import "../../pool-utils/contracts/LegacyBaseMinimalSwapInfoPool.sol"; // MUNGED changed to path to be relative
 
 import "./StableMath.sol";
 
@@ -682,7 +682,7 @@
         precision = StableMath._AMP_PRECISION;
     }
 
-    function _getAmplificationParameter() internal view returns (uint256 value, bool isUpdating) {
+    function _getAmplificationParameter() public view returns (uint256 value, bool isUpdating) { // HARNESS: changed to public
         (uint256 startValue, uint256 endValue, uint256 startTime, uint256 endTime) = _getAmplificationData();
 
         // Note that block.timestamp >= startTime, since startTime is set to the current time when an update starts
diff -ruN pool-utils/contracts/BasePool.sol pool-utils/contracts/BasePool.sol
--- pool-utils/contracts/BasePool.sol	2022-08-05 17:23:33.000000000 -0700
+++ pool-utils/contracts/BasePool.sol	2022-08-08 14:57:52.000000000 -0700
@@ -631,7 +631,7 @@
      * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead
      * *mutates* the `amounts` array.
      */
-        function _downscaleUpArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {
+    function _downscaleUpArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {
         for (uint256 i = 0; i < _getTotalTokens(); ++i) {
             amounts[i] = FixedPoint.divUp(amounts[i], scalingFactors[i]);
         }
diff -ruN pool-utils/contracts/LegacyBasePool.sol pool-utils/contracts/LegacyBasePool.sol
--- pool-utils/contracts/LegacyBasePool.sol	2022-08-07 15:41:40.000000000 -0700
+++ pool-utils/contracts/LegacyBasePool.sol	2022-08-08 14:57:52.000000000 -0700
@@ -355,7 +355,9 @@
         return (amountsOut, dueProtocolFeeAmounts);
     }
 
-    // Query functions
+    // Query functions ///////////// MUNGED ////////////////
+    // replaced function pointer inputs in queryAction with a direct implementation in queryJoin and queryExit instead 
+    // as CVL can not deal with function pointers as inputs
 
     /**
      * @notice "Dry run" `onJoinPool`.
@@ -379,21 +381,110 @@
     ) external returns (uint256 bptOut, uint256[] memory amountsIn) {
         InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
 
-        _queryAction(
-            poolId,
-            sender,
-            recipient,
-            balances,
-            lastChangeBlock,
-            protocolSwapFeePercentage,
-            userData,
-            _onJoinPool,
-            _downscaleUpArray
-        );
+        if (msg.sender != address(this)) {
+            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of
+            // the preceding if statement will be executed instead.
+
+            // solhint-disable-next-line avoid-low-level-calls
+            (bool success, ) = address(this).call(msg.data);
+
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                // This call should always revert to decode the bpt and token amounts from the revert reason
+                switch success
+                    case 0 {
+                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is
+                        // stored there as we take full control of the execution and then immediately return.
+
+                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise
+                        // there was another revert reason and we should forward it.
+                        returndatacopy(0, 0, 0x04)
+                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)
+
+                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.
+                        if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {
+                            returndatacopy(0, 0, returndatasize())
+                            revert(0, returndatasize())
+                        }
+
+                        // The returndata contains the signature, followed by the raw memory representation of the
+                        // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded
+                        // representation of these.
+                        // An ABI-encoded response will include one additional field to indicate the starting offset of
+                        // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the
+                        // returndata.
+                        //
+                        // In returndata:
+                        // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]
+                        // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]
+                        //
+                        // We now need to return (ABI-encoded values):
+                        // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]
+                        // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]
+
+                        // We copy 32 bytes for the `bptAmount` from returndata into memory.
+                        // Note that we skip the first 4 bytes for the error signature
+                        returndatacopy(0, 0x04, 32)
+
+                        // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after
+                        // the initial 64 bytes.
+                        mstore(0x20, 64)
+
+                        // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.
+                        // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also
+                        // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.
+                        returndatacopy(0x40, 0x24, sub(returndatasize(), 36))
+
+                        // We finally return the ABI-encoded uint256 and the array, which has a total length equal to
+                        // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the
+                        // error signature.
+                        return(0, add(returndatasize(), 28))
+                    }
+                    default {
+                        // This call should always revert, but we fail nonetheless if that didn't happen
+                        invalid()
+                    }
+            }
+        } else {
+            uint256[] memory scalingFactors = _scalingFactors();
+            _upscaleArray(balances, scalingFactors);
+
+            (uint256 bptAmount, uint256[] memory tokenAmounts, ) = _onJoinPool(
+                poolId,
+                sender,
+                recipient,
+                balances,
+                lastChangeBlock,
+                protocolSwapFeePercentage,
+                scalingFactors,
+                userData
+            );
 
-        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
-        // and we don't need to return anything here - it just silences compiler warnings.
-        return (bptOut, amountsIn);
+            _downscaleUpArray(tokenAmounts, scalingFactors);
+
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of
+                // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values
+                // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32
+                let size := mul(mload(tokenAmounts), 32)
+
+                // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there
+                // will be at least one available slot due to how the memory scratch space works.
+                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.
+                let start := sub(tokenAmounts, 0x20)
+                mstore(start, bptAmount)
+
+                // We send one extra value for the error signature "QueryError(uint256,uint256[])" which is 0x43adbafb
+                // We use the previous slot to `bptAmount`.
+                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)
+                start := sub(start, 0x04)
+
+                // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return
+                // the `bptAmount`, the array 's length, and the error signature.
+                revert(start, add(size, 68))
+            }
+        }
     }
 
     /**
@@ -415,24 +506,116 @@
         uint256 lastChangeBlock,
         uint256 protocolSwapFeePercentage,
         bytes memory userData
-    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {
+    ) external returns (uint256, uint256[] memory) {
         InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());
 
-        _queryAction(
-            poolId,
-            sender,
-            recipient,
-            balances,
-            lastChangeBlock,
-            protocolSwapFeePercentage,
-            userData,
-            _onExitPool,
-            _downscaleDownArray
-        );
+        // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed
+        // explanation.
+
+        if (msg.sender != address(this)) {
+            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of
+            // the preceding if statement will be executed instead.
+
+            // solhint-disable-next-line avoid-low-level-calls
+            (bool success, ) = address(this).call(msg.data);
+
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                // This call should always revert to decode the bpt and token amounts from the revert reason
+                switch success
+                    case 0 {
+                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is
+                        // stored there as we take full control of the execution and then immediately return.
+
+                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise
+                        // there was another revert reason and we should forward it.
+                        returndatacopy(0, 0, 0x04)
+                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)
+
+                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.
+                        if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {
+                            returndatacopy(0, 0, returndatasize())
+                            revert(0, returndatasize())
+                        }
+
+                        // The returndata contains the signature, followed by the raw memory representation of the
+                        // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded
+                        // representation of these.
+                        // An ABI-encoded response will include one additional field to indicate the starting offset of
+                        // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the
+                        // returndata.
+                        //
+                        // In returndata:
+                        // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]
+                        // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]
+                        //
+                        // We now need to return (ABI-encoded values):
+                        // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]
+                        // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]
+
+                        // We copy 32 bytes for the `bptAmount` from returndata into memory.
+                        // Note that we skip the first 4 bytes for the error signature
+                        returndatacopy(0, 0x04, 32)
 
-        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,
-        // and we don't need to return anything here - it just silences compiler warnings.
-        return (bptIn, amountsOut);
+                        // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after
+                        // the initial 64 bytes.
+                        mstore(0x20, 64)
+
+                        // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.
+                        // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also
+                        // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.
+                        returndatacopy(0x40, 0x24, sub(returndatasize(), 36))
+
+                        // We finally return the ABI-encoded uint256 and the array, which has a total length equal to
+                        // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the
+                        // error signature.
+                        return(0, add(returndatasize(), 28))
+                    }
+                    default {
+                        // This call should always revert, but we fail nonetheless if that didn't happen
+                        invalid()
+                    }
+            }
+        } else {
+            uint256[] memory scalingFactors = _scalingFactors();
+            _upscaleArray(balances, scalingFactors);
+
+            (uint256 bptAmount, uint256[] memory tokenAmounts, ) = _onExitPool(
+                poolId,
+                sender,
+                recipient,
+                balances,
+                lastChangeBlock,
+                protocolSwapFeePercentage,
+                scalingFactors,
+                userData
+            );
+
+            _downscaleDownArray(tokenAmounts, scalingFactors);
+
+            // solhint-disable-next-line no-inline-assembly
+            assembly {
+                // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of
+                // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values
+                // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32
+                let size := mul(mload(tokenAmounts), 32)
+
+                // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there
+                // will be at least one available slot due to how the memory scratch space works.
+                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.
+                let start := sub(tokenAmounts, 0x20)
+                mstore(start, bptAmount)
+
+                // We send one extra value for the error signature "QueryError(uint256,uint256[])" which is 0x43adbafb
+                // We use the previous slot to `bptAmount`.
+                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)
+                start := sub(start, 0x04)
+
+                // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return
+                // the `bptAmount`, the array 's length, and the error signature.
+                revert(start, add(size, 68))
+            }
+        }
     }
 
     // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are
