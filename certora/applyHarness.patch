diff -ruN ../pkg/.gitignore .gitignore
--- ../pkg/.gitignore	1969-12-31 18:00:00.000000000 -0600
+++ .gitignore	2022-06-27 16:04:04.000000000 -0500
@@ -0,0 +1,2 @@
+*
+!.gitignore
diff -ruN ../pkg/solidity-utihelpers/WordCodec.sol solidity-utihelpers/WordCodec.sol
--- ../pkg/solidity-utihelpers/WordCodec.sol	2022-06-27 11:34:42.000000000 -0500
+++ solidity-utihelpers/WordCodec.sol	2022-06-27 16:31:32.000000000 -0500
@@ -33,7 +33,7 @@
  * and the cost of accesing memory increases quadratically with the number of allocated words. Manual packing and
  * unpacking is therefore the preferred approach.
  */
-library WordCodec {
+contract WordCodec { // HARNESS: library -> contract
     // Masks are values with the least significant N bits set. They can be used to extract an encoded value from a word,
     // or to insert a new one replacing the old.
     uint256 private constant _MASK_1 = 2**(1) - 1;
@@ -50,7 +50,7 @@
         uint256 value,
         uint256 offset,
         uint256 bitLength
-    ) internal pure returns (bytes32) {
+    ) public pure returns (bytes32) { // HARNESS: internal -> public
         _validateEncodingParams(value, offset, bitLength);
 
         uint256 mask = (1 << bitLength) - 1;
@@ -69,7 +69,7 @@
         int256 value,
         uint256 offset,
         uint256 bitLength
-    ) internal pure returns (bytes32) {
+    ) public pure returns (bytes32) { // HARNESS: internal -> public
         _validateEncodingParams(value, offset, bitLength);
 
         uint256 mask = (1 << bitLength) - 1;
@@ -90,7 +90,7 @@
         uint256 value,
         uint256 offset,
         uint256 bitLength
-    ) internal pure returns (bytes32) {
+    ) public pure returns (bytes32) { // HARNESS: internal -> public
         _validateEncodingParams(value, offset, bitLength);
 
         return bytes32(value << offset);
@@ -105,7 +105,7 @@
         int256 value,
         uint256 offset,
         uint256 bitLength
-    ) internal pure returns (bytes32) {
+    ) public pure returns (bytes32) { // HARNESS: internal -> public
         _validateEncodingParams(value, offset, bitLength);
 
         uint256 mask = (1 << bitLength) - 1;
@@ -122,7 +122,7 @@
         bytes32 word,
         uint256 offset,
         uint256 bitLength
-    ) internal pure returns (uint256) {
+    ) public pure returns (uint256) { // HARNESS: internal -> public
         return uint256(word >> offset) & ((1 << bitLength) - 1);
     }
 
@@ -133,7 +133,7 @@
         bytes32 word,
         uint256 offset,
         uint256 bitLength
-    ) internal pure returns (int256) {
+    ) public pure returns (int256) { // HARNESS: internal -> public
         int256 maxInt = int256((1 << (bitLength - 1)) - 1);
         uint256 mask = (1 << bitLength) - 1;
 
@@ -149,7 +149,7 @@
     /**
      * @dev Decodes and returns a boolean shifted by an offset from a 256 bit word.
      */
-    function decodeBool(bytes32 word, uint256 offset) internal pure returns (bool) {
+    function decodeBool(bytes32 word, uint256 offset) public pure returns (bool) { // HARNESS: internal -> public
         return (uint256(word >> offset) & _MASK_1) == 1;
     }
 
@@ -163,7 +163,7 @@
         bytes32 word,
         bytes32 value,
         uint256 offset
-    ) internal pure returns (bytes32) {
+    ) public pure returns (bytes32) { // HARNESS: internal -> public
         bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_192 << offset));
         return clearedWord | bytes32((uint256(value) & _MASK_192) << offset);
     }
@@ -176,7 +176,7 @@
         bytes32 word,
         bool value,
         uint256 offset
-    ) internal pure returns (bytes32) {
+    ) public pure returns (bytes32) { // HARNESS: internal -> public
         bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_1 << offset));
         return clearedWord | bytes32(uint256(value ? 1 : 0) << offset);
     }
